v8-version,10,2,154,26,-node.36,0
v8-platform,linux,linux
shared-library,/home/gin/.local/share/nvm/v18.20.2/bin/node,0x400000,0x4fec000,0
shared-library,/usr/lib/x86_64-linux-gnu/libc.so.6,0x7f6e64f03000,0x7f6e650c0000,0
shared-library,/usr/lib/x86_64-linux-gnu/libpthread.so.0,0x7f6e6512c000,0x7f6e6512e000,0
shared-library,/usr/lib/x86_64-linux-gnu/libgcc_s.so.1,0x7f6e65131000,0x7f6e6514b000,0
shared-library,/usr/lib/x86_64-linux-gnu/libm.so.6,0x7f6e65151000,0x7f6e651db000,0
shared-library,/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30,0x7f6e65238000,0x7f6e653e3000,0
shared-library,/usr/lib/x86_64-linux-gnu/libdl.so.2,0x7f6e65464000,0x7f6e65466000,0
shared-library,/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2,0x7f6e6547b000,0x7f6e654a7000,0
shared-library,[vdso],0x7fff49347000,0x7fff49349000,0
shared-library-end
profiler,begin,1000
tick,0x7f6e64f94117,595,0,0x0,6
new,CodeRange,0x6557000,0
new,MemoryChunk,0x443f8e40000,262144
new,MemoryChunk,0x796b5680000,262144
new,MemoryChunk,0x3ea77c980000,262144
new,MemoryChunk,0x2801da800000,262144
new,MemoryChunk,0x3cdec0880000,262144
heap-capacity,1030976
heap-available,2198828672
new,MemoryChunk,0x2aac13700000,262144
tick,0x131b05d,1656,0,0x0,6
new,MemoryChunk,0x2bd542180000,262144
new,MemoryChunk,0x23f41f780000,262144
new,MemoryChunk,0x28d42e280000,262144
new,MemoryChunk,0x32bbd7440000,262144
tick,0x131fa92,2719,0,0x0,6
new,MemoryChunk,0x13800b140000,262144
new,MemoryChunk,0x1d7bd0ec0000,262144
new,MemoryChunk,0x6580000,262144
new,MemoryChunk,0x556af5c0000,262144
tick,0x11b9440,3785,0,0x0,6
code-creation,Builtin,2,3933,0x1688cc0,792,DeoptimizationEntry_Eager
code-creation,Builtin,2,3941,0x1689000,796,DeoptimizationEntry_Lazy
code-creation,Builtin,2,3944,0x1689340,796,DeoptimizationEntry_Unused
code-creation,Builtin,2,3946,0x1689680,1364,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,3949,0x1689c00,460,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,3952,0x1689e00,644,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,3954,0x168a0c0,216,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,3957,0x168a1c0,364,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,3959,0x168a340,128,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,3961,0x168a400,64,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,3963,0x168a480,284,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,3966,0x168a5c0,336,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,3968,0x168a740,372,CallFunction_ReceiverIsAny
code-creation,Builtin,2,3971,0x168a8c0,104,CallBoundFunction
code-creation,Builtin,2,3973,0x168a940,828,CallWrappedFunction
code-creation,Builtin,2,3975,0x168ac80,168,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,3977,0x168ad40,168,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,3979,0x168ae00,168,Call_ReceiverIsAny
code-creation,Builtin,2,3981,0x168aec0,972,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,3984,0x168b2c0,964,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,3987,0x168b6c0,1052,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,3989,0x168bb00,1044,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,3992,0x168bf40,1052,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,3994,0x168c380,1044,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,3997,0x168c7c0,916,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,3999,0x168cb80,916,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,4002,0x168cf40,916,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,4004,0x168d300,744,CallProxy
code-creation,Builtin,2,4006,0x168d600,120,CallVarargs
code-creation,Builtin,2,4008,0x168d680,940,CallWithSpread
code-creation,Builtin,2,4012,0x168da40,1944,CallWithSpread_Baseline
code-creation,Builtin,2,4014,0x168e200,1888,CallWithSpread_WithFeedback
code-creation,Builtin,2,4017,0x168e980,936,CallWithArrayLike
code-creation,Builtin,2,4019,0x168ed40,1864,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,4021,0x168f4c0,124,CallForwardVarargs
code-creation,Builtin,2,4027,0x168f540,124,CallFunctionForwardVarargs
code-creation,Builtin,2,4030,0x168f5c0,136,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,4032,0x168f680,236,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,4035,0x168f780,324,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,4038,0x168f900,32,ConstructFunction
code-creation,Builtin,2,4040,0x168f940,104,ConstructBoundFunction
code-creation,Builtin,2,4042,0x168f9c0,28,ConstructedNonConstructable
code-creation,Builtin,2,4044,0x168fa00,100,Construct
code-creation,Builtin,2,4046,0x168fa80,120,ConstructVarargs
code-creation,Builtin,2,4048,0x168fb00,964,ConstructWithSpread
code-creation,Builtin,2,4050,0x168ff00,1748,ConstructWithSpread_Baseline
code-creation,Builtin,2,4053,0x1690600,1736,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,4055,0x1690d00,964,ConstructWithArrayLike
code-creation,Builtin,2,4057,0x1691100,1700,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,4060,0x16917c0,164,ConstructForwardVarargs
code-creation,Builtin,2,4062,0x1691880,164,ConstructFunctionForwardVarargs
code-creation,Builtin,2,4064,0x1691940,772,Construct_Baseline
code-creation,Builtin,2,4066,0x1691c80,796,Construct_WithFeedback
code-creation,Builtin,2,4068,0x1691fc0,444,JSConstructStubGeneric
code-creation,Builtin,2,4071,0x1692180,336,JSBuiltinsConstructStub
code-creation,Builtin,2,4073,0x1692300,652,FastNewObject
code-creation,Builtin,2,4075,0x16925c0,296,FastNewClosure
code-creation,Builtin,2,4077,0x1692700,724,ConstructProxy
code-creation,Builtin,2,4079,0x1692a00,192,JSEntry
code-creation,Builtin,2,4081,0x1692b00,192,JSConstructEntry
code-creation,Builtin,2,4083,0x1692c00,192,JSRunMicrotasksEntry
code-creation,Builtin,2,4085,0x1692d00,100,JSEntryTrampoline
code-creation,Builtin,2,4087,0x1692d80,100,JSConstructEntryTrampoline
code-creation,Builtin,2,4089,0x1692e00,288,ResumeGeneratorTrampoline
code-creation,Builtin,2,4091,0x1692f40,1500,StringFromCodePointAt
code-creation,Builtin,2,4093,0x1693540,528,StringEqual
code-creation,Builtin,2,4096,0x1693780,280,StringGreaterThan
code-creation,Builtin,2,4098,0x16938c0,280,StringGreaterThanOrEqual
code-creation,Builtin,2,4100,0x1693a00,280,StringLessThan
code-creation,Builtin,2,4102,0x1693b40,280,StringLessThanOrEqual
code-creation,Builtin,2,4104,0x1693c80,2420,StringSubstring
code-creation,Builtin,2,4106,0x1694600,80,OrderedHashTableHealIndex
code-creation,Builtin,2,4108,0x1694680,1264,InterpreterEntryTrampoline
code-creation,Builtin,2,4111,0x1694b80,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,4113,0x1694c00,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,4115,0x1694c80,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,4118,0x1694d00,84,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,4120,0x1694d80,84,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,4123,0x1694e00,88,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,4126,0x1694e80,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,4128,0x1694f00,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,4130,0x1695000,52,InterpreterOnStackReplacement
code-creation,Builtin,2,4132,0x1695040,688,BaselineOutOfLinePrologue
code-creation,Builtin,2,4135,0x1695300,56,BaselineOnStackReplacement
code-creation,Builtin,2,4137,0x1695340,84,BaselineLeaveFrame
code-creation,Builtin,2,4139,0x16953c0,220,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,4142,0x16954c0,228,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,4144,0x16955c0,196,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,4147,0x16956c0,1184,CompileLazy
code-creation,Builtin,2,4149,0x1695b80,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,4151,0x1695c00,256,InstantiateAsmJs
code-creation,Builtin,2,4153,0x1695d40,32,NotifyDeoptimized
code-creation,Builtin,2,4155,0x1695d80,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,4157,0x1695dc0,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,4161,0x1695e00,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,4164,0x1695e40,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,4166,0x1695ec0,292,CallApiCallback
code-creation,Builtin,2,4168,0x1696000,276,CallApiGetter
code-creation,Builtin,2,4170,0x1696140,12,HandleApiCall
code-creation,Builtin,2,4172,0x1696180,12,HandleApiCallAsFunction
code-creation,Builtin,2,4175,0x16961c0,12,HandleApiCallAsConstructor
code-creation,Builtin,2,4177,0x1696200,64,AllocateInYoungGeneration
code-creation,Builtin,2,4179,0x1696280,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,4181,0x16962c0,64,AllocateInOldGeneration
code-creation,Builtin,2,4184,0x1696340,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,4186,0x1696380,432,CopyFastSmiOrObjectElements
code-creation,Builtin,2,4188,0x1696540,508,GrowFastDoubleElements
code-creation,Builtin,2,4190,0x1696740,400,GrowFastSmiOrObjectElements
code-creation,Builtin,2,4193,0x1696900,480,DebugBreakTrampoline
code-creation,Builtin,2,4195,0x1696b00,184,ToNumber
code-creation,Builtin,2,4197,0x1696bc0,300,ToNumber_Baseline
code-creation,Builtin,2,4199,0x1696d00,368,ToNumeric_Baseline
code-creation,Builtin,2,4201,0x1696e80,104,PlainPrimitiveToNumber
code-creation,Builtin,2,4203,0x1696f00,224,ToNumberConvertBigInt
code-creation,Builtin,2,4221,0x1697000,140,Typeof
code-creation,Builtin,2,4223,0x16970c0,108,BigIntToI64
code-creation,Builtin,2,4225,0x1697140,4,BigIntToI32Pair
code-creation,Builtin,2,4227,0x1697180,228,I64ToBigInt
code-creation,Builtin,2,4229,0x1697280,4,I32PairToBigInt
code-creation,Builtin,2,4231,0x16972c0,112,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,4233,0x1697340,4044,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,4235,0x1698340,15484,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,4237,0x169bfc0,11992,DefineKeyedOwnIC_Megamorphic
code-creation,Builtin,2,4240,0x169eec0,464,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,4242,0x169f0c0,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,4244,0x169f140,12,LoadIC_StringLength
code-creation,Builtin,2,4246,0x169f180,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,4248,0x169f1c0,3064,LoadIC_NoFeedback
code-creation,Builtin,2,4250,0x169fdc0,32,StoreGlobalIC_Slow
code-creation,Builtin,2,4252,0x169fe00,7312,StoreIC_NoFeedback
code-creation,Builtin,2,4254,0x16a1ac0,3224,DefineNamedOwnIC_NoFeedback
code-creation,Builtin,2,4256,0x16a2780,184,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,4258,0x16a2840,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,4261,0x16a28c0,244,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,4263,0x16a29c0,244,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,4266,0x16a2ac0,244,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,4269,0x16a2bc0,244,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,4271,0x16a2cc0,14448,StoreFastElementIC_Standard
code-creation,Builtin,2,4273,0x16a6540,9864,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,4276,0x16a8c00,13660,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,4278,0x16ac180,5676,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,4281,0x16ad7c0,8584,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,4283,0x16af980,19624,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,4286,0x16b4640,8584,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,4289,0x16b6800,11168,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,4291,0x16b93c0,820,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,4293,0x16b9700,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,4295,0x16b97c0,72,HasIndexedInterceptorIC
code-creation,Builtin,2,4298,0x16b9840,172,EnqueueMicrotask
code-creation,Builtin,2,4300,0x16b9900,8,RunMicrotasksTrampoline
code-creation,Builtin,2,4302,0x16b9940,3744,RunMicrotasks
code-creation,Builtin,2,4304,0x16ba800,2716,HasProperty
code-creation,Builtin,2,4306,0x16bb2c0,1168,DeleteProperty
code-creation,Builtin,2,4309,0x16bb780,2004,CopyDataProperties
code-creation,Builtin,2,4311,0x16bbf80,9352,SetDataProperties
code-creation,Builtin,2,4313,0x16be440,2736,CopyDataPropertiesWithExcludedPropertiesOnStack
code-creation,Builtin,2,4316,0x16bef00,56,CopyDataPropertiesWithExcludedProperties
code-creation,Builtin,2,4318,0x16bef40,28,Abort
code-creation,Builtin,2,4320,0x16bef80,28,AbortCSADcheck
code-creation,Builtin,2,4322,0x16befc0,12,EmptyFunction
code-creation,Builtin,2,4324,0x16bf000,12,Illegal
code-creation,Builtin,2,4325,0x16bf040,12,StrictPoisonPillThrower
code-creation,Builtin,2,4327,0x16bf080,12,UnsupportedThrower
code-creation,Builtin,2,4330,0x16bf0c0,60,ReturnReceiver
code-creation,Builtin,2,4331,0x16bf100,36,ArrayConstructor
code-creation,Builtin,2,4334,0x16bf140,412,ArrayConstructorImpl
code-creation,Builtin,2,4336,0x16bf300,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,4338,0x16bf400,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,4341,0x16bf500,180,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,4344,0x16bf5c0,180,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,4347,0x16bf680,180,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,4349,0x16bf740,180,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,4352,0x16bf800,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,4355,0x16bf900,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,4358,0x16bfa00,508,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,4361,0x16bfc00,472,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,4364,0x16bfe00,436,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,4367,0x16bffc0,400,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,4369,0x16c0180,436,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,4372,0x16c0340,400,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,4375,0x16c0500,444,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,4378,0x16c06c0,408,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,4381,0x16c0880,56,ArrayNArgumentsConstructor
code-creation,Builtin,2,4383,0x16c08c0,12,ArrayConcat
code-creation,Builtin,2,4385,0x16c0900,12,ArrayPrototypeFill
code-creation,Builtin,2,4387,0x16c0940,928,ArrayIncludesSmiOrObject
code-creation,Builtin,2,4389,0x16c0d00,152,ArrayIncludesPackedDoubles
code-creation,Builtin,2,4391,0x16c0dc0,220,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,4394,0x16c0ec0,544,ArrayIncludes
code-creation,Builtin,2,4395,0x16c1100,844,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,4398,0x16c1480,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,4400,0x16c1500,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,4402,0x16c1580,548,ArrayIndexOf
code-creation,Builtin,2,4404,0x16c17c0,12,ArrayPop
code-creation,Builtin,2,4406,0x16c1800,608,ArrayPrototypePop
code-creation,Builtin,2,4407,0x16c1a80,12,ArrayPrototypeGroupBy
code-creation,Builtin,2,4410,0x16c1ac0,12,ArrayPrototypeGroupByToMap
code-creation,Builtin,2,4412,0x16c1b00,12,ArrayPush
code-creation,Builtin,2,4414,0x16c1b40,2420,ArrayPrototypePush
code-creation,Builtin,2,4416,0x16c24c0,12,ArrayShift
code-creation,Builtin,2,4418,0x16c2500,12,ArrayUnshift
code-creation,Builtin,2,4419,0x16c2540,952,CloneFastJSArray
code-creation,Builtin,2,4421,0x16c2900,2164,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,4424,0x16c3180,984,ExtractFastJSArray
code-creation,Builtin,2,4426,0x16c3580,260,ArrayPrototypeEntries
code-creation,Builtin,2,4428,0x16c36c0,244,ArrayPrototypeKeys
code-creation,Builtin,2,4430,0x16c37c0,260,ArrayPrototypeValues
code-creation,Builtin,2,4432,0x16c3900,4464,ArrayIteratorPrototypeNext
code-creation,Builtin,2,4435,0x16c4a80,4148,FlattenIntoArray
code-creation,Builtin,2,4437,0x16c5ac0,4160,FlatMapIntoArray
code-creation,Builtin,2,4439,0x16c6b40,384,ArrayPrototypeFlat
code-creation,Builtin,2,4441,0x16c6d00,444,ArrayPrototypeFlatMap
code-creation,Builtin,2,4443,0x16c6ec0,12,ArrayBufferConstructor
code-creation,Builtin,2,4446,0x16c6f00,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,4448,0x16c6f40,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,4450,0x16c6f80,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,4452,0x16c6fc0,924,AsyncFunctionEnter
code-creation,Builtin,2,4455,0x16c7380,80,AsyncFunctionReject
code-creation,Builtin,2,4457,0x16c7400,76,AsyncFunctionResolve
code-creation,Builtin,2,4459,0x16c7480,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,4461,0x16c74c0,1820,AsyncFunctionAwaitCaught
code-creation,Builtin,2,4463,0x16c7c00,1820,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,4466,0x16c8340,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,4468,0x16c8400,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,4470,0x16c84c0,12,BigIntConstructor
code-creation,Builtin,2,4472,0x16c8500,12,BigIntAsUintN
code-creation,Builtin,2,4474,0x16c8540,12,BigIntAsIntN
code-creation,Builtin,2,4476,0x16c8580,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,4478,0x16c85c0,12,BigIntPrototypeToString
code-creation,Builtin,2,4480,0x16c8600,12,BigIntPrototypeValueOf
code-creation,Builtin,2,4483,0x16c8640,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,4485,0x16c8680,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,4487,0x16c86c0,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,4490,0x16c8700,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,4492,0x16c8740,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,4494,0x16c8780,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,4496,0x16c87c0,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,4499,0x16c8800,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,4501,0x16c8840,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,4503,0x16c8880,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,4505,0x16c88c0,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,4508,0x16c8900,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,4510,0x16c8940,12,CallSitePrototypeGetThis
code-creation,Builtin,2,4512,0x16c8980,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,4515,0x16c89c0,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,4517,0x16c8a00,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,4519,0x16c8a40,12,CallSitePrototypeIsEval
code-creation,Builtin,2,4521,0x16c8a80,12,CallSitePrototypeIsNative
code-creation,Builtin,2,4523,0x16c8ac0,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,4525,0x16c8b00,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,4527,0x16c8b40,12,CallSitePrototypeToString
code-creation,Builtin,2,4530,0x16c8b80,12,ConsoleDebug
code-creation,Builtin,2,4532,0x16c8bc0,12,ConsoleError
code-creation,Builtin,2,4533,0x16c8c00,12,ConsoleInfo
code-creation,Builtin,2,4535,0x16c8c40,12,ConsoleLog
code-creation,Builtin,2,4537,0x16c8c80,12,ConsoleWarn
code-creation,Builtin,2,4539,0x16c8cc0,12,ConsoleDir
code-creation,Builtin,2,4541,0x16c8d00,12,ConsoleDirXml
code-creation,Builtin,2,4543,0x16c8d40,12,ConsoleTable
code-creation,Builtin,2,4545,0x16c8d80,12,ConsoleTrace
code-creation,Builtin,2,4547,0x16c8dc0,12,ConsoleGroup
code-creation,Builtin,2,4548,0x16c8e00,12,ConsoleGroupCollapsed
code-creation,Builtin,2,4551,0x16c8e40,12,ConsoleGroupEnd
code-creation,Builtin,2,4553,0x16c8e80,12,ConsoleClear
code-creation,Builtin,2,4554,0x16c8ec0,12,ConsoleCount
code-creation,Builtin,2,4556,0x16c8f00,12,ConsoleCountReset
code-creation,Builtin,2,4558,0x16c8f40,12,ConsoleAssert
code-creation,Builtin,2,4560,0x16c8f80,12,ConsoleProfile
code-creation,Builtin,2,4562,0x16c8fc0,12,ConsoleProfileEnd
code-creation,Builtin,2,4564,0x16c9000,12,ConsoleTime
code-creation,Builtin,2,4566,0x16c9040,12,ConsoleTimeLog
code-creation,Builtin,2,4569,0x16c9080,12,ConsoleTimeEnd
code-creation,Builtin,2,4571,0x16c90c0,12,ConsoleTimeStamp
code-creation,Builtin,2,4573,0x16c9100,12,ConsoleContext
code-creation,Builtin,2,4575,0x16c9140,12,DataViewConstructor
code-creation,Builtin,2,4577,0x16c9180,12,DateConstructor
code-creation,Builtin,2,4579,0x16c91c0,224,DatePrototypeGetDate
code-creation,Builtin,2,4581,0x16c92c0,224,DatePrototypeGetDay
code-creation,Builtin,2,4583,0x16c93c0,224,DatePrototypeGetFullYear
code-creation,Builtin,2,4585,0x16c94c0,224,DatePrototypeGetHours
code-creation,Builtin,2,4587,0x16c95c0,212,DatePrototypeGetMilliseconds
code-creation,Builtin,2,4589,0x16c96c0,224,DatePrototypeGetMinutes
code-creation,Builtin,2,4592,0x16c97c0,224,DatePrototypeGetMonth
code-creation,Builtin,2,4594,0x16c98c0,224,DatePrototypeGetSeconds
code-creation,Builtin,2,4596,0x16c99c0,124,DatePrototypeGetTime
code-creation,Builtin,2,4598,0x16c9a40,212,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,4600,0x16c9b40,212,DatePrototypeGetUTCDate
code-creation,Builtin,2,4602,0x16c9c40,212,DatePrototypeGetUTCDay
code-creation,Builtin,2,4604,0x16c9d40,212,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,4607,0x16c9e40,212,DatePrototypeGetUTCHours
code-creation,Builtin,2,4609,0x16c9f40,212,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,4611,0x16ca040,212,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,4613,0x16ca140,212,DatePrototypeGetUTCMonth
code-creation,Builtin,2,4615,0x16ca240,212,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,4618,0x16ca340,124,DatePrototypeValueOf
code-creation,Builtin,2,4620,0x16ca3c0,372,DatePrototypeToPrimitive
code-creation,Builtin,2,4622,0x16ca540,12,DatePrototypeGetYear
code-creation,Builtin,2,4624,0x16ca580,12,DatePrototypeSetYear
code-creation,Builtin,2,4626,0x16ca5c0,12,DateNow
code-creation,Builtin,2,4627,0x16ca600,12,DateParse
code-creation,Builtin,2,4629,0x16ca640,12,DatePrototypeSetDate
code-creation,Builtin,2,4631,0x16ca680,12,DatePrototypeSetFullYear
code-creation,Builtin,2,4634,0x16ca6c0,12,DatePrototypeSetHours
code-creation,Builtin,2,4636,0x16ca700,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,4638,0x16ca740,12,DatePrototypeSetMinutes
code-creation,Builtin,2,4640,0x16ca780,12,DatePrototypeSetMonth
code-creation,Builtin,2,4642,0x16ca7c0,12,DatePrototypeSetSeconds
code-creation,Builtin,2,4644,0x16ca800,12,DatePrototypeSetTime
code-creation,Builtin,2,4646,0x16ca840,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,4648,0x16ca880,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,4650,0x16ca8c0,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,4653,0x16ca900,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,4655,0x16ca940,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,4657,0x16ca980,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,4659,0x16ca9c0,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,4661,0x16caa00,12,DatePrototypeToDateString
code-creation,Builtin,2,4663,0x16caa40,12,DatePrototypeToISOString
code-creation,Builtin,2,4666,0x16caa80,12,DatePrototypeToUTCString
code-creation,Builtin,2,4668,0x16caac0,12,DatePrototypeToString
code-creation,Builtin,2,4670,0x16cab00,12,DatePrototypeToTimeString
code-creation,Builtin,2,4672,0x16cab40,12,DatePrototypeToJson
code-creation,Builtin,2,4674,0x16cab80,12,DateUTC
code-creation,Builtin,2,4675,0x16cabc0,12,ErrorConstructor
code-creation,Builtin,2,4677,0x16cac00,12,ErrorCaptureStackTrace
code-creation,Builtin,2,4680,0x16cac40,12,ErrorPrototypeToString
code-creation,Builtin,2,4682,0x16cac80,12,FunctionConstructor
code-creation,Builtin,2,4684,0x16cacc0,80,FunctionPrototypeApply
code-creation,Builtin,2,4686,0x16cad40,12,FunctionPrototypeBind
code-creation,Builtin,2,4688,0x16cad80,36,FunctionPrototypeCall
code-creation,Builtin,2,4690,0x16cadc0,12,FunctionPrototypeToString
code-creation,Builtin,2,4692,0x16cae00,192,CreateIterResultObject
code-creation,Builtin,2,4694,0x16caf00,812,CreateGeneratorObject
code-creation,Builtin,2,4696,0x16cb240,12,GeneratorFunctionConstructor
code-creation,Builtin,2,4699,0x16cb280,416,GeneratorPrototypeNext
code-creation,Builtin,2,4702,0x16cb440,420,GeneratorPrototypeReturn
code-creation,Builtin,2,4704,0x16cb600,424,GeneratorPrototypeThrow
code-creation,Builtin,2,4706,0x16cb7c0,12,AsyncFunctionConstructor
code-creation,Builtin,2,4708,0x16cb800,384,SuspendGeneratorBaseline
code-creation,Builtin,2,4710,0x16cb9c0,100,ResumeGeneratorBaseline
code-creation,Builtin,2,4712,0x16cba40,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,4715,0x16cba80,12,GlobalDecodeURI
code-creation,Builtin,2,4717,0x16cbac0,12,GlobalDecodeURIComponent
code-creation,Builtin,2,4719,0x16cbb00,12,GlobalEncodeURI
code-creation,Builtin,2,4721,0x16cbb40,12,GlobalEncodeURIComponent
code-creation,Builtin,2,4723,0x16cbb80,12,GlobalEscape
code-creation,Builtin,2,4725,0x16cbbc0,12,GlobalUnescape
code-creation,Builtin,2,4727,0x16cbc00,12,GlobalEval
code-creation,Builtin,2,4729,0x16cbc40,136,GlobalIsFinite
code-creation,Builtin,2,4731,0x16cbd00,132,GlobalIsNaN
code-creation,Builtin,2,4733,0x16cbdc0,12,JsonParse
code-creation,Builtin,2,4735,0x16cbe00,12,JsonStringify
code-creation,Builtin,2,4736,0x16cbe40,4340,LoadIC
code-creation,Builtin,2,4738,0x16ccf40,4156,LoadIC_Megamorphic
code-creation,Builtin,2,4740,0x16cdf80,4352,LoadIC_Noninlined
code-creation,Builtin,2,4742,0x16cf0c0,44,LoadICTrampoline
code-creation,Builtin,2,4744,0x16cf100,24,LoadICBaseline
code-creation,Builtin,2,4746,0x16cf140,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,4748,0x16cf180,7196,LoadSuperIC
code-creation,Builtin,2,4750,0x16d0dc0,24,LoadSuperICBaseline
code-creation,Builtin,2,4752,0x16d0e00,8204,KeyedLoadIC
code-creation,Builtin,2,4754,0x16d2e40,13196,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,4756,0x16d6200,44,KeyedLoadICTrampoline
code-creation,Builtin,2,4758,0x16d6240,24,KeyedLoadICBaseline
code-creation,Builtin,2,4760,0x16d6280,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,4763,0x16d62c0,5072,StoreGlobalIC
code-creation,Builtin,2,4765,0x16d76c0,44,StoreGlobalICTrampoline
code-creation,Builtin,2,4767,0x16d7700,24,StoreGlobalICBaseline
code-creation,Builtin,2,4769,0x16d7740,5276,StoreIC
code-creation,Builtin,2,4770,0x16d8c00,44,StoreICTrampoline
code-creation,Builtin,2,4772,0x16d8c40,24,StoreICBaseline
code-creation,Builtin,2,4774,0x16d8c80,5088,DefineNamedOwnIC
code-creation,Builtin,2,4776,0x16da080,44,DefineNamedOwnICTrampoline
code-creation,Builtin,2,4779,0x16da0c0,24,DefineNamedOwnICBaseline
code-creation,Builtin,2,4781,0x16da100,5744,KeyedStoreIC
code-creation,Builtin,2,4783,0x16db780,44,KeyedStoreICTrampoline
code-creation,Builtin,2,4785,0x16db7c0,24,KeyedStoreICBaseline
code-creation,Builtin,2,4787,0x16db800,5564,DefineKeyedOwnIC
code-creation,Builtin,2,4789,0x16dcdc0,44,DefineKeyedOwnICTrampoline
code-creation,Builtin,2,4791,0x16dce00,24,DefineKeyedOwnICBaseline
code-creation,Builtin,2,4793,0x16dce40,384,StoreInArrayLiteralIC
code-creation,Builtin,2,4795,0x16dd000,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,4798,0x16dd040,140,LookupContextBaseline
code-creation,Builtin,2,4800,0x16dd100,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,4802,0x16dd1c0,3036,LoadGlobalIC
code-creation,Builtin,2,4804,0x16dddc0,3020,LoadGlobalICInsideTypeof
code-creation,Builtin,2,4806,0x16de9c0,44,LoadGlobalICTrampoline
code-creation,Builtin,2,4808,0x16dea00,24,LoadGlobalICBaseline
code-creation,Builtin,2,4810,0x16dea40,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,4812,0x16dea80,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,4815,0x16deac0,144,LookupGlobalICBaseline
code-creation,Builtin,2,4817,0x16deb80,144,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,4819,0x16dec40,2048,CloneObjectIC
code-creation,Builtin,2,4821,0x16df480,24,CloneObjectICBaseline
code-creation,Builtin,2,4823,0x16df4c0,2060,CloneObjectIC_Slow
code-creation,Builtin,2,4825,0x16dfd00,2908,KeyedHasIC
code-creation,Builtin,2,4827,0x16e0880,24,KeyedHasICBaseline
code-creation,Builtin,2,4829,0x16e08c0,2716,KeyedHasIC_Megamorphic
code-creation,Builtin,2,4849,0x16e1380,1456,IterableToList
code-creation,Builtin,2,4867,0x16e1940,1260,IterableToFixedArray
code-creation,Builtin,2,4886,0x16e1e40,736,IterableToListWithSymbolLookup
code-creation,Builtin,2,4903,0x16e2140,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,4920,0x16e2180,128,IterableToListMayPreserveHoles
code-creation,Builtin,2,4936,0x16e2240,1012,IterableToFixedArrayForWasm
code-creation,Builtin,2,4952,0x16e2640,1516,StringListFromIterable
code-creation,Builtin,2,4968,0x16e2c40,1216,FindOrderedHashMapEntry
code-creation,Builtin,2,4984,0x16e3140,4212,MapConstructor
code-creation,Builtin,2,4999,0x16e41c0,1968,MapPrototypeSet
code-creation,Builtin,2,5015,0x16e4980,1532,MapPrototypeDelete
code-creation,Builtin,2,5031,0x16e4f80,208,MapPrototypeGet
code-creation,Builtin,2,5047,0x16e5080,168,MapPrototypeHas
code-creation,Builtin,2,5064,0x16e5140,12,MapPrototypeClear
code-creation,Builtin,2,5080,0x16e5180,284,MapPrototypeEntries
code-creation,Builtin,2,5096,0x16e52c0,144,MapPrototypeGetSize
code-creation,Builtin,2,5112,0x16e5380,500,MapPrototypeForEach
code-creation,Builtin,2,5128,0x16e5580,288,MapPrototypeKeys
code-creation,Builtin,2,5144,0x16e56c0,288,MapPrototypeValues
code-creation,Builtin,2,5160,0x16e5800,1048,MapIteratorPrototypeNext
code-creation,Builtin,2,5176,0x16e5c40,1180,MapIteratorToList
code-creation,Builtin,2,5192,0x16e6100,12,NumberPrototypeToExponential
code-creation,Builtin,2,5208,0x16e6140,12,NumberPrototypeToFixed
code-creation,Builtin,2,5224,0x16e6180,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,5240,0x16e61c0,12,NumberPrototypeToPrecision
code-creation,Builtin,2,5256,0x16e6200,324,SameValue
code-creation,Builtin,2,5274,0x16e6380,200,SameValueNumbersOnly
code-creation,Builtin,2,5291,0x16e6480,792,Add_Baseline
code-creation,Builtin,2,5307,0x16e67c0,652,AddSmi_Baseline
code-creation,Builtin,2,5323,0x16e6a80,832,Subtract_Baseline
code-creation,Builtin,2,5339,0x16e6e00,692,SubtractSmi_Baseline
code-creation,Builtin,2,5355,0x16e70c0,820,Multiply_Baseline
code-creation,Builtin,2,5371,0x16e7400,712,MultiplySmi_Baseline
code-creation,Builtin,2,5387,0x16e7700,836,Divide_Baseline
code-creation,Builtin,2,5403,0x16e7a80,772,DivideSmi_Baseline
code-creation,Builtin,2,5419,0x16e7dc0,776,Modulus_Baseline
code-creation,Builtin,2,5435,0x16e8100,668,ModulusSmi_Baseline
code-creation,Builtin,2,5451,0x16e83c0,824,Exponentiate_Baseline
code-creation,Builtin,2,5467,0x16e8700,720,ExponentiateSmi_Baseline
code-creation,Builtin,2,5483,0x16e8a00,792,BitwiseAnd_Baseline
code-creation,Builtin,2,5499,0x16e8d40,376,BitwiseAndSmi_Baseline
code-creation,Builtin,2,5515,0x16e8ec0,788,BitwiseOr_Baseline
code-creation,Builtin,2,5531,0x16e9200,376,BitwiseOrSmi_Baseline
code-creation,Builtin,2,5547,0x16e9380,792,BitwiseXor_Baseline
code-creation,Builtin,2,5563,0x16e96c0,376,BitwiseXorSmi_Baseline
code-creation,Builtin,2,5579,0x16e9840,812,ShiftLeft_Baseline
code-creation,Builtin,2,5595,0x16e9b80,400,ShiftLeftSmi_Baseline
code-creation,Builtin,2,5611,0x16e9d40,812,ShiftRight_Baseline
code-creation,Builtin,2,5627,0x16ea080,388,ShiftRightSmi_Baseline
code-creation,Builtin,2,5644,0x16ea240,924,ShiftRightLogical_Baseline
code-creation,Builtin,2,5660,0x16ea600,652,ShiftRightLogicalSmi_Baseline
code-creation,Builtin,2,5676,0x16ea8c0,724,Add_WithFeedback
code-creation,Builtin,2,5692,0x16eabc0,784,Subtract_WithFeedback
code-creation,Builtin,2,5708,0x16eaf00,784,Multiply_WithFeedback
code-creation,Builtin,2,5724,0x16eb240,812,Divide_WithFeedback
code-creation,Builtin,2,5740,0x16eb580,736,Modulus_WithFeedback
code-creation,Builtin,2,5756,0x16eb880,788,Exponentiate_WithFeedback
code-creation,Builtin,2,5772,0x16ebbc0,772,BitwiseAnd_WithFeedback
code-creation,Builtin,2,5788,0x16ebf00,768,BitwiseOr_WithFeedback
code-creation,Builtin,2,5804,0x16ec240,772,BitwiseXor_WithFeedback
code-creation,Builtin,2,5820,0x16ec580,784,ShiftLeft_WithFeedback
code-creation,Builtin,2,5836,0x16ec8c0,784,ShiftRight_WithFeedback
code-creation,Builtin,2,5852,0x16ecc00,900,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,5869,0x16ecfc0,1692,Equal_Baseline
code-creation,Builtin,2,5885,0x16ed680,896,StrictEqual_Baseline
code-creation,Builtin,2,5893,0x16eda40,1260,LessThan_Baseline
code-creation,Builtin,2,5895,0x16edf40,1256,GreaterThan_Baseline
tick,0x7f6e650178bf,5914,0,0x0,6
tick,0x7f6e64f94337,5933,0,0x0,6
code-creation,Builtin,2,5939,0x16ee440,1260,LessThanOrEqual_Baseline
code-creation,Builtin,2,5950,0x16ee940,1256,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,5952,0x16eee40,1632,Equal_WithFeedback
code-creation,Builtin,2,5954,0x16ef4c0,920,StrictEqual_WithFeedback
code-creation,Builtin,2,5957,0x16ef880,1240,LessThan_WithFeedback
code-creation,Builtin,2,5959,0x16efd80,1240,GreaterThan_WithFeedback
code-creation,Builtin,2,5961,0x16f0280,1240,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,5963,0x16f0780,1240,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,5965,0x16f0c80,356,BitwiseNot_Baseline
code-creation,Builtin,2,5967,0x16f0e00,460,Decrement_Baseline
code-creation,Builtin,2,5969,0x16f1000,464,Increment_Baseline
code-creation,Builtin,2,5971,0x16f1200,492,Negate_Baseline
code-creation,Builtin,2,5973,0x16f1400,344,BitwiseNot_WithFeedback
code-creation,Builtin,2,5975,0x16f1580,440,Decrement_WithFeedback
code-creation,Builtin,2,5977,0x16f1740,444,Increment_WithFeedback
code-creation,Builtin,2,5980,0x16f1900,472,Negate_WithFeedback
code-creation,Builtin,2,5982,0x16f1b00,264,ObjectAssign
code-creation,Builtin,2,5984,0x16f1c40,864,ObjectCreate
code-creation,Builtin,2,5985,0x16f1fc0,12,ObjectDefineGetter
code-creation,Builtin,2,5988,0x16f2000,12,ObjectDefineProperties
code-creation,Builtin,2,5990,0x16f2040,12,ObjectDefineProperty
code-creation,Builtin,2,5992,0x16f2080,12,ObjectDefineSetter
code-creation,Builtin,2,5994,0x16f20c0,1476,ObjectEntries
code-creation,Builtin,2,5996,0x16f26c0,12,ObjectFreeze
code-creation,Builtin,2,5997,0x16f2700,5632,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,6000,0x16f3d40,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,6007,0x16f3d80,596,ObjectGetOwnPropertyNames
code-creation,Builtin,2,6009,0x16f4000,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,6011,0x16f4040,168,ObjectHasOwn
code-creation,Builtin,2,6013,0x16f4100,388,ObjectIs
code-creation,Builtin,2,6015,0x16f42c0,12,ObjectIsFrozen
code-creation,Builtin,2,6017,0x16f4300,12,ObjectIsSealed
code-creation,Builtin,2,6019,0x16f4340,532,ObjectKeys
code-creation,Builtin,2,6021,0x16f4580,12,ObjectLookupGetter
code-creation,Builtin,2,6023,0x16f45c0,12,ObjectLookupSetter
code-creation,Builtin,2,6025,0x16f4600,2364,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,6027,0x16f4f40,236,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,6029,0x16f5040,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,6032,0x16f5080,12,ObjectPrototypeGetProto
code-creation,Builtin,2,6034,0x16f50c0,12,ObjectPrototypeSetProto
code-creation,Builtin,2,6036,0x16f5100,12,ObjectSeal
code-creation,Builtin,2,6038,0x16f5140,1132,ObjectToString
code-creation,Builtin,2,6040,0x16f55c0,1248,ObjectValues
code-creation,Builtin,2,6041,0x16f5ac0,296,OrdinaryHasInstance
code-creation,Builtin,2,6044,0x16f5c00,368,InstanceOf
code-creation,Builtin,2,6046,0x16f5d80,636,InstanceOf_WithFeedback
code-creation,Builtin,2,6048,0x16f6000,656,InstanceOf_Baseline
code-creation,Builtin,2,6050,0x16f62c0,268,ForInEnumerate
code-creation,Builtin,2,6052,0x16f6400,148,ForInPrepare
code-creation,Builtin,2,6054,0x16f64c0,2668,ForInFilter
code-creation,Builtin,2,6055,0x16f6f40,56,ReflectApply
code-creation,Builtin,2,6057,0x16f6f80,64,ReflectConstruct
code-creation,Builtin,2,6059,0x16f7000,12,ReflectDefineProperty
code-creation,Builtin,2,6061,0x16f7040,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,6064,0x16f7080,12,ReflectOwnKeys
code-creation,Builtin,2,6066,0x16f70c0,12,ReflectSet
code-creation,Builtin,2,6067,0x16f7100,12,RegExpCapture1Getter
code-creation,Builtin,2,6069,0x16f7140,12,RegExpCapture2Getter
code-creation,Builtin,2,6071,0x16f7180,12,RegExpCapture3Getter
code-creation,Builtin,2,6074,0x16f71c0,12,RegExpCapture4Getter
code-creation,Builtin,2,6076,0x16f7200,12,RegExpCapture5Getter
code-creation,Builtin,2,6078,0x16f7240,12,RegExpCapture6Getter
code-creation,Builtin,2,6083,0x16f7280,12,RegExpCapture7Getter
code-creation,Builtin,2,6085,0x16f72c0,12,RegExpCapture8Getter
code-creation,Builtin,2,6087,0x16f7300,12,RegExpCapture9Getter
code-creation,Builtin,2,6089,0x16f7340,2140,RegExpConstructor
code-creation,Builtin,2,6091,0x16f7bc0,12,RegExpInputGetter
code-creation,Builtin,2,6093,0x16f7c00,12,RegExpInputSetter
code-creation,Builtin,2,6095,0x16f7c40,12,RegExpLastMatchGetter
code-creation,Builtin,2,6097,0x16f7c80,12,RegExpLastParenGetter
code-creation,Builtin,2,6099,0x16f7cc0,12,RegExpLeftContextGetter
code-creation,Builtin,2,6102,0x16f7d00,848,RegExpPrototypeCompile
code-creation,Builtin,2,6104,0x16f8080,12,RegExpPrototypeToString
code-creation,Builtin,2,6106,0x16f80c0,12,RegExpRightContextGetter
code-creation,Builtin,2,6108,0x16f8100,252,RegExpExecAtom
code-creation,Builtin,2,6110,0x16f8200,1004,RegExpExecInternal
code-creation,Builtin,2,6112,0x16f8600,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,6114,0x16f8640,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,6117,0x16f8680,2764,SetConstructor
code-creation,Builtin,2,6119,0x16f9180,1312,SetPrototypeHas
code-creation,Builtin,2,6121,0x16f96c0,1744,SetPrototypeAdd
code-creation,Builtin,2,6123,0x16f9dc0,1492,SetPrototypeDelete
code-creation,Builtin,2,6125,0x16fa3c0,12,SetPrototypeClear
code-creation,Builtin,2,6127,0x16fa400,288,SetPrototypeEntries
code-creation,Builtin,2,6129,0x16fa540,144,SetPrototypeGetSize
code-creation,Builtin,2,6131,0x16fa600,464,SetPrototypeForEach
code-creation,Builtin,2,6133,0x16fa800,288,SetPrototypeValues
code-creation,Builtin,2,6135,0x16fa940,984,SetIteratorPrototypeNext
code-creation,Builtin,2,6137,0x16fad40,1112,SetOrSetIteratorToList
code-creation,Builtin,2,6139,0x16fb1c0,12,ShadowRealmConstructor
code-creation,Builtin,2,6141,0x16fb200,572,ShadowRealmGetWrappedValue
code-creation,Builtin,2,6143,0x16fb440,12,ShadowRealmPrototypeEvaluate
code-creation,Builtin,2,6146,0x16fb480,12,ShadowRealmPrototypeImportValue
code-creation,Builtin,2,6148,0x16fb4c0,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,6151,0x16fb500,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,6153,0x16fb540,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,6155,0x16fb580,1336,AtomicsLoad
code-creation,Builtin,2,6157,0x16fbac0,1068,AtomicsStore
code-creation,Builtin,2,6159,0x16fbf00,1716,AtomicsExchange
code-creation,Builtin,2,6161,0x16fc5c0,2064,AtomicsCompareExchange
code-creation,Builtin,2,6163,0x16fce00,1804,AtomicsAdd
code-creation,Builtin,2,6165,0x16fd540,1804,AtomicsSub
code-creation,Builtin,2,6167,0x16fdc80,1804,AtomicsAnd
code-creation,Builtin,2,6169,0x16fe3c0,1804,AtomicsOr
code-creation,Builtin,2,6171,0x16feb00,1804,AtomicsXor
code-creation,Builtin,2,6172,0x16ff240,12,AtomicsNotify
code-creation,Builtin,2,6174,0x16ff280,12,AtomicsIsLockFree
code-creation,Builtin,2,6176,0x16ff2c0,12,AtomicsWait
code-creation,Builtin,2,6178,0x16ff300,12,AtomicsWaitAsync
code-creation,Builtin,2,6180,0x16ff340,12,StringFromCodePoint
code-creation,Builtin,2,6182,0x16ff380,1456,StringFromCharCode
code-creation,Builtin,2,6184,0x16ff940,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,6187,0x16ff980,4316,StringPrototypeMatchAll
code-creation,Builtin,2,6189,0x1700a80,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,6191,0x1700ac0,1216,StringPrototypeReplace
code-creation,Builtin,2,6193,0x1700fc0,2900,StringPrototypeSplit
code-creation,Builtin,2,6195,0x1701b40,12,StringRaw
code-creation,Builtin,2,6197,0x1701b80,12,SymbolConstructor
code-creation,Builtin,2,6199,0x1701bc0,12,SymbolFor
code-creation,Builtin,2,6201,0x1701c00,12,SymbolKeyFor
code-creation,Builtin,2,6203,0x1701c40,88,TypedArrayBaseConstructor
code-creation,Builtin,2,6205,0x1701cc0,264,TypedArrayConstructor
code-creation,Builtin,2,6207,0x1701e00,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,6209,0x1701e40,908,TypedArrayPrototypeByteLength
code-creation,Builtin,2,6211,0x1702200,360,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,6214,0x1702380,612,TypedArrayPrototypeLength
code-creation,Builtin,2,6218,0x1702600,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,6220,0x1702640,12,TypedArrayPrototypeFill
code-creation,Builtin,2,6222,0x1702680,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,6224,0x17026c0,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,6227,0x1702700,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,6229,0x1702740,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,6231,0x1702780,304,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,6234,0x17028c0,24280,TypedArrayPrototypeMap
code-creation,Builtin,2,6236,0x17087c0,1000,GenericJSToWasmWrapper
code-creation,Builtin,2,6238,0x1708bc0,1176,WasmReturnPromiseOnSuspend
code-creation,Builtin,2,6240,0x1709080,156,WasmSuspend
code-creation,Builtin,2,6242,0x1709140,248,WasmResume
code-creation,Builtin,2,6244,0x1709240,160,WasmCompileLazy
code-creation,Builtin,2,6246,0x1709300,168,WasmDebugBreak
code-creation,Builtin,2,6248,0x17093c0,16,WasmOnStackReplace
code-creation,Builtin,2,6250,0x1709400,136,WasmFloat32ToNumber
code-creation,Builtin,2,6252,0x17094c0,148,WasmFloat64ToNumber
code-creation,Builtin,2,6254,0x1709580,4,WasmI32AtomicWait32
code-creation,Builtin,2,6256,0x17095c0,4,WasmI64AtomicWait32
code-creation,Builtin,2,6258,0x1709600,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,6261,0x1709640,4372,WeakMapConstructor
code-creation,Builtin,2,6263,0x170a780,252,WeakMapLookupHashIndex
code-creation,Builtin,2,6265,0x170a880,220,WeakMapGet
code-creation,Builtin,2,6267,0x170a980,180,WeakMapPrototypeHas
code-creation,Builtin,2,6269,0x170aa40,236,WeakMapPrototypeSet
code-creation,Builtin,2,6271,0x170ab40,144,WeakMapPrototypeDelete
code-creation,Builtin,2,6273,0x170ac00,2956,WeakSetConstructor
code-creation,Builtin,2,6275,0x170b7c0,180,WeakSetPrototypeHas
code-creation,Builtin,2,6277,0x170b880,236,WeakSetPrototypeAdd
code-creation,Builtin,2,6279,0x170b980,144,WeakSetPrototypeDelete
code-creation,Builtin,2,6281,0x170ba40,436,WeakCollectionDelete
code-creation,Builtin,2,6284,0x170bc00,832,WeakCollectionSet
code-creation,Builtin,2,6286,0x170bf80,12,SharedStructTypeConstructor
code-creation,Builtin,2,6288,0x170bfc0,12,SharedStructConstructor
code-creation,Builtin,2,6290,0x170c000,292,AsyncGeneratorResolve
code-creation,Builtin,2,6292,0x170c140,104,AsyncGeneratorReject
code-creation,Builtin,2,6294,0x170c1c0,1912,AsyncGeneratorYield
code-creation,Builtin,2,6296,0x170c940,2028,AsyncGeneratorReturn
code-creation,Builtin,2,6298,0x170d140,312,AsyncGeneratorResumeNext
code-creation,Builtin,2,6301,0x170d280,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,6303,0x170d2c0,1012,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,6305,0x170d6c0,1016,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,6308,0x170dac0,1016,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,6310,0x170dec0,1860,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,6312,0x170e640,1860,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,6314,0x170edc0,168,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,6317,0x170ee80,176,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,6319,0x170ef40,120,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,6322,0x170efc0,120,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,6324,0x170f040,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,6327,0x170f0c0,176,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,6329,0x170f180,1668,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,6331,0x170f840,1780,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,6334,0x170ff40,1800,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,6336,0x1710680,96,AsyncIteratorValueUnwrap
code-creation,Builtin,2,6338,0x1710700,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,6341,0x1710800,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,6344,0x1710900,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,6347,0x1710a00,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,6351,0x1710bc0,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,6354,0x1710d80,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,6356,0x1710e80,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,6359,0x1710f80,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,6362,0x1711080,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,6365,0x1711240,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,6367,0x1711400,4,DirectCEntry
code-creation,Builtin,2,6369,0x1711440,1072,StringAdd_CheckNone
code-creation,Builtin,2,6371,0x1711880,2416,SubString
code-creation,Builtin,2,6373,0x1712200,16,StackCheck
code-creation,Builtin,2,6375,0x1712240,84,DoubleToI
code-creation,Builtin,2,6377,0x17122c0,2276,GetProperty
code-creation,Builtin,2,6379,0x1712bc0,2368,GetPropertyWithReceiver
code-creation,Builtin,2,6382,0x1713540,15652,SetProperty
code-creation,Builtin,2,6384,0x1717280,13592,CreateDataProperty
code-creation,Builtin,2,6386,0x171a7c0,8,MemCopyUint8Uint8
code-creation,Builtin,2,6388,0x171a800,8,MemMove
code-creation,Builtin,2,6389,0x171a840,12,IsTraceCategoryEnabled
code-creation,Builtin,2,6392,0x171a880,12,Trace
code-creation,Builtin,2,6393,0x171a8c0,12,FinalizationRegistryUnregister
code-creation,Builtin,2,6396,0x171a900,420,AsyncModuleEvaluate
code-creation,Builtin,2,6398,0x171aac0,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,6400,0x171ab00,12,CallAsyncModuleRejected
code-creation,Builtin,2,6402,0x171ab40,12,TemporalNowTimeZone
code-creation,Builtin,2,6404,0x171ab80,12,TemporalNowInstant
code-creation,Builtin,2,6406,0x171abc0,12,TemporalNowPlainDateTime
code-creation,Builtin,2,6409,0x171ac00,12,TemporalNowPlainDateTimeISO
code-creation,Builtin,2,6411,0x171ac40,12,TemporalNowZonedDateTime
code-creation,Builtin,2,6413,0x171ac80,12,TemporalNowZonedDateTimeISO
code-creation,Builtin,2,6415,0x171acc0,12,TemporalNowPlainDate
code-creation,Builtin,2,6417,0x171ad00,12,TemporalNowPlainDateISO
code-creation,Builtin,2,6420,0x171ad40,12,TemporalNowPlainTimeISO
code-creation,Builtin,2,6422,0x171ad80,12,TemporalPlainDateConstructor
code-creation,Builtin,2,6424,0x171adc0,12,TemporalPlainDateFrom
code-creation,Builtin,2,6426,0x171ae00,12,TemporalPlainDateCompare
code-creation,Builtin,2,6428,0x171ae40,12,TemporalPlainDatePrototypeCalendar
code-creation,Builtin,2,6431,0x171ae80,12,TemporalPlainDatePrototypeYear
code-creation,Builtin,2,6433,0x171aec0,12,TemporalPlainDatePrototypeMonth
code-creation,Builtin,2,6435,0x171af00,12,TemporalPlainDatePrototypeMonthCode
code-creation,Builtin,2,6438,0x171af40,12,TemporalPlainDatePrototypeDay
code-creation,Builtin,2,6440,0x171af80,12,TemporalPlainDatePrototypeDayOfWeek
code-creation,Builtin,2,6442,0x171afc0,12,TemporalPlainDatePrototypeDayOfYear
code-creation,Builtin,2,6445,0x171b000,12,TemporalPlainDatePrototypeWeekOfYear
code-creation,Builtin,2,6447,0x171b040,12,TemporalPlainDatePrototypeDaysInWeek
code-creation,Builtin,2,6450,0x171b080,12,TemporalPlainDatePrototypeDaysInMonth
code-creation,Builtin,2,6452,0x171b0c0,12,TemporalPlainDatePrototypeDaysInYear
code-creation,Builtin,2,6455,0x171b100,12,TemporalPlainDatePrototypeMonthsInYear
code-creation,Builtin,2,6457,0x171b140,12,TemporalPlainDatePrototypeInLeapYear
code-creation,Builtin,2,6459,0x171b180,12,TemporalPlainDatePrototypeToPlainYearMonth
code-creation,Builtin,2,6462,0x171b1c0,12,TemporalPlainDatePrototypeToPlainMonthDay
code-creation,Builtin,2,6464,0x171b200,12,TemporalPlainDatePrototypeGetISOFields
code-creation,Builtin,2,6467,0x171b240,12,TemporalPlainDatePrototypeAdd
code-creation,Builtin,2,6469,0x171b280,12,TemporalPlainDatePrototypeSubtract
code-creation,Builtin,2,6472,0x171b2c0,12,TemporalPlainDatePrototypeWith
code-creation,Builtin,2,6474,0x171b300,12,TemporalPlainDatePrototypeWithCalendar
code-creation,Builtin,2,6476,0x171b340,12,TemporalPlainDatePrototypeUntil
code-creation,Builtin,2,6479,0x171b380,12,TemporalPlainDatePrototypeSince
code-creation,Builtin,2,6482,0x171b3c0,12,TemporalPlainDatePrototypeEquals
code-creation,Builtin,2,6485,0x171b400,12,TemporalPlainDatePrototypeToPlainDateTime
code-creation,Builtin,2,6487,0x171b440,12,TemporalPlainDatePrototypeToZonedDateTime
code-creation,Builtin,2,6490,0x171b480,12,TemporalPlainDatePrototypeToString
code-creation,Builtin,2,6492,0x171b4c0,12,TemporalPlainDatePrototypeToJSON
code-creation,Builtin,2,6495,0x171b500,12,TemporalPlainDatePrototypeValueOf
code-creation,Builtin,2,6497,0x171b540,12,TemporalPlainTimeConstructor
code-creation,Builtin,2,6499,0x171b580,12,TemporalPlainTimeFrom
code-creation,Builtin,2,6501,0x171b5c0,12,TemporalPlainTimeCompare
code-creation,Builtin,2,6503,0x171b600,12,TemporalPlainTimePrototypeCalendar
code-creation,Builtin,2,6506,0x171b640,12,TemporalPlainTimePrototypeHour
code-creation,Builtin,2,6508,0x171b680,12,TemporalPlainTimePrototypeMinute
code-creation,Builtin,2,6510,0x171b6c0,12,TemporalPlainTimePrototypeSecond
code-creation,Builtin,2,6513,0x171b700,12,TemporalPlainTimePrototypeMillisecond
code-creation,Builtin,2,6515,0x171b740,12,TemporalPlainTimePrototypeMicrosecond
code-creation,Builtin,2,6518,0x171b780,12,TemporalPlainTimePrototypeNanosecond
code-creation,Builtin,2,6520,0x171b7c0,12,TemporalPlainTimePrototypeAdd
code-creation,Builtin,2,6523,0x171b800,12,TemporalPlainTimePrototypeSubtract
code-creation,Builtin,2,6525,0x171b840,12,TemporalPlainTimePrototypeWith
code-creation,Builtin,2,6527,0x171b880,12,TemporalPlainTimePrototypeUntil
code-creation,Builtin,2,6530,0x171b8c0,12,TemporalPlainTimePrototypeSince
code-creation,Builtin,2,6532,0x171b900,12,TemporalPlainTimePrototypeRound
code-creation,Builtin,2,6534,0x171b940,12,TemporalPlainTimePrototypeEquals
code-creation,Builtin,2,6537,0x171b980,12,TemporalPlainTimePrototypeToPlainDateTime
code-creation,Builtin,2,6539,0x171b9c0,12,TemporalPlainTimePrototypeToZonedDateTime
code-creation,Builtin,2,6542,0x171ba00,12,TemporalPlainTimePrototypeGetISOFields
code-creation,Builtin,2,6544,0x171ba40,12,TemporalPlainTimePrototypeToString
code-creation,Builtin,2,6546,0x171ba80,12,TemporalPlainTimePrototypeToJSON
code-creation,Builtin,2,6549,0x171bac0,12,TemporalPlainTimePrototypeValueOf
code-creation,Builtin,2,6551,0x171bb00,12,TemporalPlainDateTimeConstructor
code-creation,Builtin,2,6554,0x171bb40,12,TemporalPlainDateTimeFrom
code-creation,Builtin,2,6556,0x171bb80,12,TemporalPlainDateTimeCompare
code-creation,Builtin,2,6558,0x171bbc0,12,TemporalPlainDateTimePrototypeCalendar
code-creation,Builtin,2,6561,0x171bc00,12,TemporalPlainDateTimePrototypeYear
code-creation,Builtin,2,6563,0x171bc40,12,TemporalPlainDateTimePrototypeMonth
code-creation,Builtin,2,6565,0x171bc80,12,TemporalPlainDateTimePrototypeMonthCode
code-creation,Builtin,2,6568,0x171bcc0,12,TemporalPlainDateTimePrototypeDay
code-creation,Builtin,2,6570,0x171bd00,12,TemporalPlainDateTimePrototypeHour
code-creation,Builtin,2,6573,0x171bd40,12,TemporalPlainDateTimePrototypeMinute
code-creation,Builtin,2,6575,0x171bd80,12,TemporalPlainDateTimePrototypeSecond
code-creation,Builtin,2,6577,0x171bdc0,12,TemporalPlainDateTimePrototypeMillisecond
code-creation,Builtin,2,6580,0x171be00,12,TemporalPlainDateTimePrototypeMicrosecond
code-creation,Builtin,2,6582,0x171be40,12,TemporalPlainDateTimePrototypeNanosecond
code-creation,Builtin,2,6585,0x171be80,12,TemporalPlainDateTimePrototypeDayOfWeek
code-creation,Builtin,2,6588,0x171bec0,12,TemporalPlainDateTimePrototypeDayOfYear
code-creation,Builtin,2,6590,0x171bf00,12,TemporalPlainDateTimePrototypeWeekOfYear
code-creation,Builtin,2,6593,0x171bf40,12,TemporalPlainDateTimePrototypeDaysInWeek
code-creation,Builtin,2,6595,0x171bf80,12,TemporalPlainDateTimePrototypeDaysInMonth
code-creation,Builtin,2,6598,0x171bfc0,12,TemporalPlainDateTimePrototypeDaysInYear
code-creation,Builtin,2,6600,0x171c000,12,TemporalPlainDateTimePrototypeMonthsInYear
code-creation,Builtin,2,6603,0x171c040,12,TemporalPlainDateTimePrototypeInLeapYear
code-creation,Builtin,2,6605,0x171c080,12,TemporalPlainDateTimePrototypeWith
code-creation,Builtin,2,6608,0x171c0c0,12,TemporalPlainDateTimePrototypeWithPlainTime
code-creation,Builtin,2,6611,0x171c100,12,TemporalPlainDateTimePrototypeWithPlainDate
code-creation,Builtin,2,6614,0x171c140,12,TemporalPlainDateTimePrototypeWithCalendar
code-creation,Builtin,2,6616,0x171c180,12,TemporalPlainDateTimePrototypeAdd
code-creation,Builtin,2,6619,0x171c1c0,12,TemporalPlainDateTimePrototypeSubtract
code-creation,Builtin,2,6621,0x171c200,12,TemporalPlainDateTimePrototypeUntil
code-creation,Builtin,2,6623,0x171c240,12,TemporalPlainDateTimePrototypeSince
code-creation,Builtin,2,6626,0x171c280,12,TemporalPlainDateTimePrototypeRound
code-creation,Builtin,2,6628,0x171c2c0,12,TemporalPlainDateTimePrototypeEquals
code-creation,Builtin,2,6631,0x171c300,12,TemporalPlainDateTimePrototypeToString
code-creation,Builtin,2,6633,0x171c340,12,TemporalPlainDateTimePrototypeToJSON
code-creation,Builtin,2,6636,0x171c380,12,TemporalPlainDateTimePrototypeValueOf
code-creation,Builtin,2,6638,0x171c3c0,12,TemporalPlainDateTimePrototypeToZonedDateTime
code-creation,Builtin,2,6641,0x171c400,12,TemporalPlainDateTimePrototypeToPlainDate
code-creation,Builtin,2,6643,0x171c440,12,TemporalPlainDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,6646,0x171c480,12,TemporalPlainDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,6648,0x171c4c0,12,TemporalPlainDateTimePrototypeToPlainTime
code-creation,Builtin,2,6651,0x171c500,12,TemporalPlainDateTimePrototypeGetISOFields
code-creation,Builtin,2,6653,0x171c540,12,TemporalZonedDateTimeConstructor
code-creation,Builtin,2,6656,0x171c580,12,TemporalZonedDateTimeFrom
code-creation,Builtin,2,6658,0x171c5c0,12,TemporalZonedDateTimeCompare
code-creation,Builtin,2,6660,0x171c600,12,TemporalZonedDateTimePrototypeCalendar
code-creation,Builtin,2,6662,0x171c640,12,TemporalZonedDateTimePrototypeTimeZone
code-creation,Builtin,2,6665,0x171c680,12,TemporalZonedDateTimePrototypeYear
code-creation,Builtin,2,6667,0x171c6c0,12,TemporalZonedDateTimePrototypeMonth
code-creation,Builtin,2,6670,0x171c700,12,TemporalZonedDateTimePrototypeMonthCode
code-creation,Builtin,2,6672,0x171c740,12,TemporalZonedDateTimePrototypeDay
code-creation,Builtin,2,6675,0x171c780,12,TemporalZonedDateTimePrototypeHour
code-creation,Builtin,2,6677,0x171c7c0,12,TemporalZonedDateTimePrototypeMinute
code-creation,Builtin,2,6679,0x171c800,12,TemporalZonedDateTimePrototypeSecond
code-creation,Builtin,2,6682,0x171c840,12,TemporalZonedDateTimePrototypeMillisecond
code-creation,Builtin,2,6684,0x171c880,12,TemporalZonedDateTimePrototypeMicrosecond
code-creation,Builtin,2,6687,0x171c8c0,12,TemporalZonedDateTimePrototypeNanosecond
code-creation,Builtin,2,6689,0x171c900,12,TemporalZonedDateTimePrototypeEpochSeconds
code-creation,Builtin,2,6692,0x171c940,12,TemporalZonedDateTimePrototypeEpochMilliseconds
code-creation,Builtin,2,6694,0x171c980,12,TemporalZonedDateTimePrototypeEpochMicroseconds
code-creation,Builtin,2,6697,0x171c9c0,12,TemporalZonedDateTimePrototypeEpochNanoseconds
code-creation,Builtin,2,6700,0x171ca00,12,TemporalZonedDateTimePrototypeDayOfWeek
code-creation,Builtin,2,6702,0x171ca40,12,TemporalZonedDateTimePrototypeDayOfYear
code-creation,Builtin,2,6705,0x171ca80,12,TemporalZonedDateTimePrototypeWeekOfYear
code-creation,Builtin,2,6707,0x171cac0,12,TemporalZonedDateTimePrototypeHoursInDay
code-creation,Builtin,2,6710,0x171cb00,12,TemporalZonedDateTimePrototypeDaysInWeek
code-creation,Builtin,2,6712,0x171cb40,12,TemporalZonedDateTimePrototypeDaysInMonth
code-creation,Builtin,2,6715,0x171cb80,12,TemporalZonedDateTimePrototypeDaysInYear
code-creation,Builtin,2,6717,0x171cbc0,12,TemporalZonedDateTimePrototypeMonthsInYear
code-creation,Builtin,2,6720,0x171cc00,12,TemporalZonedDateTimePrototypeInLeapYear
code-creation,Builtin,2,6722,0x171cc40,12,TemporalZonedDateTimePrototypeOffsetNanoseconds
code-creation,Builtin,2,6725,0x171cc80,12,TemporalZonedDateTimePrototypeOffset
code-creation,Builtin,2,6727,0x171ccc0,12,TemporalZonedDateTimePrototypeWith
code-creation,Builtin,2,6730,0x171cd00,12,TemporalZonedDateTimePrototypeWithPlainTime
code-creation,Builtin,2,6732,0x171cd40,12,TemporalZonedDateTimePrototypeWithPlainDate
code-creation,Builtin,2,6736,0x171cd80,12,TemporalZonedDateTimePrototypeWithTimeZone
code-creation,Builtin,2,6739,0x171cdc0,12,TemporalZonedDateTimePrototypeWithCalendar
code-creation,Builtin,2,6741,0x171ce00,12,TemporalZonedDateTimePrototypeAdd
code-creation,Builtin,2,6743,0x171ce40,12,TemporalZonedDateTimePrototypeSubtract
code-creation,Builtin,2,6746,0x171ce80,12,TemporalZonedDateTimePrototypeUntil
code-creation,Builtin,2,6749,0x171cec0,12,TemporalZonedDateTimePrototypeSince
code-creation,Builtin,2,6751,0x171cf00,12,TemporalZonedDateTimePrototypeRound
code-creation,Builtin,2,6753,0x171cf40,12,TemporalZonedDateTimePrototypeEquals
code-creation,Builtin,2,6756,0x171cf80,12,TemporalZonedDateTimePrototypeToString
code-creation,Builtin,2,6758,0x171cfc0,12,TemporalZonedDateTimePrototypeToJSON
code-creation,Builtin,2,6760,0x171d000,12,TemporalZonedDateTimePrototypeValueOf
code-creation,Builtin,2,6763,0x171d040,12,TemporalZonedDateTimePrototypeStartOfDay
code-creation,Builtin,2,6765,0x171d080,12,TemporalZonedDateTimePrototypeToInstant
code-creation,Builtin,2,6768,0x171d0c0,12,TemporalZonedDateTimePrototypeToPlainDate
code-creation,Builtin,2,6770,0x171d100,12,TemporalZonedDateTimePrototypeToPlainTime
code-creation,Builtin,2,6773,0x171d140,12,TemporalZonedDateTimePrototypeToPlainDateTime
code-creation,Builtin,2,6776,0x171d180,12,TemporalZonedDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,6778,0x171d1c0,12,TemporalZonedDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,6781,0x171d200,12,TemporalZonedDateTimePrototypeGetISOFields
code-creation,Builtin,2,6783,0x171d240,12,TemporalDurationConstructor
code-creation,Builtin,2,6786,0x171d280,12,TemporalDurationFrom
code-creation,Builtin,2,6788,0x171d2c0,12,TemporalDurationCompare
code-creation,Builtin,2,6790,0x171d300,12,TemporalDurationPrototypeYears
code-creation,Builtin,2,6792,0x171d340,12,TemporalDurationPrototypeMonths
code-creation,Builtin,2,6794,0x171d380,12,TemporalDurationPrototypeWeeks
code-creation,Builtin,2,6797,0x171d3c0,12,TemporalDurationPrototypeDays
code-creation,Builtin,2,6799,0x171d400,12,TemporalDurationPrototypeHours
code-creation,Builtin,2,6801,0x171d440,12,TemporalDurationPrototypeMinutes
code-creation,Builtin,2,6803,0x171d480,12,TemporalDurationPrototypeSeconds
code-creation,Builtin,2,6806,0x171d4c0,12,TemporalDurationPrototypeMilliseconds
code-creation,Builtin,2,6808,0x171d500,12,TemporalDurationPrototypeMicroseconds
code-creation,Builtin,2,6811,0x171d540,12,TemporalDurationPrototypeNanoseconds
code-creation,Builtin,2,6813,0x171d580,12,TemporalDurationPrototypeSign
code-creation,Builtin,2,6815,0x171d5c0,12,TemporalDurationPrototypeBlank
code-creation,Builtin,2,6817,0x171d600,12,TemporalDurationPrototypeWith
code-creation,Builtin,2,6820,0x171d640,12,TemporalDurationPrototypeNegated
code-creation,Builtin,2,6822,0x171d680,12,TemporalDurationPrototypeAbs
code-creation,Builtin,2,6824,0x171d6c0,12,TemporalDurationPrototypeAdd
code-creation,Builtin,2,6827,0x171d700,12,TemporalDurationPrototypeSubtract
code-creation,Builtin,2,6829,0x171d740,12,TemporalDurationPrototypeRound
code-creation,Builtin,2,6831,0x171d780,12,TemporalDurationPrototypeTotal
code-creation,Builtin,2,6834,0x171d7c0,12,TemporalDurationPrototypeToString
code-creation,Builtin,2,6836,0x171d800,12,TemporalDurationPrototypeToJSON
code-creation,Builtin,2,6838,0x171d840,12,TemporalDurationPrototypeValueOf
code-creation,Builtin,2,6841,0x171d880,12,TemporalInstantConstructor
code-creation,Builtin,2,6843,0x171d8c0,12,TemporalInstantFrom
code-creation,Builtin,2,6845,0x171d900,12,TemporalInstantFromEpochSeconds
code-creation,Builtin,2,6847,0x171d940,12,TemporalInstantFromEpochMilliseconds
code-creation,Builtin,2,6850,0x171d980,12,TemporalInstantFromEpochMicroseconds
code-creation,Builtin,2,6852,0x171d9c0,12,TemporalInstantFromEpochNanoseconds
code-creation,Builtin,2,6854,0x171da00,12,TemporalInstantCompare
code-creation,Builtin,2,6856,0x171da40,12,TemporalInstantPrototypeEpochSeconds
code-creation,Builtin,2,6859,0x171da80,12,TemporalInstantPrototypeEpochMilliseconds
code-creation,Builtin,2,6864,0x171dac0,12,TemporalInstantPrototypeEpochMicroseconds
code-creation,Builtin,2,6866,0x171db00,12,TemporalInstantPrototypeEpochNanoseconds
code-creation,Builtin,2,6869,0x171db40,12,TemporalInstantPrototypeAdd
code-creation,Builtin,2,6871,0x171db80,12,TemporalInstantPrototypeSubtract
code-creation,Builtin,2,6873,0x171dbc0,12,TemporalInstantPrototypeUntil
code-creation,Builtin,2,6876,0x171dc00,12,TemporalInstantPrototypeSince
code-creation,Builtin,2,6878,0x171dc40,12,TemporalInstantPrototypeRound
code-creation,Builtin,2,6880,0x171dc80,12,TemporalInstantPrototypeEquals
code-creation,Builtin,2,6883,0x171dcc0,12,TemporalInstantPrototypeToString
code-creation,Builtin,2,6885,0x171dd00,12,TemporalInstantPrototypeToJSON
code-creation,Builtin,2,6887,0x171dd40,12,TemporalInstantPrototypeValueOf
code-creation,Builtin,2,6890,0x171dd80,12,TemporalInstantPrototypeToZonedDateTime
code-creation,Builtin,2,6892,0x171ddc0,12,TemporalInstantPrototypeToZonedDateTimeISO
code-creation,Builtin,2,6895,0x171de00,12,TemporalPlainYearMonthConstructor
code-creation,Builtin,2,6897,0x171de40,12,TemporalPlainYearMonthFrom
code-creation,Builtin,2,6899,0x171de80,12,TemporalPlainYearMonthCompare
code-creation,Builtin,2,6902,0x171dec0,12,TemporalPlainYearMonthPrototypeCalendar
code-creation,Builtin,2,6904,0x171df00,12,TemporalPlainYearMonthPrototypeYear
code-creation,Builtin,2,6906,0x171df40,12,TemporalPlainYearMonthPrototypeMonth
code-creation,Builtin,2,6909,0x171df80,12,TemporalPlainYearMonthPrototypeMonthCode
code-creation,Builtin,2,6911,0x171dfc0,12,TemporalPlainYearMonthPrototypeDaysInYear
code-creation,Builtin,2,6914,0x171e000,12,TemporalPlainYearMonthPrototypeDaysInMonth
code-creation,Builtin,2,6916,0x171e040,12,TemporalPlainYearMonthPrototypeMonthsInYear
code-creation,Builtin,2,6919,0x171e080,12,TemporalPlainYearMonthPrototypeInLeapYear
code-creation,Builtin,2,6922,0x171e0c0,12,TemporalPlainYearMonthPrototypeWith
code-creation,Builtin,2,6924,0x171e100,12,TemporalPlainYearMonthPrototypeAdd
code-creation,Builtin,2,6926,0x171e140,12,TemporalPlainYearMonthPrototypeSubtract
code-creation,Builtin,2,6929,0x171e180,12,TemporalPlainYearMonthPrototypeUntil
code-creation,Builtin,2,6931,0x171e1c0,12,TemporalPlainYearMonthPrototypeSince
code-creation,Builtin,2,6934,0x171e200,12,TemporalPlainYearMonthPrototypeEquals
code-creation,Builtin,2,6936,0x171e240,12,TemporalPlainYearMonthPrototypeToString
code-creation,Builtin,2,6939,0x171e280,12,TemporalPlainYearMonthPrototypeToJSON
code-creation,Builtin,2,6941,0x171e2c0,12,TemporalPlainYearMonthPrototypeValueOf
code-creation,Builtin,2,6944,0x171e300,12,TemporalPlainYearMonthPrototypeToPlainDate
code-creation,Builtin,2,6946,0x171e340,12,TemporalPlainYearMonthPrototypeGetISOFields
code-creation,Builtin,2,6949,0x171e380,12,TemporalPlainMonthDayConstructor
code-creation,Builtin,2,6951,0x171e3c0,12,TemporalPlainMonthDayFrom
code-creation,Builtin,2,6953,0x171e400,12,TemporalPlainMonthDayPrototypeCalendar
code-creation,Builtin,2,6956,0x171e440,12,TemporalPlainMonthDayPrototypeMonthCode
code-creation,Builtin,2,6958,0x171e480,12,TemporalPlainMonthDayPrototypeDay
code-creation,Builtin,2,6961,0x171e4c0,12,TemporalPlainMonthDayPrototypeWith
code-creation,Builtin,2,6983,0x171e500,12,TemporalPlainMonthDayPrototypeEquals
code-creation,Builtin,2,7004,0x171e540,12,TemporalPlainMonthDayPrototypeToString
code-creation,Builtin,2,7021,0x171e580,12,TemporalPlainMonthDayPrototypeToJSON
code-creation,Builtin,2,7038,0x171e5c0,12,TemporalPlainMonthDayPrototypeValueOf
code-creation,Builtin,2,7054,0x171e600,12,TemporalPlainMonthDayPrototypeToPlainDate
code-creation,Builtin,2,7071,0x171e640,12,TemporalPlainMonthDayPrototypeGetISOFields
code-creation,Builtin,2,7087,0x171e680,12,TemporalTimeZoneConstructor
code-creation,Builtin,2,7103,0x171e6c0,12,TemporalTimeZoneFrom
code-creation,Builtin,2,7119,0x171e700,12,TemporalTimeZonePrototypeId
code-creation,Builtin,2,7136,0x171e740,12,TemporalTimeZonePrototypeGetOffsetNanosecondsFor
code-creation,Builtin,2,7152,0x171e780,12,TemporalTimeZonePrototypeGetOffsetStringFor
code-creation,Builtin,2,7172,0x171e7c0,12,TemporalTimeZonePrototypeGetPlainDateTimeFor
code-creation,Builtin,2,7189,0x171e800,12,TemporalTimeZonePrototypeGetInstantFor
code-creation,Builtin,2,7206,0x171e840,12,TemporalTimeZonePrototypeGetPossibleInstantsFor
code-creation,Builtin,2,7222,0x171e880,12,TemporalTimeZonePrototypeGetNextTransition
code-creation,Builtin,2,7239,0x171e8c0,12,TemporalTimeZonePrototypeGetPreviousTransition
code-creation,Builtin,2,7256,0x171e900,12,TemporalTimeZonePrototypeToString
code-creation,Builtin,2,7272,0x171e940,12,TemporalTimeZonePrototypeToJSON
code-creation,Builtin,2,7288,0x171e980,12,TemporalCalendarConstructor
code-creation,Builtin,2,7304,0x171e9c0,12,TemporalCalendarFrom
code-creation,Builtin,2,7320,0x171ea00,12,TemporalCalendarPrototypeId
code-creation,Builtin,2,7337,0x171ea40,12,TemporalCalendarPrototypeDateFromFields
code-creation,Builtin,2,7354,0x171ea80,12,TemporalCalendarPrototypeYearMonthFromFields
code-creation,Builtin,2,7370,0x171eac0,12,TemporalCalendarPrototypeMonthDayFromFields
code-creation,Builtin,2,7387,0x171eb00,12,TemporalCalendarPrototypeDateAdd
code-creation,Builtin,2,7403,0x171eb40,12,TemporalCalendarPrototypeDateUntil
code-creation,Builtin,2,7420,0x171eb80,12,TemporalCalendarPrototypeYear
code-creation,Builtin,2,7436,0x171ebc0,12,TemporalCalendarPrototypeMonth
code-creation,Builtin,2,7452,0x171ec00,12,TemporalCalendarPrototypeMonthCode
code-creation,Builtin,2,7469,0x171ec40,12,TemporalCalendarPrototypeDay
code-creation,Builtin,2,7485,0x171ec80,12,TemporalCalendarPrototypeDayOfWeek
code-creation,Builtin,2,7502,0x171ecc0,12,TemporalCalendarPrototypeDayOfYear
code-creation,Builtin,2,7518,0x171ed00,12,TemporalCalendarPrototypeWeekOfYear
code-creation,Builtin,2,7535,0x171ed40,12,TemporalCalendarPrototypeDaysInWeek
code-creation,Builtin,2,7551,0x171ed80,12,TemporalCalendarPrototypeDaysInMonth
code-creation,Builtin,2,7568,0x171edc0,12,TemporalCalendarPrototypeDaysInYear
code-creation,Builtin,2,7584,0x171ee00,12,TemporalCalendarPrototypeMonthsInYear
code-creation,Builtin,2,7601,0x171ee40,12,TemporalCalendarPrototypeInLeapYear
code-creation,Builtin,2,7618,0x171ee80,12,TemporalCalendarPrototypeFields
code-creation,Builtin,2,7634,0x171eec0,12,TemporalCalendarPrototypeMergeFields
code-creation,Builtin,2,7651,0x171ef00,12,TemporalCalendarPrototypeToString
code-creation,Builtin,2,7667,0x171ef40,12,TemporalCalendarPrototypeToJSON
code-creation,Builtin,2,7683,0x171ef80,1592,StringFixedArrayFromIterable
code-creation,Builtin,2,7700,0x171f5c0,1564,TemporalInstantFixedArrayFromIterable
code-creation,Builtin,2,7716,0x171fc00,272,AggregateErrorConstructor
code-creation,Builtin,2,7732,0x171fd40,848,ArrayPrototypeAt
code-creation,Builtin,2,7748,0x17200c0,628,ArrayPrototypeConcat
code-creation,Builtin,2,7765,0x1720340,5520,ArrayPrototypeCopyWithin
code-creation,Builtin,2,7781,0x1721900,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,7797,0x1721a00,584,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,7814,0x1721c80,3352,ArrayEveryLoopContinuation
code-creation,Builtin,2,7830,0x17229c0,1496,ArrayEvery
code-creation,Builtin,2,7846,0x1722fc0,276,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,7862,0x1723100,912,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,7879,0x17234c0,3628,ArrayFilterLoopContinuation
code-creation,Builtin,2,7895,0x1724300,4176,ArrayFilter
code-creation,Builtin,2,7911,0x1725380,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,7928,0x1725480,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,7944,0x17254c0,304,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,7961,0x1725600,508,ArrayFindLoopContinuation
code-creation,Builtin,2,7977,0x1725800,1476,ArrayPrototypeFind
code-creation,Builtin,2,7993,0x1725e00,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,8010,0x1725f00,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,8026,0x1725f40,304,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,8043,0x1726080,504,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,8067,0x1726280,1472,ArrayPrototypeFindIndex
code-creation,Builtin,2,8083,0x1726880,448,ArrayFindLastLoopContinuation
code-creation,Builtin,2,8100,0x1726a80,1668,ArrayPrototypeFindLast
code-creation,Builtin,2,8116,0x1727140,444,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,8132,0x1727300,1664,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,8148,0x17279c0,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,8165,0x1727ac0,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,8181,0x1727bc0,3208,ArrayForEachLoopContinuation
tick,0x7f6e650178bf,8204,0,0x0,6
tick,0x7f6e650178bf,8253,0,0x0,6
code-creation,Builtin,2,8275,0x1728880,1344,ArrayForEach
code-creation,Builtin,2,8284,0x1728e00,3412,ArrayFrom
code-creation,Builtin,2,8286,0x1729b80,160,ArrayIsArray
code-creation,Builtin,2,8288,0x1729c40,412,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,8291,0x1729e00,44,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,8294,0x1729e40,140,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,8296,0x1729f00,324,ConvertToLocaleString
code-creation,Builtin,2,8298,0x172a080,764,JoinStackPush
code-creation,Builtin,2,8300,0x172a380,280,JoinStackPop
code-creation,Builtin,2,8316,0x172a4c0,6612,ArrayPrototypeJoin
code-creation,Builtin,2,8319,0x172bec0,5364,ArrayPrototypeToLocaleString
code-creation,Builtin,2,8321,0x172d3c0,240,ArrayPrototypeToString
code-creation,Builtin,2,8323,0x172d4c0,6520,TypedArrayPrototypeJoin
code-creation,Builtin,2,8325,0x172ee40,5192,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,8327,0x17302c0,3712,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,8330,0x1731180,256,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,8332,0x17312c0,244,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,8335,0x17313c0,496,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,8337,0x17315c0,3252,ArrayMapLoopContinuation
code-creation,Builtin,2,8339,0x1732280,3832,ArrayMap
code-creation,Builtin,2,8341,0x1733180,868,ArrayOf
code-creation,Builtin,2,8342,0x1733500,424,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,8345,0x17336c0,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,8348,0x17337c0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,8350,0x17338c0,3272,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,8352,0x17345c0,1948,ArrayReduceRight
code-creation,Builtin,2,8354,0x1734d80,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,8357,0x1734e40,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,8359,0x1734f40,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,8362,0x1735040,3308,ArrayReduceLoopContinuation
code-creation,Builtin,2,8364,0x1735d40,1564,ArrayReduce
code-creation,Builtin,2,8366,0x1736380,3172,ArrayPrototypeReverse
code-creation,Builtin,2,8368,0x1737000,3572,ArrayPrototypeShift
code-creation,Builtin,2,8370,0x1737e00,5144,ArrayPrototypeSlice
code-creation,Builtin,2,8372,0x1739240,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,8374,0x1739340,556,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,8377,0x1739580,3348,ArraySomeLoopContinuation
code-creation,Builtin,2,8379,0x173a2c0,1476,ArraySome
code-creation,Builtin,2,8381,0x173a8c0,13736,ArrayPrototypeSplice
code-creation,Builtin,2,8383,0x173de80,3044,ArrayPrototypeUnshift
code-creation,Builtin,2,8385,0x173ea80,324,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,8387,0x173ec00,488,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,8390,0x173ee00,212,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,8392,0x173ef00,324,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,8394,0x173f080,212,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,8397,0x173f180,100,ArrayBufferIsView
code-creation,Builtin,2,8399,0x173f200,396,ToInteger
code-creation,Builtin,2,8401,0x173f3c0,3096,FastCreateDataProperty
code-creation,Builtin,2,8407,0x1740000,612,CheckSameObject
code-creation,Builtin,2,8409,0x1740280,928,BooleanConstructor
code-creation,Builtin,2,8411,0x1740640,160,BooleanPrototypeToString
code-creation,Builtin,2,8413,0x1740700,156,BooleanPrototypeValueOf
code-creation,Builtin,2,8415,0x17407c0,1188,BigIntAddNoThrow
code-creation,Builtin,2,8417,0x1740c80,1272,BigIntAdd
code-creation,Builtin,2,8419,0x1741180,1188,BigIntSubtractNoThrow
code-creation,Builtin,2,8421,0x1741640,1276,BigIntSubtract
code-creation,Builtin,2,8423,0x1741b40,288,BigIntUnaryMinus
code-creation,Builtin,2,8425,0x1741c80,1344,ToString
code-creation,Builtin,2,8427,0x1742200,156,StringPrototypeToString
code-creation,Builtin,2,8429,0x17422c0,156,StringPrototypeValueOf
code-creation,Builtin,2,8431,0x1742380,2472,StringToList
code-creation,Builtin,2,8433,0x1742d40,996,StringPrototypeCharAt
code-creation,Builtin,2,8435,0x1743140,696,StringPrototypeCharCodeAt
code-creation,Builtin,2,8438,0x1743400,1236,StringPrototypeCodePointAt
code-creation,Builtin,2,8440,0x1743900,420,StringPrototypeConcat
code-creation,Builtin,2,8442,0x1743ac0,984,StringConstructor
code-creation,Builtin,2,8444,0x1743ec0,1404,StringAddConvertLeft
code-creation,Builtin,2,8446,0x1744440,1452,StringAddConvertRight
code-creation,Builtin,2,8448,0x1744a00,788,StringCharAt
code-creation,Builtin,2,8450,0x1744d40,16,FastNewClosureBaseline
code-creation,Builtin,2,8452,0x1744d80,200,FastNewFunctionContextEval
code-creation,Builtin,2,8454,0x1744e80,200,FastNewFunctionContextFunction
code-creation,Builtin,2,8457,0x1744f80,248,CreateRegExpLiteral
code-creation,Builtin,2,8459,0x1745080,1088,CreateShallowArrayLiteral
code-creation,Builtin,2,8461,0x1745500,492,CreateEmptyArrayLiteral
code-creation,Builtin,2,8463,0x1745700,1820,CreateShallowObjectLiteral
code-creation,Builtin,2,8465,0x1745e40,388,ObjectConstructor
code-creation,Builtin,2,8467,0x1746000,176,CreateEmptyLiteralObject
code-creation,Builtin,2,8469,0x17460c0,544,NumberConstructor
code-creation,Builtin,2,8471,0x1746300,60,GenericLazyDeoptContinuation
code-creation,Builtin,2,8474,0x1746340,64,StringToNumber
code-creation,Builtin,2,8476,0x17463c0,184,NonNumberToNumber
code-creation,Builtin,2,8478,0x1746480,240,NonNumberToNumeric
code-creation,Builtin,2,8480,0x1746580,36,ToNumeric
code-creation,Builtin,2,8482,0x17465c0,1292,NumberToString
code-creation,Builtin,2,8484,0x1746b00,104,ToBoolean
code-creation,Builtin,2,8486,0x1746b80,100,ToBooleanForBaselineJump
code-creation,Builtin,2,8488,0x1746c00,604,ToLength
code-creation,Builtin,2,8490,0x1746e80,1328,ToName
code-creation,Builtin,2,8491,0x17473c0,756,ToObject
code-creation,Builtin,2,8493,0x17476c0,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,8495,0x17477c0,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,8498,0x17478c0,236,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,8500,0x17479c0,380,OrdinaryToPrimitive_Number
code-creation,Builtin,2,8502,0x1747b40,380,OrdinaryToPrimitive_String
code-creation,Builtin,2,8504,0x1747cc0,232,FastConsoleAssert
code-creation,Builtin,2,8506,0x1747dc0,156,DataViewPrototypeGetBuffer
code-creation,Builtin,2,8509,0x1747e80,752,DataViewPrototypeGetByteLength
code-creation,Builtin,2,8511,0x1748180,416,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,8513,0x1748340,816,DataViewPrototypeGetUint8
code-creation,Builtin,2,8515,0x1748680,816,DataViewPrototypeGetInt8
code-creation,Builtin,2,8517,0x17489c0,892,DataViewPrototypeGetUint16
code-creation,Builtin,2,8520,0x1748d40,888,DataViewPrototypeGetInt16
code-creation,Builtin,2,8522,0x17490c0,1048,DataViewPrototypeGetUint32
code-creation,Builtin,2,8524,0x1749500,924,DataViewPrototypeGetInt32
code-creation,Builtin,2,8526,0x17498c0,1080,DataViewPrototypeGetFloat32
code-creation,Builtin,2,8528,0x1749d00,1144,DataViewPrototypeGetFloat64
code-creation,Builtin,2,8530,0x174a180,1216,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,8533,0x174a680,1240,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,8535,0x174ab80,1196,DataViewPrototypeSetUint8
code-creation,Builtin,2,8537,0x174b040,1196,DataViewPrototypeSetInt8
code-creation,Builtin,2,8541,0x174b500,1280,DataViewPrototypeSetUint16
code-creation,Builtin,2,8543,0x174ba40,1280,DataViewPrototypeSetInt16
code-creation,Builtin,2,8545,0x174bf80,1320,DataViewPrototypeSetUint32
code-creation,Builtin,2,8547,0x174c4c0,1320,DataViewPrototypeSetInt32
code-creation,Builtin,2,8549,0x174ca00,1288,DataViewPrototypeSetFloat32
code-creation,Builtin,2,8552,0x174cf40,1348,DataViewPrototypeSetFloat64
code-creation,Builtin,2,8554,0x174d4c0,1224,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,8556,0x174d9c0,1224,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,8559,0x174dec0,828,FinalizationRegistryConstructor
code-creation,Builtin,2,8561,0x174e200,1192,FinalizationRegistryRegister
code-creation,Builtin,2,8563,0x174e6c0,684,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,8565,0x174e980,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,8568,0x174eb00,940,FastFunctionPrototypeBind
code-creation,Builtin,2,8570,0x174eec0,92,IncBlockCounter
code-creation,Builtin,2,8572,0x174ef40,236,GetTemplateObject
code-creation,Builtin,2,8574,0x174f040,92,ForInNext
code-creation,Builtin,2,8576,0x174f0c0,132,GetImportMetaObjectBaseline
code-creation,Builtin,2,8578,0x174f180,116,GetIteratorWithFeedback
code-creation,Builtin,2,8580,0x174f200,100,GetIteratorBaseline
code-creation,Builtin,2,8582,0x174f280,268,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,8585,0x174f3c0,1064,CallIteratorWithFeedback
code-creation,Builtin,2,8587,0x174f800,284,MathAbs
code-creation,Builtin,2,8588,0x174f940,424,MathCeil
code-creation,Builtin,2,8590,0x174fb00,428,MathFloor
code-creation,Builtin,2,8592,0x174fcc0,484,MathRound
code-creation,Builtin,2,8594,0x174fec0,428,MathTrunc
code-creation,Builtin,2,8596,0x1750080,376,MathPow
code-creation,Builtin,2,8598,0x1750200,412,MathMax
code-creation,Builtin,2,8599,0x17503c0,416,MathMin
code-creation,Builtin,2,8601,0x1750580,324,MathAcos
code-creation,Builtin,2,8603,0x1750700,324,MathAcosh
code-creation,Builtin,2,8605,0x1750880,324,MathAsin
code-creation,Builtin,2,8607,0x1750a00,324,MathAsinh
code-creation,Builtin,2,8608,0x1750b80,324,MathAtan
code-creation,Builtin,2,8610,0x1750d00,420,MathAtan2
code-creation,Builtin,2,8612,0x1750ec0,324,MathAtanh
code-creation,Builtin,2,8614,0x1751040,324,MathCbrt
code-creation,Builtin,2,8616,0x17511c0,168,MathClz32
code-creation,Builtin,2,8617,0x1751280,324,MathCos
code-creation,Builtin,2,8619,0x1751400,324,MathCosh
code-creation,Builtin,2,8621,0x1751580,324,MathExp
code-creation,Builtin,2,8623,0x1751700,324,MathExpm1
code-creation,Builtin,2,8625,0x1751880,268,MathFround
code-creation,Builtin,2,8626,0x17519c0,304,MathImul
code-creation,Builtin,2,8628,0x1751b00,324,MathLog
code-creation,Builtin,2,8630,0x1751c80,324,MathLog1p
code-creation,Builtin,2,8632,0x1751e00,324,MathLog10
code-creation,Builtin,2,8633,0x1751f80,324,MathLog2
code-creation,Builtin,2,8635,0x1752100,324,MathSin
code-creation,Builtin,2,8637,0x1752280,176,MathSign
code-creation,Builtin,2,8639,0x1752340,324,MathSinh
code-creation,Builtin,2,8641,0x17524c0,264,MathSqrt
code-creation,Builtin,2,8642,0x1752600,324,MathTan
code-creation,Builtin,2,8644,0x1752780,324,MathTanh
code-creation,Builtin,2,8646,0x1752900,1052,MathHypot
code-creation,Builtin,2,8648,0x1752d40,332,MathRandom
code-creation,Builtin,2,8650,0x1752ec0,2828,NumberPrototypeToString
code-creation,Builtin,2,8652,0x1753a00,156,NumberIsFinite
code-creation,Builtin,2,8654,0x1753ac0,344,NumberIsInteger
code-creation,Builtin,2,8656,0x1753c40,128,NumberIsNaN
code-creation,Builtin,2,8657,0x1753d00,376,NumberIsSafeInteger
code-creation,Builtin,2,8659,0x1753e80,156,NumberPrototypeValueOf
code-creation,Builtin,2,8661,0x1753f40,200,NumberParseFloat
code-creation,Builtin,2,8664,0x1754040,252,ParseInt
code-creation,Builtin,2,8665,0x1754140,84,NumberParseInt
code-creation,Builtin,2,8667,0x17541c0,820,Add
code-creation,Builtin,2,8669,0x1754500,420,Subtract
code-creation,Builtin,2,8671,0x17546c0,608,Multiply
code-creation,Builtin,2,8673,0x1754940,532,Divide
code-creation,Builtin,2,8675,0x1754b80,592,Modulus
code-creation,Builtin,2,8678,0x1754e00,520,Exponentiate
code-creation,Builtin,2,8680,0x1755040,344,Negate
code-creation,Builtin,2,8682,0x17551c0,108,BitwiseNot
code-creation,Builtin,2,8683,0x1755240,108,Decrement
code-creation,Builtin,2,8685,0x17552c0,108,Increment
code-creation,Builtin,2,8687,0x1755340,428,ShiftLeft
code-creation,Builtin,2,8689,0x1755500,428,ShiftRight
code-creation,Builtin,2,8691,0x17556c0,540,ShiftRightLogical
code-creation,Builtin,2,8693,0x1755900,424,BitwiseAnd
code-creation,Builtin,2,8695,0x1755ac0,424,BitwiseOr
code-creation,Builtin,2,8696,0x1755c80,424,BitwiseXor
code-creation,Builtin,2,8698,0x1755e40,796,LessThan
code-creation,Builtin,2,13954,0x1756180,796,LessThanOrEqual
code-creation,Builtin,2,13972,0x17564c0,792,GreaterThan
code-creation,Builtin,2,13989,0x1756800,792,GreaterThanOrEqual
code-creation,Builtin,2,14005,0x1756b40,852,Equal
code-creation,Builtin,2,14021,0x1756ec0,332,StrictEqual
code-creation,Builtin,2,14053,0x1757040,3332,ObjectFromEntries
code-creation,Builtin,2,14083,0x1757d80,752,CreateObjectWithoutProperties
code-creation,Builtin,2,14100,0x1758080,144,ObjectIsExtensible
code-creation,Builtin,2,14116,0x1758140,148,ObjectPreventExtensions
code-creation,Builtin,2,14132,0x1758200,140,ObjectGetPrototypeOf
code-creation,Builtin,2,14148,0x17582c0,304,ObjectSetPrototypeOf
code-creation,Builtin,2,14164,0x1758400,80,ObjectPrototypeToString
code-creation,Builtin,2,14180,0x1758480,96,ObjectPrototypeValueOf
code-creation,Builtin,2,14196,0x1758500,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,14212,0x17585c0,864,FulfillPromise
code-creation,Builtin,2,14228,0x1758940,1000,RejectPromise
code-creation,Builtin,2,14245,0x1758d40,2696,NewPromiseCapability
code-creation,Builtin,2,14261,0x1759800,168,PromiseCapabilityDefaultReject
code-creation,Builtin,2,14277,0x17598c0,156,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,14293,0x1759980,1296,PerformPromiseThen
code-creation,Builtin,2,14309,0x1759ec0,668,PromiseReject
code-creation,Builtin,2,14325,0x175a180,300,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,14342,0x175a2c0,108,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,14358,0x175a340,4716,PromiseAll
code-creation,Builtin,2,14374,0x175b5c0,5140,PromiseAllSettled
code-creation,Builtin,2,14407,0x175ca00,1100,PromiseAllResolveElementClosure
code-creation,Builtin,2,14423,0x175ce80,1396,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,14440,0x175d400,1404,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,14472,0x175d980,1180,PromiseAnyRejectElementClosure
code-creation,Builtin,2,14488,0x175de40,2728,PromiseAny
code-creation,Builtin,2,14504,0x175e900,3136,PromiseConstructor
code-creation,Builtin,2,14519,0x175f580,300,PromisePrototypeCatch
code-creation,Builtin,2,14552,0x175f6c0,88,PromiseValueThunkFinally
code-creation,Builtin,2,14583,0x175f740,80,PromiseThrowerFinally
code-creation,Builtin,2,14599,0x175f7c0,1020,PromiseCatchFinally
code-creation,Builtin,2,14615,0x175fbc0,1020,PromiseThenFinally
code-creation,Builtin,2,14631,0x175ffc0,1796,PromisePrototypeFinally
code-creation,Builtin,2,14647,0x1760700,1544,PromiseRace
code-creation,Builtin,2,14679,0x1760d40,340,PromiseFulfillReactionJob
code-creation,Builtin,2,14696,0x1760ec0,444,PromiseRejectReactionJob
code-creation,Builtin,2,14727,0x1761080,156,PromiseResolveTrampoline
code-creation,Builtin,2,14743,0x1761140,680,PromiseResolve
code-creation,Builtin,2,14760,0x1761400,696,ResolvePromise
code-creation,Builtin,2,14777,0x17616c0,2248,PromisePrototypeThen
code-creation,Builtin,2,14793,0x1761fc0,1364,PromiseResolveThenableJob
code-creation,Builtin,2,14810,0x1762540,448,ProxyConstructor
code-creation,Builtin,2,14826,0x1762740,1768,ProxyDeleteProperty
code-creation,Builtin,2,14842,0x1762e40,2144,ProxyGetProperty
code-creation,Builtin,2,14858,0x17636c0,1056,ProxyGetPrototypeOf
code-creation,Builtin,2,14874,0x1763b00,1692,ProxyHasProperty
code-creation,Builtin,2,14890,0x17641c0,772,ProxyIsExtensible
code-creation,Builtin,2,14906,0x1764500,824,ProxyPreventExtensions
code-creation,Builtin,2,14922,0x1764840,1236,ProxyRevocable
code-creation,Builtin,2,14944,0x1764d40,132,ProxyRevoke
code-creation,Builtin,2,14981,0x1764e00,2240,ProxySetProperty
code-creation,Builtin,2,14998,0x1765700,1312,ProxySetPrototypeOf
code-creation,Builtin,2,15014,0x1765c40,208,ReflectIsExtensible
code-creation,Builtin,2,15031,0x1765d40,216,ReflectPreventExtensions
code-creation,Builtin,2,15036,0x1765e40,184,ReflectGetPrototypeOf
code-creation,Builtin,2,15039,0x1765f00,296,ReflectSetPrototypeOf
code-creation,Builtin,2,15041,0x1766040,300,ReflectGet
code-creation,Builtin,2,15046,0x1766180,156,ReflectDeleteProperty
code-creation,Builtin,2,15049,0x1766240,144,ReflectHas
code-creation,Builtin,2,15051,0x1766300,5048,RegExpPrototypeExecSlow
code-creation,Builtin,2,15053,0x17676c0,5044,RegExpPrototypeExec
code-creation,Builtin,2,15055,0x1768a80,2312,RegExpPrototypeMatchAll
code-creation,Builtin,2,15057,0x17693c0,9316,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,15060,0x176b840,8736,RegExpMatchFast
code-creation,Builtin,2,15062,0x176da80,3564,RegExpPrototypeMatch
code-creation,Builtin,2,15064,0x176e880,6156,RegExpReplace
code-creation,Builtin,2,15066,0x17700c0,524,RegExpPrototypeReplace
code-creation,Builtin,2,15094,0x1770300,1336,RegExpSearchFast
code-creation,Builtin,2,15117,0x1770840,1636,RegExpPrototypeSearch
code-creation,Builtin,2,15120,0x1770ec0,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,15123,0x1770fc0,5672,RegExpSplit
code-creation,Builtin,2,15126,0x1772600,484,RegExpPrototypeSplit
code-creation,Builtin,2,15128,0x1772800,2208,RegExpPrototypeTest
code-creation,Builtin,2,15130,0x17730c0,1288,RegExpPrototypeTestFast
code-creation,Builtin,2,15132,0x1773600,240,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,15146,0x1773700,256,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,15152,0x1773840,256,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,15166,0x1773980,256,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,15192,0x1773ac0,256,RegExpPrototypeLinearGetter
code-creation,Builtin,2,15205,0x1773c00,256,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,15238,0x1773d40,284,RegExpPrototypeStickyGetter
code-creation,Builtin,2,15269,0x1773e80,284,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,15285,0x1773fc0,2288,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,15310,0x17748c0,1460,StringPrototypeAt
code-creation,Builtin,2,15326,0x1774e80,3092,StringPrototypeEndsWith
code-creation,Builtin,2,15342,0x1775ac0,488,CreateHTML
code-creation,Builtin,2,15358,0x1775cc0,164,StringPrototypeAnchor
code-creation,Builtin,2,15374,0x1775d80,128,StringPrototypeBig
code-creation,Builtin,2,15390,0x1775e40,128,StringPrototypeBlink
code-creation,Builtin,2,15407,0x1775f00,128,StringPrototypeBold
code-creation,Builtin,2,15423,0x1775fc0,172,StringPrototypeFontcolor
code-creation,Builtin,2,15439,0x1776080,172,StringPrototypeFontsize
code-creation,Builtin,2,15455,0x1776140,128,StringPrototypeFixed
code-creation,Builtin,2,15487,0x1776200,128,StringPrototypeItalics
code-creation,Builtin,2,15503,0x17762c0,172,StringPrototypeLink
code-creation,Builtin,2,15519,0x1776380,128,StringPrototypeSmall
code-creation,Builtin,2,15536,0x1776440,128,StringPrototypeStrike
code-creation,Builtin,2,15552,0x1776500,128,StringPrototypeSub
code-creation,Builtin,2,15568,0x17765c0,128,StringPrototypeSup
code-creation,Builtin,2,15617,0x1776680,1060,StringPrototypeIncludes
code-creation,Builtin,2,15633,0x1776ac0,648,StringPrototypeIndexOf
code-creation,Builtin,2,15649,0x1776d80,344,StringPrototypeIterator
code-creation,Builtin,2,15665,0x1776f00,1980,StringIteratorPrototypeNext
code-creation,Builtin,2,15697,0x17776c0,1264,StringPrototypeMatch
code-creation,Builtin,2,15730,0x1777bc0,1264,StringPrototypeSearch
code-creation,Builtin,2,15746,0x17780c0,816,StringPrototypePadStart
code-creation,Builtin,2,15763,0x1778400,816,StringPrototypePadEnd
code-creation,Builtin,2,15779,0x1778740,120,StringRepeat
code-creation,Builtin,2,15795,0x17787c0,404,StringPrototypeRepeat
code-creation,Builtin,2,15843,0x1778980,10980,StringPrototypeReplaceAll
code-creation,Builtin,2,15860,0x177b480,3312,StringPrototypeSlice
code-creation,Builtin,2,15880,0x177c180,3116,StringPrototypeStartsWith
code-creation,Builtin,2,15897,0x177cdc0,3244,StringPrototypeSubstr
code-creation,Builtin,2,15913,0x177da80,3168,StringPrototypeSubstring
code-creation,Builtin,2,15930,0x177e700,6852,StringPrototypeTrim
code-creation,Builtin,2,15946,0x1780200,6204,StringPrototypeTrimStart
code-creation,Builtin,2,15963,0x1781a40,5816,StringPrototypeTrimEnd
code-creation,Builtin,2,15979,0x1783100,160,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,15995,0x17831c0,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,16011,0x1783280,176,SymbolPrototypeToString
code-creation,Builtin,2,16028,0x1783340,156,SymbolPrototypeValueOf
code-creation,Builtin,2,16044,0x1783400,1152,TypedArrayPrototypeAt
code-creation,Builtin,2,16060,0x17838c0,10128,CreateTypedArray
code-creation,Builtin,2,16077,0x1786080,1792,TypedArrayPrototypeEvery
code-creation,Builtin,2,16093,0x17867c0,420,TypedArrayPrototypeEntries
code-creation,Builtin,2,16109,0x1786980,4224,TypedArrayPrototypeFilter
tick,0x7f6e650a07fd,16133,0,0x0,6
tick,0x7f6e64f8d450,16167,0,0x0,6
tick,0x7f6e64f94337,16171,0,0x0,6
code-creation,Builtin,2,16214,0x1787a40,1760,TypedArrayPrototypeFind
code-creation,Builtin,2,16223,0x1788140,1764,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,16226,0x1788840,1792,TypedArrayPrototypeFindLast
code-creation,Builtin,2,16228,0x1788f80,1796,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,16231,0x17896c0,1628,TypedArrayPrototypeForEach
code-creation,Builtin,2,16233,0x1789d40,2348,TypedArrayFrom
code-creation,Builtin,2,16235,0x178a680,404,TypedArrayPrototypeKeys
code-creation,Builtin,2,16237,0x178a840,1036,TypedArrayOf
code-creation,Builtin,2,16239,0x178ac80,1728,TypedArrayPrototypeReduce
code-creation,Builtin,2,16241,0x178b380,1764,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,16244,0x178ba80,3456,TypedArrayPrototypeSet
code-creation,Builtin,2,16246,0x178c840,3972,TypedArrayPrototypeSlice
code-creation,Builtin,2,16248,0x178d800,1760,TypedArrayPrototypeSome
code-creation,Builtin,2,16250,0x178df00,940,TypedArrayMergeSort
code-creation,Builtin,2,16252,0x178e2c0,2348,TypedArrayPrototypeSort
code-creation,Builtin,2,16255,0x178ec00,3184,TypedArrayPrototypeSubArray
code-creation,Builtin,2,16257,0x178f880,420,TypedArrayPrototypeValues
code-creation,Builtin,2,16259,0x178fa40,984,WeakRefConstructor
code-creation,Builtin,2,16261,0x178fe40,184,WeakRefDeref
code-creation,Builtin,2,16263,0x178ff00,664,NewSloppyArgumentsElements
code-creation,Builtin,2,16266,0x17901c0,304,NewStrictArgumentsElements
code-creation,Builtin,2,16268,0x1790300,332,NewRestArgumentsElements
code-creation,Builtin,2,16270,0x1790480,1536,FastNewSloppyArguments
code-creation,Builtin,2,16272,0x1790ac0,516,FastNewStrictArguments
code-creation,Builtin,2,16274,0x1790d00,564,FastNewRestArguments
code-creation,Builtin,2,16276,0x1790f40,664,StringSlowFlatten
code-creation,Builtin,2,16278,0x1791200,2100,StringIndexOf
code-creation,Builtin,2,16280,0x1791a40,2064,TestTurbofanType
code-creation,Builtin,2,16282,0x1792280,152,CheckTurbofanType
code-creation,Builtin,2,16284,0x1792340,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,16286,0x1792380,20,TestHelperPlus1
code-creation,Builtin,2,16288,0x17923c0,20,TestHelperPlus2
code-creation,Builtin,2,16290,0x1792400,96,NewSmiBox
code-creation,Builtin,2,16292,0x1792480,24,ReturnTwoValues
code-creation,Builtin,2,16294,0x17924c0,32,Load_FastSmiElements_0
code-creation,Builtin,2,16296,0x1792500,32,Load_FastObjectElements_0
code-creation,Builtin,2,16298,0x1792540,144,Load_FastDoubleElements_0
code-creation,Builtin,2,16301,0x1792600,32,Store_FastSmiElements_0
code-creation,Builtin,2,16303,0x1792640,92,Store_FastObjectElements_0
code-creation,Builtin,2,16305,0x17926c0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,16307,0x1792700,40,Delete_FastSmiElements_0
code-creation,Builtin,2,16310,0x1792740,40,Delete_FastObjectElements_0
code-creation,Builtin,2,16312,0x1792780,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,16314,0x17927c0,296,SortCompareDefault
code-creation,Builtin,2,16320,0x1792900,96,SortCompareUserFn
code-creation,Builtin,2,16322,0x1792980,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,16324,0x17929c0,308,Copy
code-creation,Builtin,2,16326,0x1792b00,5740,MergeAt
code-creation,Builtin,2,16328,0x1794180,792,GallopLeft
code-creation,Builtin,2,16330,0x17944c0,832,GallopRight
code-creation,Builtin,2,16332,0x1794840,3788,ArrayTimSort
code-creation,Builtin,2,16334,0x1795740,2100,ArrayPrototypeSort
code-creation,Builtin,2,16336,0x1795f80,3608,StringFastLocaleCompare
code-creation,Builtin,2,16338,0x1796dc0,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,16340,0x1796e40,24,WasmFuncRefToJS
code-creation,Builtin,2,16342,0x1796e80,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,16344,0x1796f00,76,WasmTaggedToFloat64
code-creation,Builtin,2,16346,0x1796f80,72,WasmMemoryGrow
code-creation,Builtin,2,16348,0x1797000,100,WasmTableInit
code-creation,Builtin,2,16350,0x1797080,100,WasmTableCopy
code-creation,Builtin,2,16352,0x1797100,84,WasmTableFill
code-creation,Builtin,2,16354,0x1797180,72,WasmTableGrow
code-creation,Builtin,2,16356,0x1797200,148,WasmTableGet
code-creation,Builtin,2,16358,0x17972c0,240,WasmTableSet
code-creation,Builtin,2,16360,0x17973c0,96,WasmRefFunc
code-creation,Builtin,2,16362,0x1797440,144,WasmAllocateFixedArray
code-creation,Builtin,2,16364,0x1797500,44,WasmThrow
code-creation,Builtin,2,16366,0x1797540,56,WasmRethrow
code-creation,Builtin,2,16367,0x1797580,44,WasmRethrowExplicitContext
code-creation,Builtin,2,16370,0x17975c0,44,WasmTriggerTierUp
code-creation,Builtin,2,16372,0x1797600,32,WasmStackGuard
code-creation,Builtin,2,16374,0x1797640,32,WasmStackOverflow
code-creation,Builtin,2,16376,0x1797680,40,WasmTraceMemory
code-creation,Builtin,2,16378,0x17976c0,32,WasmTraceEnter
code-creation,Builtin,2,16380,0x1797700,40,WasmTraceExit
code-creation,Builtin,2,16382,0x1797740,340,WasmAllocateJSArray
code-creation,Builtin,2,16384,0x17978c0,120,WasmAllocateStructWithRtt
code-creation,Builtin,2,16386,0x1797940,136,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,16388,0x1797a00,172,WasmAllocateArray_InitZero
code-creation,Builtin,2,16391,0x1797ac0,176,WasmAllocateArray_InitNull
code-creation,Builtin,2,16393,0x1797b80,60,WasmArrayInitFromData
code-creation,Builtin,2,16395,0x1797bc0,140,WasmArrayCopyWithChecks
code-creation,Builtin,2,16397,0x1797c80,72,WasmArrayCopy
code-creation,Builtin,2,16399,0x1797d00,240,WasmAllocateObjectWrapper
code-creation,Builtin,2,16401,0x1797e00,52,WasmSubtypeCheck
code-creation,Builtin,2,16403,0x1797e40,8,WasmInt32ToNumber
code-creation,Builtin,2,16405,0x1797e80,116,WasmUint32ToNumber
code-creation,Builtin,2,16407,0x1797f00,144,UintPtr53ToNumber
code-creation,Builtin,2,16409,0x1797fc0,96,WasmAtomicNotify
code-creation,Builtin,2,16411,0x1798040,116,WasmI32AtomicWait64
code-creation,Builtin,2,16413,0x17980c0,116,WasmI64AtomicWait64
code-creation,Builtin,2,16415,0x1798140,1260,CallRefIC
code-creation,Builtin,2,16417,0x1798640,596,WasmGetOwnProperty
code-creation,Builtin,2,16419,0x17988c0,40,WasmTrap
code-creation,Builtin,2,16421,0x1798900,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,16423,0x1798940,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,16425,0x1798980,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,16427,0x17989c0,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,16429,0x1798a00,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,16432,0x1798a40,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,16434,0x1798a80,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,16436,0x1798ac0,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,16439,0x1798b00,16,ThrowWasmTrapDataSegmentOutOfBounds
code-creation,Builtin,2,16441,0x1798b40,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,16443,0x1798b80,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,16445,0x1798bc0,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,16448,0x1798c00,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,16450,0x1798c40,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,16454,0x1798c80,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,16456,0x1798cc0,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,16458,0x1798d00,168,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,16461,0x1798dc0,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,16463,0x1798e00,112,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,16466,0x1798e80,108,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,16468,0x1798f00,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,16471,0x1798f40,216,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,16473,0x1799040,244,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,16476,0x1799140,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,16478,0x1799180,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,16481,0x17991c0,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,16483,0x1799200,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,16485,0x1799240,128,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,16488,0x1799300,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,16490,0x1799340,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,16492,0x1799380,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,16495,0x17993c0,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,16497,0x1799400,2760,Load_GenericElementsAccessor_0
code-creation,Builtin,2,16500,0x1799f00,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,16502,0x1799f40,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,16504,0x1799f80,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,16507,0x1799fc0,172,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,16509,0x179a080,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,16511,0x179a140,112,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,16514,0x179a1c0,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,16516,0x179a200,160,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,16519,0x179a2c0,108,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,16521,0x179a340,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,16524,0x179a380,156,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,16526,0x179a440,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,16529,0x179a480,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,16531,0x179a4c0,616,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,16534,0x179a740,216,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,16536,0x179a840,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,16539,0x179a880,196,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,16541,0x179a980,244,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,16544,0x179aa80,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,16546,0x179aac0,196,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,16549,0x179abc0,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,16551,0x179ac00,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,16554,0x179ac40,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,16556,0x179ad00,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,16559,0x179ad40,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,16561,0x179ad80,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,16563,0x179ae40,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,16566,0x179ae80,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,16568,0x179aec0,184,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,16571,0x179af80,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,16573,0x179afc0,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,16577,0x179b000,184,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,16579,0x179b0c0,128,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,16582,0x179b180,172,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,16584,0x179b240,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,16586,0x179b300,12,CollatorConstructor
code-creation,Builtin,2,16589,0x179b340,12,CollatorInternalCompare
code-creation,Builtin,2,16591,0x179b380,12,CollatorPrototypeCompare
code-creation,Builtin,2,16593,0x179b3c0,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,16595,0x179b400,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,16598,0x179b440,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,16600,0x179b480,12,DatePrototypeToLocaleString
code-creation,Builtin,2,16602,0x179b4c0,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,16604,0x179b500,12,DateTimeFormatConstructor
code-creation,Builtin,2,16607,0x179b540,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,16609,0x179b580,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,16611,0x179b5c0,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,16614,0x179b600,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,16616,0x179b640,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,16619,0x179b680,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,16621,0x179b6c0,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,16624,0x179b700,12,DisplayNamesConstructor
code-creation,Builtin,2,16626,0x179b740,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,16628,0x179b780,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,16630,0x179b7c0,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,16633,0x179b800,12,IntlGetCanonicalLocales
code-creation,Builtin,2,16635,0x179b840,12,IntlSupportedValuesOf
code-creation,Builtin,2,16637,0x179b880,12,ListFormatConstructor
code-creation,Builtin,2,16639,0x179b8c0,228,ListFormatPrototypeFormat
code-creation,Builtin,2,16641,0x179b9c0,228,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,16643,0x179bac0,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,16646,0x179bb00,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,16648,0x179bb40,12,LocaleConstructor
code-creation,Builtin,2,16650,0x179bb80,12,LocalePrototypeBaseName
code-creation,Builtin,2,16652,0x179bbc0,12,LocalePrototypeCalendar
code-creation,Builtin,2,16655,0x179bc00,12,LocalePrototypeCalendars
code-creation,Builtin,2,16657,0x179bc40,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,16659,0x179bc80,12,LocalePrototypeCollation
code-creation,Builtin,2,16661,0x179bcc0,12,LocalePrototypeCollations
code-creation,Builtin,2,16663,0x179bd00,12,LocalePrototypeHourCycle
code-creation,Builtin,2,16665,0x179bd40,12,LocalePrototypeHourCycles
code-creation,Builtin,2,16668,0x179bd80,12,LocalePrototypeLanguage
code-creation,Builtin,2,16670,0x179bdc0,12,LocalePrototypeMaximize
code-creation,Builtin,2,16672,0x179be00,12,LocalePrototypeMinimize
code-creation,Builtin,2,16674,0x179be40,12,LocalePrototypeNumeric
code-creation,Builtin,2,16676,0x179be80,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,16678,0x179bec0,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,16681,0x179bf00,12,LocalePrototypeRegion
code-creation,Builtin,2,16683,0x179bf40,12,LocalePrototypeScript
code-creation,Builtin,2,16685,0x179bf80,12,LocalePrototypeTextInfo
code-creation,Builtin,2,16687,0x179bfc0,12,LocalePrototypeTimeZones
code-creation,Builtin,2,16689,0x179c000,12,LocalePrototypeToString
code-creation,Builtin,2,16691,0x179c040,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,16693,0x179c080,12,NumberFormatConstructor
code-creation,Builtin,2,16695,0x179c0c0,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,16698,0x179c100,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,16700,0x179c140,12,NumberFormatPrototypeFormatRange
code-creation,Builtin,2,16702,0x179c180,12,NumberFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,16707,0x179c1c0,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,16709,0x179c200,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,16711,0x179c240,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,16714,0x179c280,12,PluralRulesConstructor
code-creation,Builtin,2,16716,0x179c2c0,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,16718,0x179c300,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,16720,0x179c340,12,PluralRulesPrototypeSelectRange
code-creation,Builtin,2,16723,0x179c380,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,16725,0x179c3c0,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,16727,0x179c400,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,16730,0x179c440,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,16732,0x179c480,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,16734,0x179c4c0,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,16737,0x179c500,12,SegmenterConstructor
code-creation,Builtin,2,16739,0x179c540,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,16741,0x179c580,12,SegmenterPrototypeSegment
code-creation,Builtin,2,16744,0x179c5c0,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,16746,0x179c600,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,16748,0x179c640,12,SegmentsPrototypeContaining
code-creation,Builtin,2,16751,0x179c680,12,SegmentsPrototypeIterator
code-creation,Builtin,2,16753,0x179c6c0,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,16755,0x179c700,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,16757,0x179c740,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,16760,0x179c780,196,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,16762,0x179c880,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,16765,0x179c8c0,656,StringToLowerCaseIntl
code-creation,Builtin,2,16767,0x179cb80,12,TemporalCalendarPrototypeEra
code-creation,Builtin,2,16769,0x179cbc0,12,TemporalCalendarPrototypeEraYear
code-creation,Builtin,2,16771,0x179cc00,12,TemporalDurationPrototypeToLocaleString
code-creation,Builtin,2,16774,0x179cc40,12,TemporalInstantPrototypeToLocaleString
code-creation,Builtin,2,16776,0x179cc80,12,TemporalPlainDatePrototypeEra
code-creation,Builtin,2,16778,0x179ccc0,12,TemporalPlainDatePrototypeEraYear
code-creation,Builtin,2,16781,0x179cd00,12,TemporalPlainDatePrototypeToLocaleString
code-creation,Builtin,2,16783,0x179cd40,12,TemporalPlainDateTimePrototypeEra
code-creation,Builtin,2,16786,0x179cd80,12,TemporalPlainDateTimePrototypeEraYear
code-creation,Builtin,2,16788,0x179cdc0,12,TemporalPlainDateTimePrototypeToLocaleString
code-creation,Builtin,2,16791,0x179ce00,12,TemporalPlainMonthDayPrototypeToLocaleString
code-creation,Builtin,2,16793,0x179ce40,12,TemporalPlainTimePrototypeToLocaleString
code-creation,Builtin,2,16796,0x179ce80,12,TemporalPlainYearMonthPrototypeEra
code-creation,Builtin,2,16798,0x179cec0,12,TemporalPlainYearMonthPrototypeEraYear
code-creation,Builtin,2,16800,0x179cf00,12,TemporalPlainYearMonthPrototypeToLocaleString
code-creation,Builtin,2,16803,0x179cf40,12,TemporalZonedDateTimePrototypeEra
code-creation,Builtin,2,16805,0x179cf80,12,TemporalZonedDateTimePrototypeEraYear
code-creation,Builtin,2,16808,0x179cfc0,12,TemporalZonedDateTimePrototypeToLocaleString
code-creation,Builtin,2,16810,0x179d000,12,V8BreakIteratorConstructor
code-creation,Builtin,2,16812,0x179d040,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,16815,0x179d080,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,16817,0x179d0c0,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,16819,0x179d100,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,16822,0x179d140,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,16824,0x179d180,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,16826,0x179d1c0,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,16829,0x179d200,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,16831,0x179d240,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,16836,0x179d280,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,16838,0x179d2c0,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,16841,0x179d300,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,16844,0x179d340,24,Wide
code-creation,BytecodeHandler,0,16846,0x179d380,24,ExtraWide
code-creation,BytecodeHandler,0,16848,0x179d3c0,104,DebugBreakWide
code-creation,BytecodeHandler,0,16850,0x179d440,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,16853,0x179d4c0,164,DebugBreak0
code-creation,BytecodeHandler,0,16855,0x179d580,104,DebugBreak1
code-creation,BytecodeHandler,0,16857,0x179d600,104,DebugBreak2
code-creation,BytecodeHandler,0,16859,0x179d680,104,DebugBreak3
code-creation,BytecodeHandler,0,16861,0x179d700,104,DebugBreak4
code-creation,BytecodeHandler,0,16863,0x179d780,104,DebugBreak5
code-creation,BytecodeHandler,0,16865,0x179d800,104,DebugBreak6
code-creation,BytecodeHandler,0,16867,0x179d880,32,Ldar
code-creation,BytecodeHandler,0,16869,0x179d8c0,60,LdaZero
code-creation,BytecodeHandler,0,16870,0x179d900,68,LdaSmi
code-creation,BytecodeHandler,0,16872,0x179d980,64,LdaUndefined
code-creation,BytecodeHandler,0,16875,0x179da00,64,LdaNull
code-creation,BytecodeHandler,0,16877,0x179da80,64,LdaTheHole
code-creation,BytecodeHandler,0,16879,0x179db00,24,LdaTrue
code-creation,BytecodeHandler,0,16881,0x179db40,24,LdaFalse
code-creation,BytecodeHandler,0,16882,0x179db80,68,LdaConstant
code-creation,BytecodeHandler,0,16884,0x179dc00,124,LdaContextSlot
code-creation,BytecodeHandler,0,16887,0x179dc80,124,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,16889,0x179dd00,80,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,16892,0x179dd80,80,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,16894,0x179de00,32,Star
code-creation,BytecodeHandler,0,16896,0x179de40,48,Mov
code-creation,BytecodeHandler,0,16898,0x179de80,40,PushContext
code-creation,BytecodeHandler,0,16900,0x179dec0,36,PopContext
code-creation,BytecodeHandler,0,16902,0x179df00,56,TestReferenceEqual
code-creation,BytecodeHandler,0,16904,0x179df40,60,TestUndetectable
code-creation,BytecodeHandler,0,16907,0x179df80,44,TestNull
code-creation,BytecodeHandler,0,16909,0x179dfc0,44,TestUndefined
code-creation,BytecodeHandler,0,16911,0x179e000,364,TestTypeOf
code-creation,BytecodeHandler,0,16913,0x179e180,5648,LdaGlobal
code-creation,BytecodeHandler,0,16915,0x179f7c0,4400,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,16917,0x17a0900,160,StaGlobal
code-creation,BytecodeHandler,0,16919,0x17a09c0,156,StaContextSlot
code-creation,BytecodeHandler,0,16921,0x17a0a80,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,16923,0x17a0b00,124,LdaLookupSlot
code-creation,BytecodeHandler,0,16925,0x17a0b80,244,LdaLookupContextSlot
code-creation,BytecodeHandler,0,16928,0x17a0c80,4660,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,16930,0x17a1ec0,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,16932,0x17a1f40,244,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,16935,0x17a2040,4572,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,16937,0x17a3240,220,StaLookupSlot
code-creation,BytecodeHandler,0,16939,0x17a3340,5292,GetNamedProperty
code-creation,BytecodeHandler,0,16942,0x17a4800,184,GetNamedPropertyFromSuper
code-creation,BytecodeHandler,0,16944,0x17a48c0,200,GetKeyedProperty
code-creation,BytecodeHandler,0,16946,0x17a49c0,160,LdaModuleVariable
code-creation,BytecodeHandler,0,16948,0x17a4a80,292,StaModuleVariable
code-creation,BytecodeHandler,0,16951,0x17a4bc0,176,SetNamedProperty
code-creation,BytecodeHandler,0,16953,0x17a4c80,176,DefineNamedOwnProperty
code-creation,BytecodeHandler,0,16955,0x17a4d40,168,SetKeyedProperty
code-creation,BytecodeHandler,0,16958,0x17a4e00,168,DefineKeyedOwnProperty
code-creation,BytecodeHandler,0,16960,0x17a4ec0,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,16962,0x17a4f80,200,DefineKeyedOwnPropertyInLiteral
code-creation,BytecodeHandler,0,16965,0x17a5080,164,CollectTypeProfile
code-creation,BytecodeHandler,0,16969,0x17a5140,1028,Add
code-creation,BytecodeHandler,0,16971,0x17a5580,1056,Sub
code-creation,BytecodeHandler,0,16973,0x17a59c0,1036,Mul
code-creation,BytecodeHandler,0,16975,0x17a5e00,988,Div
code-creation,BytecodeHandler,0,16977,0x17a6200,936,Mod
code-creation,BytecodeHandler,0,16979,0x17a65c0,984,Exp
code-creation,BytecodeHandler,0,16981,0x17a69c0,992,BitwiseOr
code-creation,BytecodeHandler,0,16983,0x17a6dc0,992,BitwiseXor
code-creation,BytecodeHandler,0,16985,0x17a71c0,992,BitwiseAnd
code-creation,BytecodeHandler,0,16987,0x17a75c0,1008,ShiftLeft
code-creation,BytecodeHandler,0,16989,0x17a79c0,1008,ShiftRight
code-creation,BytecodeHandler,0,16991,0x17a7dc0,1128,ShiftRightLogical
code-creation,BytecodeHandler,0,16993,0x17a8240,956,AddSmi
code-creation,BytecodeHandler,0,16995,0x17a8600,964,SubSmi
code-creation,BytecodeHandler,0,16997,0x17a8a00,892,MulSmi
code-creation,BytecodeHandler,0,16999,0x17a8d80,940,DivSmi
code-creation,BytecodeHandler,0,17001,0x17a9140,812,ModSmi
code-creation,BytecodeHandler,0,17002,0x17a9480,868,ExpSmi
code-creation,BytecodeHandler,0,17004,0x17a9800,500,BitwiseOrSmi
code-creation,BytecodeHandler,0,17006,0x17a9a00,500,BitwiseXorSmi
code-creation,BytecodeHandler,0,17008,0x17a9c00,500,BitwiseAndSmi
code-creation,BytecodeHandler,0,17011,0x17a9e00,524,ShiftLeftSmi
code-creation,BytecodeHandler,0,17013,0x17aa040,512,ShiftRightSmi
code-creation,BytecodeHandler,0,17015,0x17aa280,820,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,17017,0x17aa5c0,656,Inc
code-creation,BytecodeHandler,0,17019,0x17aa880,656,Dec
code-creation,BytecodeHandler,0,17021,0x17aab40,652,Negate
code-creation,BytecodeHandler,0,17023,0x17aae00,500,BitwiseNot
code-creation,BytecodeHandler,0,17025,0x17ab000,120,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,17027,0x17ab080,44,LogicalNot
code-creation,BytecodeHandler,0,17029,0x17ab0c0,208,TypeOf
code-creation,BytecodeHandler,0,17031,0x17ab1c0,124,DeletePropertyStrict
code-creation,BytecodeHandler,0,17034,0x17ab240,116,DeletePropertySloppy
code-creation,BytecodeHandler,0,17036,0x17ab2c0,40,GetSuperConstructor
code-creation,BytecodeHandler,0,17038,0x17ab300,1100,CallAnyReceiver
code-creation,BytecodeHandler,0,17040,0x17ab780,1100,CallProperty
code-creation,BytecodeHandler,0,17042,0x17abc00,996,CallProperty0
code-creation,BytecodeHandler,0,17045,0x17ac000,1008,CallProperty1
code-creation,BytecodeHandler,0,17047,0x17ac400,1020,CallProperty2
code-creation,BytecodeHandler,0,17049,0x17ac800,976,CallUndefinedReceiver
code-creation,BytecodeHandler,0,17051,0x17acc00,1036,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,17053,0x17ad040,1008,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,17055,0x17ad440,1028,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,17058,0x17ad880,1100,CallWithSpread
code-creation,BytecodeHandler,0,17060,0x17add00,128,CallRuntime
code-creation,BytecodeHandler,0,17062,0x17addc0,164,CallRuntimeForPair
code-creation,BytecodeHandler,0,17064,0x17ade80,84,CallJSRuntime
code-creation,BytecodeHandler,0,17066,0x17adf00,1316,InvokeIntrinsic
code-creation,BytecodeHandler,0,17069,0x17ae440,1008,Construct
code-creation,BytecodeHandler,0,17070,0x17ae840,516,ConstructWithSpread
code-creation,BytecodeHandler,0,17073,0x17aea80,1920,TestEqual
code-creation,BytecodeHandler,0,17075,0x17af240,1048,TestEqualStrict
code-creation,BytecodeHandler,0,17077,0x17af680,1624,TestLessThan
code-creation,BytecodeHandler,0,17079,0x17afd00,1624,TestGreaterThan
code-creation,BytecodeHandler,0,17081,0x17b0380,1624,TestLessThanOrEqual
code-creation,BytecodeHandler,0,17084,0x17b0a00,1624,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,17086,0x17b1080,868,TestInstanceOf
code-creation,BytecodeHandler,0,17088,0x17b1400,156,TestIn
code-creation,BytecodeHandler,0,17090,0x17b14c0,116,ToName
code-creation,BytecodeHandler,0,17092,0x17b1540,220,ToNumber
code-creation,BytecodeHandler,0,17094,0x17b1640,240,ToNumeric
code-creation,BytecodeHandler,0,17096,0x17b1740,116,ToObject
code-creation,BytecodeHandler,0,17098,0x17b17c0,120,ToString
code-creation,BytecodeHandler,0,17101,0x17b1840,404,CreateRegExpLiteral
code-creation,BytecodeHandler,0,17104,0x17b1a00,1468,CreateArrayLiteral
code-creation,BytecodeHandler,0,17106,0x17b1fc0,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,17108,0x17b2040,792,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,17110,0x17b2380,2236,CreateObjectLiteral
code-creation,BytecodeHandler,0,17113,0x17b2c40,224,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,17115,0x17b2d40,172,CloneObject
code-creation,BytecodeHandler,0,17117,0x17b2e00,208,GetTemplateObject
code-creation,BytecodeHandler,0,17120,0x17b2f00,328,CreateClosure
code-creation,BytecodeHandler,0,17122,0x17b3080,116,CreateBlockContext
code-creation,BytecodeHandler,0,17124,0x17b3100,132,CreateCatchContext
code-creation,BytecodeHandler,0,17126,0x17b31c0,260,CreateFunctionContext
code-creation,BytecodeHandler,0,17128,0x17b3300,260,CreateEvalContext
code-creation,BytecodeHandler,0,17131,0x17b3440,132,CreateWithContext
code-creation,BytecodeHandler,0,17133,0x17b3500,1600,CreateMappedArguments
code-creation,BytecodeHandler,0,17135,0x17b3b80,588,CreateUnmappedArguments
code-creation,BytecodeHandler,0,17138,0x17b3e00,644,CreateRestParameter
code-creation,BytecodeHandler,0,17140,0x17b40c0,480,JumpLoop
code-creation,BytecodeHandler,0,17142,0x17b42c0,44,Jump
code-creation,BytecodeHandler,0,17144,0x17b4300,56,JumpConstant
code-creation,BytecodeHandler,0,17146,0x17b4340,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,17148,0x17b43c0,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,17150,0x17b4440,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,17153,0x17b44c0,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,17155,0x17b4540,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,17157,0x17b45c0,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,17160,0x17b4640,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,17162,0x17b46c0,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,17164,0x17b4740,160,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,17166,0x17b4800,156,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,17169,0x17b48c0,144,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,17171,0x17b4980,144,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,17191,0x17b4a40,68,JumpIfTrue
code-creation,BytecodeHandler,0,17193,0x17b4ac0,68,JumpIfFalse
code-creation,BytecodeHandler,0,17195,0x17b4b40,68,JumpIfNull
code-creation,BytecodeHandler,0,17197,0x17b4bc0,68,JumpIfNotNull
code-creation,BytecodeHandler,0,17199,0x17b4c40,68,JumpIfUndefined
code-creation,BytecodeHandler,0,17201,0x17b4cc0,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,17204,0x17b4d40,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,17206,0x17b4dc0,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,17208,0x17b4e40,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,17211,0x17b4ec0,468,ForInEnumerate
code-creation,BytecodeHandler,0,17213,0x17b50c0,260,ForInPrepare
code-creation,BytecodeHandler,0,17235,0x17b5200,64,ForInContinue
code-creation,BytecodeHandler,0,17267,0x17b5280,264,ForInNext
code-creation,BytecodeHandler,0,17284,0x17b53c0,48,ForInStep
code-creation,BytecodeHandler,0,17300,0x17b5400,36,SetPendingMessage
code-creation,BytecodeHandler,0,17317,0x17b5440,116,Throw
code-creation,BytecodeHandler,0,17333,0x17b54c0,116,ReThrow
code-creation,BytecodeHandler,0,17349,0x17b5540,112,Return
code-creation,BytecodeHandler,0,17365,0x17b55c0,192,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,17381,0x17b56c0,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,17398,0x17b5780,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,17415,0x17b5840,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,17432,0x17b5900,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,17448,0x17b5980,512,SuspendGenerator
code-creation,BytecodeHandler,0,17465,0x17b5bc0,140,ResumeGenerator
code-creation,BytecodeHandler,0,17481,0x17b5c80,164,GetIterator
code-creation,BytecodeHandler,0,17497,0x17b5d40,116,Debugger
code-creation,BytecodeHandler,0,17517,0x17b5dc0,124,IncBlockCounter
code-creation,BytecodeHandler,0,17533,0x17b5e40,56,Abort
code-creation,BytecodeHandler,0,17550,0x17b5e80,32,Star0
code-creation,BytecodeHandler,0,17566,0x17b5ec0,60,Illegal
code-creation,BytecodeHandler,0,17582,0x17b5f00,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,17599,0x17b5f80,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,17615,0x17b6000,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,17631,0x17b6080,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,17647,0x17b6100,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,17664,0x17b6180,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,17680,0x17b6200,32,Ldar.Wide
code-creation,BytecodeHandler,0,17696,0x17b6240,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,17712,0x17b6280,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,17728,0x17b62c0,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,17745,0x17b6340,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,17762,0x17b63c0,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,17778,0x17b6400,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,17795,0x17b6440,32,Star.Wide
code-creation,BytecodeHandler,0,17811,0x17b6480,48,Mov.Wide
code-creation,BytecodeHandler,0,17828,0x17b64c0,40,PushContext.Wide
code-creation,BytecodeHandler,0,17844,0x17b6500,36,PopContext.Wide
code-creation,BytecodeHandler,0,17860,0x17b6540,56,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,17877,0x17b6580,4536,LdaGlobal.Wide
code-creation,BytecodeHandler,0,17894,0x17b7740,4464,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,17910,0x17b88c0,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,17927,0x17b8980,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,17944,0x17b8a40,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,17961,0x17b8ac0,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,17977,0x17b8b80,248,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,17994,0x17b8c80,4732,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,18010,0x17b9f00,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18027,0x17b9fc0,248,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18044,0x17ba0c0,4636,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,18061,0x17bb300,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,18078,0x17bb400,5304,GetNamedProperty.Wide
code-creation,BytecodeHandler,0,18094,0x17bc8c0,192,GetNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,18111,0x17bc9c0,156,GetKeyedProperty.Wide
code-creation,BytecodeHandler,0,18128,0x17bca80,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,18144,0x17bcb40,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,18161,0x17bcc80,180,SetNamedProperty.Wide
code-creation,BytecodeHandler,0,18177,0x17bcd40,180,DefineNamedOwnProperty.Wide
tick,0x7f6e650178bf,18206,0,0x0,6
code-creation,BytecodeHandler,0,18239,0x17bce00,172,SetKeyedProperty.Wide
code-creation,BytecodeHandler,0,18245,0x17bcec0,172,DefineKeyedOwnProperty.Wide
code-creation,BytecodeHandler,0,18248,0x17bcf80,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,18251,0x17bd040,204,DefineKeyedOwnPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,18253,0x17bd140,168,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,18256,0x17bd200,988,Add.Wide
code-creation,BytecodeHandler,0,18259,0x17bd600,1024,Sub.Wide
code-creation,BytecodeHandler,0,18261,0x17bda40,992,Mul.Wide
code-creation,BytecodeHandler,0,18263,0x17bde40,992,Div.Wide
code-creation,BytecodeHandler,0,18265,0x17be240,944,Mod.Wide
code-creation,BytecodeHandler,0,18267,0x17be600,1000,Exp.Wide
code-creation,BytecodeHandler,0,18269,0x17bea00,1016,BitwiseOr.Wide
code-creation,BytecodeHandler,0,18271,0x17bee00,1016,BitwiseXor.Wide
code-creation,BytecodeHandler,0,18290,0x17bf200,1016,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,18296,0x17bf600,1032,ShiftLeft.Wide
code-creation,BytecodeHandler,0,18299,0x17bfa40,1032,ShiftRight.Wide
code-creation,BytecodeHandler,0,18304,0x17bfe80,1152,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,18307,0x17c0340,920,AddSmi.Wide
code-creation,BytecodeHandler,0,18309,0x17c0700,932,SubSmi.Wide
code-creation,BytecodeHandler,0,18311,0x17c0ac0,892,MulSmi.Wide
code-creation,BytecodeHandler,0,18314,0x17c0e40,940,DivSmi.Wide
code-creation,BytecodeHandler,0,18316,0x17c1200,812,ModSmi.Wide
code-creation,BytecodeHandler,0,18318,0x17c1540,868,ExpSmi.Wide
code-creation,BytecodeHandler,0,18320,0x17c18c0,508,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,18322,0x17c1ac0,508,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,18325,0x17c1cc0,508,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,18327,0x17c1ec0,532,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,18329,0x17c2100,520,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,18333,0x17c2340,828,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,18348,0x17c2680,624,Inc.Wide
code-creation,BytecodeHandler,0,18379,0x17c2900,624,Dec.Wide
code-creation,BytecodeHandler,0,18395,0x17c2b80,660,Negate.Wide
code-creation,BytecodeHandler,0,18412,0x17c2e40,512,BitwiseNot.Wide
code-creation,BytecodeHandler,0,18428,0x17c3080,128,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,18445,0x17c3140,120,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,18462,0x17c31c0,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,18479,0x17c3200,1104,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,18495,0x17c3680,1104,CallProperty.Wide
code-creation,BytecodeHandler,0,18512,0x17c3b00,1000,CallProperty0.Wide
code-creation,BytecodeHandler,0,18529,0x17c3f00,1012,CallProperty1.Wide
code-creation,BytecodeHandler,0,18546,0x17c4300,1024,CallProperty2.Wide
code-creation,BytecodeHandler,0,18562,0x17c4740,976,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,18579,0x17c4b40,1036,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,18596,0x17c4f80,1012,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,18613,0x17c5380,1032,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,18630,0x17c57c0,1104,CallWithSpread.Wide
code-creation,BytecodeHandler,0,18646,0x17c5c40,132,CallRuntime.Wide
code-creation,BytecodeHandler,0,18663,0x17c5d00,176,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,18680,0x17c5dc0,88,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,18696,0x17c5e40,1320,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,18713,0x17c6380,964,Construct.Wide
code-creation,BytecodeHandler,0,18729,0x17c6780,460,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,18746,0x17c6980,1944,TestEqual.Wide
code-creation,BytecodeHandler,0,18763,0x17c7140,1056,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,18779,0x17c7580,1612,TestLessThan.Wide
code-creation,BytecodeHandler,0,18796,0x17c7c00,1612,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,18813,0x17c8280,1612,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,18829,0x17c8900,1612,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,18846,0x17c8f80,876,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,18863,0x17c9300,156,TestIn.Wide
code-creation,BytecodeHandler,0,18879,0x17c93c0,120,ToName.Wide
code-creation,BytecodeHandler,0,18896,0x17c9440,224,ToNumber.Wide
code-creation,BytecodeHandler,0,18912,0x17c9540,244,ToNumeric.Wide
code-creation,BytecodeHandler,0,18929,0x17c9640,120,ToObject.Wide
code-creation,BytecodeHandler,0,18945,0x17c96c0,408,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,18962,0x17c9880,1396,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,18979,0x17c9e00,792,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,18996,0x17ca140,2168,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,19013,0x17ca9c0,176,CloneObject.Wide
code-creation,BytecodeHandler,0,19030,0x17caa80,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,19047,0x17cab40,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,19063,0x17cacc0,120,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,19080,0x17cad40,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,19100,0x17cae00,260,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,19117,0x17caf40,260,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,19134,0x17cb080,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,19151,0x17cb140,492,JumpLoop.Wide
code-creation,BytecodeHandler,0,19167,0x17cb340,44,Jump.Wide
code-creation,BytecodeHandler,0,19183,0x17cb380,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,19200,0x17cb3c0,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,19217,0x17cb440,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,19233,0x17cb4c0,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,19250,0x17cb540,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,19267,0x17cb5c0,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,19284,0x17cb640,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,19301,0x17cb6c0,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,19318,0x17cb740,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,19335,0x17cb7c0,160,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,19352,0x17cb880,156,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,19385,0x17cb940,144,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,19402,0x17cba00,144,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,19437,0x17cbac0,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,19454,0x17cbb40,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,19470,0x17cbbc0,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,19487,0x17cbc40,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,19503,0x17cbcc0,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,19520,0x17cbd40,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,19537,0x17cbdc0,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,19554,0x17cbe40,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,19571,0x17cbec0,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,19588,0x17cbf40,472,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,19604,0x17cc140,260,ForInPrepare.Wide
code-creation,BytecodeHandler,0,19621,0x17cc280,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,19638,0x17cc300,268,ForInNext.Wide
code-creation,BytecodeHandler,0,19654,0x17cc440,48,ForInStep.Wide
code-creation,BytecodeHandler,0,19671,0x17cc480,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,19688,0x17cc540,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,19704,0x17cc600,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,19721,0x17cc680,532,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,19737,0x17cc8c0,140,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,19754,0x17cc980,168,GetIterator.Wide
code-creation,BytecodeHandler,0,19771,0x17cca40,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,19787,0x17ccb00,56,Abort.Wide
code-creation,BytecodeHandler,0,19804,0x17ccb40,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,19820,0x17ccbc0,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,19837,0x17ccc40,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,19853,0x17cccc0,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,19870,0x17ccd40,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,19887,0x17ccdc0,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,19904,0x17cce40,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,19920,0x17cce80,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,19937,0x17ccec0,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,19953,0x17ccf00,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19970,0x17ccf80,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,19987,0x17cd000,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,20004,0x17cd040,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,20021,0x17cd080,32,Star.ExtraWide
code-creation,BytecodeHandler,0,20037,0x17cd0c0,44,Mov.ExtraWide
code-creation,BytecodeHandler,0,20057,0x17cd100,40,PushContext.ExtraWide
code-creation,BytecodeHandler,0,20074,0x17cd140,36,PopContext.ExtraWide
code-creation,BytecodeHandler,0,20091,0x17cd180,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,20108,0x17cd1c0,4524,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,20125,0x17ce380,4452,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,20142,0x17cf500,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,20158,0x17cf5c0,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,20175,0x17cf680,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,20192,0x17cf700,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,20209,0x17cf7c0,244,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,20226,0x17cf8c0,4716,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,20243,0x17d0b40,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,20260,0x17d0c00,244,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,20277,0x17d0d00,4624,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,20294,0x17d1f40,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,20311,0x17d2040,5284,GetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,20328,0x17d3500,188,GetNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,20346,0x17d35c0,156,GetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,20363,0x17d3680,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,20380,0x17d3740,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,20396,0x17d3880,176,SetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,20413,0x17d3940,176,DefineNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,20430,0x17d3a00,168,SetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,20447,0x17d3ac0,168,DefineKeyedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,20464,0x17d3b80,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,20480,0x17d3c40,200,DefineKeyedOwnPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,20498,0x17d3d40,168,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,20515,0x17d3e00,984,Add.ExtraWide
tick,0x7f6e650178bf,20538,0,0x0,6
tick,0x7f6e64f8dec0,20556,0,0x0,6
tick,0x7f6e64f94337,20561,0,0x0,6
code-creation,BytecodeHandler,0,20597,0x17d4200,1024,Sub.ExtraWide
code-creation,BytecodeHandler,0,20607,0x17d4640,988,Mul.ExtraWide
code-creation,BytecodeHandler,0,20609,0x17d4a40,992,Div.ExtraWide
code-creation,BytecodeHandler,0,20612,0x17d4e40,944,Mod.ExtraWide
code-creation,BytecodeHandler,0,20614,0x17d5200,996,Exp.ExtraWide
code-creation,BytecodeHandler,0,20616,0x17d5600,1012,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,20618,0x17d5a00,1016,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,20621,0x17d5e00,1016,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,20623,0x17d6200,1028,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,20625,0x17d6640,1028,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,20628,0x17d6a80,1152,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,20630,0x17d6f40,916,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,20632,0x17d7300,928,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,20635,0x17d76c0,892,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,20637,0x17d7a40,936,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,20639,0x17d7e00,812,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,20641,0x17d8140,864,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,20643,0x17d84c0,508,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,20646,0x17d86c0,508,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,20648,0x17d88c0,508,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,20650,0x17d8ac0,528,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,20653,0x17d8d00,516,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,20655,0x17d8f40,828,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,20658,0x17d9280,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,20663,0x17d9500,620,Dec.ExtraWide
code-creation,BytecodeHandler,0,20666,0x17d9780,656,Negate.ExtraWide
code-creation,BytecodeHandler,0,20668,0x17d9a40,508,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,20670,0x17d9c40,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,20673,0x17d9cc0,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,20675,0x17d9d40,40,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,20678,0x17d9d80,1100,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,20680,0x17da200,1100,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,20683,0x17da680,996,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,20685,0x17daa80,1004,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,20687,0x17dae80,1016,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,20690,0x17db280,972,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,20692,0x17db680,1036,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,20695,0x17dbac0,1008,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,20697,0x17dbec0,1028,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,20700,0x17dc300,1100,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,20702,0x17dc780,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,20705,0x17dc840,176,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,20707,0x17dc900,84,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,20709,0x17dc980,1320,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,20712,0x17dcec0,960,Construct.ExtraWide
code-creation,BytecodeHandler,0,20714,0x17dd2c0,456,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,20717,0x17dd4c0,1944,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,20719,0x17ddc80,1052,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,20721,0x17de0c0,1608,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,20724,0x17de740,1608,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,20726,0x17dedc0,1608,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,20728,0x17df440,1608,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,20731,0x17dfac0,872,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,20733,0x17dfe40,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,20736,0x17dff00,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,20738,0x17dff80,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,20740,0x17e0080,240,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,20742,0x17e0180,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,20745,0x17e0200,404,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,20747,0x17e03c0,1392,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,20749,0x17e0940,792,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,20752,0x17e0c80,2164,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,20755,0x17e1500,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,20757,0x17e15c0,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,20759,0x17e1680,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,20762,0x17e1800,120,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,20764,0x17e1880,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,20767,0x17e1940,260,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,20769,0x17e1a80,260,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,20771,0x17e1bc0,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,20774,0x17e1c80,488,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,20776,0x17e1e80,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,20778,0x17e1ec0,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,20781,0x17e1f00,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20783,0x17e1f80,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20786,0x17e2000,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,20788,0x17e2080,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,20792,0x17e2100,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,20795,0x17e2180,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,20798,0x17e2200,80,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,20800,0x17e2280,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,20803,0x17e2300,160,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,20805,0x17e23c0,156,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,20808,0x17e2480,144,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,20810,0x17e2540,144,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,20813,0x17e2600,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,20815,0x17e2680,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,20818,0x17e2700,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,20820,0x17e2780,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,20822,0x17e2800,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,20825,0x17e2880,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,20827,0x17e2900,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,20830,0x17e2980,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,20832,0x17e2a00,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,20835,0x17e2a80,472,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,20837,0x17e2c80,256,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,20840,0x17e2dc0,64,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,20843,0x17e2e40,264,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,20845,0x17e2f80,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,20848,0x17e2fc0,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,20850,0x17e3080,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,20853,0x17e3140,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,20856,0x17e31c0,528,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,20858,0x17e3400,136,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,20860,0x17e34c0,164,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,20863,0x17e3580,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,20865,0x17e3600,56,Abort.ExtraWide
tick,0x7f6e650a397b,21647,0,0x0,6
new,MemoryChunk,0x33c0d1780000,262144
new,MemoryChunk,0x227cb5380000,262144
new,MemoryChunk,0x3694bf280000,262144
tick,0x132010b,22748,0,0x0,5
new,MemoryChunk,0x3f370e3c0000,262144
new,MemoryChunk,0x3a1b5d300000,262144
tick,0x119ef40,23850,0,0x0,5
code-creation,Eval,10,24307,0x3a1b5d3054a0,5, node:internal/main/run_main_module:1:1,0x3a1b5d305358,~
script-source,390,node:internal/main/run_main_module,'use strict';\n\nconst { RegExpPrototypeExec } = primordials;\n\nconst {\n  prepareMainThreadExecution\x2C\n  markBootstrapComplete\x2C\n} = require('internal/process/pre_execution');\nconst { getOptionValue } = require('internal/options');\n\nconst mainEntry = prepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Necessary to reset RegExp statics before user code runs.\nRegExpPrototypeExec(/^/\x2C '');\n\nif (getOptionValue('--experimental-default-type') === 'module') {\n  require('internal/modules/run_main').executeUserEntryPoint(mainEntry);\n} else {\n  /**\n   * To support legacy monkey-patching of `Module.runMain`\x2C we call `runMain` here to have the CommonJS loader begin\n   * the execution of the main entry point\x2C even if the ESM loader immediately takes over because the main entry is an\n   * ES module or one of the other opt-in conditions (such as the use of `--import`) are met. Users can monkey-patch\n   * before the main entry point is loaded by doing so via scripts loaded through `--require`. This monkey-patchability\n   * is undesirable and is removed in `--experimental-default-type=module` mode.\n   */\n  require('internal/modules/cjs/loader').Module.runMain(mainEntry);\n}\n
code-source-info,0x3a1b5d3054a0,390,0,1182,C0O0C4O1182,,
code-creation,Function,10,24358,0x3a1b5d305590,119, node:internal/main/run_main_module:1:1,0x3a1b5d305418,~
code-source-info,0x3a1b5d305590,390,0,1182,C0O23C5O128C8O128C13O71C18O101C23O198C26O198C31O179C36O246C38O246C43O281C46O367C54O367C59O398C62O402C69O448C74O466C77O466C82O502C87O503C94O1114C97O1114C102O1152C107O1159C112O1160C118O1181,,
code-creation,LazyCompile,10,24576,0x3a1b5d3058d8,45,prepareMainThreadExecution node:internal/process/pre_execution:39:36,0x1d7bd0eee488,~
script-source,67,node:internal/process/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  SafeMap\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolDispose\x2C\n  SymbolAsyncDispose\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  refreshOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  defineOperation\x2C\n  exposeInterface\x2C\n  exposeLazyInterfaces\x2C\n  defineReplaceableLazyAttribute\x2C\n  setupCoverageHooks\x2C\n} = require('internal/util');\n\nconst {\n  ERR_MANIFEST_ASSERT_INTEGRITY\x2C\n} = require('internal/errors').codes;\nconst assert = require('internal/assert');\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n\nfunction prepareMainThreadExecution(expandArgv1 = false\x2C initializeModules = true) {\n  return prepareExecution({\n    expandArgv1\x2C\n    initializeModules\x2C\n    isMainThread: true\x2C\n  });\n}\n\nfunction prepareWorkerThreadExecution() {\n  prepareExecution({\n    expandArgv1: false\x2C\n    initializeModules: false\x2C  // Will need to initialize it after policy setup\n    isMainThread: false\x2C\n  });\n}\n\nfunction prepareExecution(options) {\n  const { expandArgv1\x2C initializeModules\x2C isMainThread } = options;\n\n  refreshRuntimeOptions();\n  reconnectZeroFillToggle();\n\n  // Patch the process object and get the resolved main entry point.\n  const mainEntry = patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupFetch();\n  setupWebCrypto();\n  setupCustomEvent();\n  setupCodeCoverage();\n  setupDebugEnv();\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n\n  require('internal/dns/utils').initializeDns();\n\n  setupSymbolDisposePolyfill();\n\n  if (isMainThread) {\n    assert(internalBinding('worker').isMainThread);\n    // Worker threads will get the manifest in the message handler.\n    const policy = readPolicyFromDisk();\n    if (policy) {\n      require('internal/process/policy')\n        .setup(policy.manifestSrc\x2C policy.manifestURL);\n    }\n\n    // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n    setupStacktracePrinterOnSigint();\n    initializeReportSignalHandlers();  // Main-thread-only.\n    initializeHeapSnapshotSignalHandlers();\n    // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n    // spawned by our child_process module\x2C then initialize IPC.\n    // This attaches some internal event listeners and creates:\n    // process.send()\x2C process.channel\x2C process.connected\x2C\n    // process.disconnect().\n    setupChildProcessIpcChannel();\n    // If this is a worker in cluster mode\x2C start up the communication\n    // channel. This needs to be done before any user code gets executed\n    // (including preload modules).\n    initializeClusterIPC();\n\n    // TODO(joyeecheung): do this for worker threads as well.\n    require('internal/v8/startup_snapshot').runDeserializeCallbacks();\n  } else {\n    assert(!internalBinding('worker').isMainThread);\n    // The setup should be called in LOAD_SCRIPT message handler.\n    assert(!initializeModules);\n  }\n\n  if (initializeModules) {\n    setupUserModules();\n  }\n\n  return mainEntry;\n}\n\nfunction setupSymbolDisposePolyfill() {\n  // TODO(MoLow): Remove this polyfill once Symbol.dispose and Symbol.asyncDispose are available in V8.\n  // eslint-disable-next-line node-core/prefer-primordials\n  if (typeof Symbol.dispose !== 'symbol') {\n    ObjectDefineProperty(Symbol\x2C 'dispose'\x2C {\n      __proto__: null\x2C\n      configurable: false\x2C\n      enumerable: false\x2C\n      value: SymbolDispose\x2C\n      writable: false\x2C\n    });\n  }\n\n  // eslint-disable-next-line node-core/prefer-primordials\n  if (typeof Symbol.asyncDispose !== 'symbol') {\n    ObjectDefineProperty(Symbol\x2C 'asyncDispose'\x2C {\n      __proto__: null\x2C\n      configurable: false\x2C\n      enumerable: false\x2C\n      value: SymbolAsyncDispose\x2C\n      writable: false\x2C\n    });\n  }\n}\n\nfunction setupUserModules(isLoaderWorker = false) {\n  initializeCJSLoader();\n  initializeESMLoader(isLoaderWorker);\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  // Loader workers are responsible for doing this themselves.\n  if (isLoaderWorker) {\n    return;\n  }\n  loadPreloadModules();\n  // Need to be done after --require setup.\n  initializeFrozenIntrinsics();\n}\n\nfunction refreshRuntimeOptions() {\n  refreshOptions();\n}\n\n/**\n * Patch the process object with legacy properties and normalizations.\n * Replace `process.argv[0]` with `process.execPath`\x2C preserving the original `argv[0]` value as `process.argv0`.\n * Replace `process.argv[1]` with the resolved absolute file path of the entry point\x2C if found.\n * @param {boolean} expandArgv1 - Whether to replace `process.argv[1]` with the resolved absolute file path of\n * the main entry point.\n */\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  // Since we replace process.argv[0] below\x2C preserve the original value in case the user needs it.\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    // Only set it to true during snapshot building.\n    configurable: getOptionValue('--build-snapshot')\x2C\n    value: process.argv[0]\x2C\n  });\n\n  process.exitCode = undefined;\n  process._exiting = false;\n  process.argv[0] = process.execPath;\n\n  /** @type {string} */\n  let mainEntry;\n  // If requested\x2C update process.argv[1] to replace whatever the user provided with the resolved absolute file path of\n  // the entry point.\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      mainEntry = path.resolve(process.argv[1]);\n      process.argv[1] = mainEntry;\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // We need to initialize the global console here again with process.stdout\n  // and friends for snapshot deserialization.\n  const globalConsole = require('internal/console/global');\n  const { initializeGlobalConsole } = require('internal/console/constructor');\n  initializeGlobalConsole(globalConsole);\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n\n  return mainEntry;\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\x2C\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\x2C\n    resetForSerialization\x2C\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n\n    // The code above would add the listener back during deserialization\x2C\n    // if applicable.\n    if (isBuildingSnapshot()) {\n      addSerializeCallback(() => {\n        process.removeListener('warning'\x2C onWarning);\n        resetForSerialization();\n      });\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/\nfunction setupFetch() {\n  if (process.config.variables.node_no_browser_globals ||\n      getOptionValue('--no-experimental-fetch')) {\n    return;\n  }\n\n  let undici;\n  function lazyUndici() {\n    if (undici) {\n      return undici;\n    }\n\n    undici = require('internal/deps/undici/undici');\n    return undici;\n  }\n\n  async function fetch(input\x2C init = undefined) {\n    return lazyUndici().fetch(input\x2C init);\n  }\n\n  defineOperation(globalThis\x2C 'fetch'\x2C fetch);\n\n  function lazyInterface(name) {\n    return {\n      configurable: true\x2C\n      enumerable: false\x2C\n      get() {\n        return lazyUndici()[name];\n      }\x2C\n      set(value) {\n        exposeInterface(globalThis\x2C name\x2C value);\n      }\x2C\n    };\n  }\n\n  ObjectDefineProperties(globalThis\x2C {\n    FormData: lazyInterface('FormData')\x2C\n    Headers: lazyInterface('Headers')\x2C\n    Request: lazyInterface('Request')\x2C\n    Response: lazyInterface('Response')\x2C\n  });\n\n  // The WebAssembly Web API: https://webassembly.github.io/spec/web-api\n  internalBinding('wasm_web_api').setImplementation((streamState\x2C source) => {\n    require('internal/wasm_web_api').wasmStreamingCallback(streamState\x2C source);\n  });\n}\n\n// TODO(aduh95): move this to internal/bootstrap/browser when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-webcrypto')) {\n    return;\n  }\n\n  if (internalBinding('config').hasOpenSSL) {\n    defineReplaceableLazyAttribute(\n      globalThis\x2C 'internal/crypto/webcrypto'\x2C ['crypto']\x2C false\x2C\n    );\n    exposeLazyInterfaces(\n      globalThis\x2C 'internal/crypto/webcrypto'\x2C\n      ['Crypto'\x2C 'CryptoKey'\x2C 'SubtleCrypto']\x2C\n    );\n  }\n}\n\nfunction setupCodeCoverage() {\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd. Don't do anything if the\n  // --experimental-test-coverage flag is present\x2C as the test runner will\n  // handle coverage.\n  if (process.env.NODE_V8_COVERAGE &&\n      !getOptionValue('--experimental-test-coverage')) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n}\n\n// TODO(daeyeon): move this to internal/bootstrap/browser when the CLI flag is\n//                removed.\nfunction setupCustomEvent() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-customevent')) {\n    return;\n  }\n  const { CustomEvent } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'CustomEvent'\x2C CustomEvent);\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      const { report } = require('internal/process/report');\n      return report;\n    }\x2C\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/realm').BuiltinModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  if (getOptionValue('--report-on-signal')) {\n    const { addSignalHandler } = require('internal/process/report');\n    addSignalHandler();\n  }\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  function doWriteHeapSnapshot() {\n    writeHeapSnapshot();\n  }\n  process.on(signal\x2C doWriteHeapSnapshot);\n\n  // The code above would add the listener back during deserialization\x2C\n  // if applicable.\n  if (isBuildingSnapshot()) {\n    addSerializeCallback(() => {\n      process.removeListener(signal\x2C doWriteHeapSnapshot);\n    });\n  }\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\x2C\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\x2C\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction readPolicyFromDisk() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = pathToFileURL(experimentalPolicy);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\x2C\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    return {\n      manifestSrc: src\x2C manifestURL: manifestURL.href\x2C\n    };\n  }\n}\n\nfunction initializeCJSLoader() {\n  const { initializeCJS } = require('internal/modules/cjs/loader');\n  initializeCJS();\n}\n\nfunction initializeESMLoader(isLoaderWorker) {\n  const { initializeESM } = require('internal/modules/esm/utils');\n  initializeESM(isLoaderWorker);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const {\n    setSourceMapsEnabled\x2C\n  } = require('internal/source_map/source_map_cache');\n  setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\x2C\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nfunction markBootstrapComplete() {\n  internalBinding('performance').markBootstrapComplete();\n}\n\nmodule.exports = {\n  setupUserModules\x2C\n  prepareMainThreadExecution\x2C\n  prepareWorkerThreadExecution\x2C\n  markBootstrapComplete\x2C\n  loadPreloadModules\x2C\n  initializeFrozenIntrinsics\x2C\n};\n
code-source-info,0x3a1b5d3058d8,67,791,940,C20O843C30O873C36O890C40O850C44O938,,
tick,0x106e5e8,25148,0,0x0,3,0x12da7b0,0x3a1b5d3055b6
code-creation,LazyCompile,10,25212,0x3a1b5d307018,309,prepareExecution node:internal/process/pre_execution:55:26,0x1d7bd0eee8b0,~
code-source-info,0x3a1b5d307018,67,1168,3296,C0O1190C5O1203C10O1222C15O1251C18O1251C21O1278C26O1278C29O1395C32O1395C37O1430C40O1430C43O1459C46O1459C49O1479C52O1479C55O1504C58O1504C61O1529C64O1529C67O1545C70O1545C73O1565C76O1565C79O1587C82O1587C85O1610C88O1610C91O1698C94O1698C97O1720C100O1720C103O1754C106O1754C109O1783C115O1783C120O1812C125O1813C129O1833C132O1833C135O1866C139O1890C150O1897C155O1922C160O1890C164O2025C167O2025C171O2051C173O2071C179O2071C184O2114C189O2128C194O2148C199O2115C205O2247C208O2247C211O2285C214O2285C217O2345C220O2345C223O2679C226O2679C229O2894C232O2894C235O2985C241O2985C246O3024C251O3025C257O3067C268O3075C273O3100C279O3067C283O3186C290O3194C292O3186C296O3221C300O3250C303O3250C306O3277C308O3294,,
code-creation,LazyCompile,10,25241,0x3a1b5d307308,10,refreshRuntimeOptions node:internal/process/pre_execution:159:31,0x1d7bd0eee9a0,~
code-source-info,0x3a1b5d307308,67,4495,4521,C0O4502C5O4502C9O4520,,
code-creation,LazyCompile,10,25260,0x3a1b5d3073f8,22,refreshOptions node:internal/options:39:24,0x28d42e28a950,~
script-source,22,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction refreshOptions() {\n  optionsMap = undefined;\n  aliasesMap = undefined;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n};\n
code-source-info,0x3a1b5d3073f8,22,902,960,C0O909C4O920C10O935C14O946C21O959,,
code-creation,LazyCompile,10,25364,0x3a1b5d307760,19,reconnectZeroFillToggle node:internal/buffer:1074:33,0x32bbd744c338,~
script-source,31,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\x2C\n} = internalBinding('buffer');\n\nconst {\n  privateSymbols: {\n    untransferable_object_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  obj[untransferable_object_private_symbol] = true;\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\x2C\n};\n
code-source-info,0x3a1b5d307760,31,30714,30754,C0O30721C5O30732C11O30730C18O30753,,
tick,0x7f6e64f83003,26211,0,0x0,3,0x12da7b0,0x3a1b5d307032,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,26288,0x3a1b5d30a098,466,patchProcessObject node:internal/process/pre_execution:170:28,0x1d7bd0eee9f0,~
code-source-info,0x3a1b5d30a098,67,4975,7392,C0O5009C6O5009C11O5055C19O5055C24O5087C30O5087C35O5125C40O5126C44O5252C55O5273C62O5407C68O5407C79O5462C85O5466C92O5252C97O5480C101O5497C105O5512C109O5529C113O5540C116O5548C126O5566C130O5556C134O5607C136O5762C143O5789C150O5793C157O5807C163O5841C170O5845C177O5807C184O5923C190O5923C198O5973C206O5989C213O5993C217O5973C223O6005C226O6013C236O6021C246O6246C252O6246C257O6320C263O6320C268O6292C273O6363C277O6546C286O6546C291O6592C300O6592C305O6645C314O6645C319O6705C328O6705C333O6763C342O6763C347O6823C356O6823C361O6887C370O6887C375O6952C384O6952C389O7023C398O7023C403O7093C412O7093C417O7153C426O7153C431O7223C442O7223C447O7293C458O7293C463O7373C465O7390,,
code-creation,LazyCompile,10,26376,0x3a1b5d30a620,82,getOptionValue node:internal/options:44:24,0x28d42e28a9a0,~
code-source-info,0x3a1b5d30a620,22,985,1228,C0O1018C3O1018C7O1063C15O1063C22O1113C30O1135C38O1135C43O1122C47O1113C53O1150C55O1175C60O1181C61O1203C66O1203C74O1218C81O1226,,
code-creation,LazyCompile,10,26399,0x3a1b5d30a780,33,getCLIOptionsFromBinding node:internal/options:18:34,0x28d42e28a788,~
code-source-info,0x3a1b5d30a780,22,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
code-creation,LazyCompile,10,26727,0x3a1b5d30ab58,188,resolve node:path:1091:10,0x32bbd746c180,~
script-source,40,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C `paths[${i}]`);\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path\x2C `paths[${i}]`);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [suffix]\n   * @returns {string}\n   */\n  basename(path\x2C suffix) {\n    if (suffix !== undefined)\n      validateString(suffix\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {\n      if (suffix === path)\n        return '';\n      let extIdx = suffix.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(suffix\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\x2C\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x3a1b5d30ab58,40,33819,34735,C0O33819C3O33854C6O33885C8O33915C12O33922C16O33935C18O33929C25O33939C27O33983C28O33985C35O33996C42O34002C45O34002C49O34020C59O34050C70O34020C75O34101C81O34108C86O34125C88O34150C100O34176C105O34198C112O34225C120O34264C122O34260C126O33958C131O33897C134O34480C139O34526C150O34495C156O34612C160O34642C165O34653C169O34668C170O34699C176O34706C187O34731,,
tick,0x106e5f5,27960,0,0x0,3,0x12da7b0,0x3a1b5d30a171,0x3a1b5d307038,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,27981,0x3a1b5d30dd90,13, node:path:1082:10,0x32bbd746c130,~
code-source-info,0x3a1b5d30dd90,40,33668,33687,C0O33682C3O33682C8O33682C12O33687,,
code-creation,LazyCompile,10,28011,0x3a1b5d30de90,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x1d7bd0efa4a0,~
script-source,73,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\x2C\n    }\x2C\n  } = require('internal/errors');\n  const {\n    validateUint32\x2C\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\x2C\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id >>>= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\x2C\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x3a1b5d30de90,73,3349,3433,C0O3356C7O3370C12O3382C17O3405C22O3405C29O3392C35O3414C39O3431,,
code-creation,LazyCompile,10,28183,0x3a1b5d30e510,442,normalizeString node:path:66:25,0x32bbd746bd70,~
code-source-info,0x3a1b5d30e510,40,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,28260,0x3a1b5d30e898,8,isPosixPathSeparator node:path:56:30,0x32bbd746bcd0,~
code-source-info,0x3a1b5d30e898,40,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,28433,0x3a1b5d30ecb8,385,initializeGlobalConsole node:internal/console/constructor:691:33,0x13800b149bd8,~
script-source,50,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\x2C\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (new.target === undefined) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\x2C\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: key\x2C\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value(instance) {\n    return instance[kIsConsole];\n  }\x2C\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { __proto__: null\x2C ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { __proto__: null\x2C ...consolePropAttributes\x2C value: stderr }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindStreamsLazy]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\x2C\n        }\x2C\n        '_stderr': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kBindProperties]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\x2C\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          __proto__: null\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\x2C\n        }\x2C\n        '_ignoreErrors': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\x2C\n        }\x2C\n        '_times': { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { __proto__: null\x2C ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { __proto__: null\x2C ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { __proto__: null\x2C ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: groupIndentation\x2C\n        }\x2C\n        [SymbolToStringTag]: {\n          __proto__: null\x2C\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\x2C\n        }\x2C\n      });\n    }\x2C\n  }\x2C\n  [kWriteToConsole]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = RegExpPrototypeSymbolReplace(/\\n/g\x2C string\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\x2C\n  }\x2C\n  [kGetInspectOptions]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = lazyUtilColors().shouldColorize(stream);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\x2C\n  }\x2C\n  [kFormatForStdout]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n  [kFormatForStderr]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\x2C\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\x2C\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\x2C\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\x2C\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    cliTable ??= require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\x2C\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = ObjectCreate(null);\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          map[key] ??= [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\x2C\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true\x2C 'auto');\n\n  const {\n    namespace: {\n      addSerializeCallback\x2C\n      isBuildingSnapshot\x2C\n    }\x2C\n  } = require('internal/v8/startup_snapshot');\n\n  if (!internalBinding('config').hasInspector || !isBuildingSnapshot()) {\n    return;\n  }\n  const { console: consoleFromVM } = internalBinding('inspector');\n  const nodeConsoleKeys = ObjectKeys(Console.prototype);\n  const vmConsoleKeys = ObjectKeys(consoleFromVM);\n  const originalKeys = new SafeSet(vmConsoleKeys.concat(nodeConsoleKeys));\n  const inspectorConsoleKeys = new SafeSet();\n  for (const key of ObjectKeys(globalConsole)) {\n    if (!originalKeys.has(key)) {\n      inspectorConsoleKeys.add(key);\n    }\n  }\n  // During deserialization these should be reinstalled to console by\n  // V8 when the inspector client is created.\n  addSerializeCallback(() => {\n    for (const key of inspectorConsoleKeys) {\n      globalConsole[key] = undefined;\n    }\n  });\n}\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  initializeGlobalConsole\x2C\n  formatTime\x2C // exported for tests\n};\n
code-source-info,0x3a1b5d30ecb8,50,20472,21479,C0O20472C12O20492C19O20506C21O20505C30O20523C35O20536C42O20550C44O20549C53O20566C59O20677C67O20677C72O20677C77O20616C82O20644C87O20721C95O20726C100O20751C106O20769C111O20797C112O20804C113O20846C121O20846C126O20828C131O20902C143O20921C148O20902C153O20957C160O20957C165O21007C172O21033C177O21033C185O21007C191O21090C198O21090C203O21090C205O21125C215O21125C244O21118C274O21118C277O21176C283O21176C293O21194C297O21215C303O21215C308O21107C374O21353C379O21353C384O21478,,
tick,0xf152a6,29078,0,0x0,3,0x12da7b0,0x3a1b5d30a1a9,0x3a1b5d307038,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,29105,0x3a1b5d3109a8,94,value node:internal/console/constructor:206:20,0x13800b149230,~
code-source-info,0x3a1b5d3109a8,50,5856,6493,C0O5856C15O5877C16O5877C18O5895C19O5895C21O5909C33O5959C38O6057C46O6164C60O6226C65O6324C73O6435C87O5909C93O6492,,
code-creation,LazyCompile,10,29181,0x3a1b5d310f70,414,value node:internal/console/constructor:236:20,0x13800b1492f0,~
code-source-info,0x3a1b5d310f70,50,6593,7993,C17O6649C27O6711C34O6753C52O6823C55O6793C73O6893C86O6990C89O6960C104O7039C111O7081C126O7121C129O7121C144O7173C151O7195C166O7229C169O7225C187O7320C191O7330C198O7352C213O7386C216O7382C235O7408C239O7421C246O7443C261O7473C275O7495C279O7508C286O7530C300O7560C314O7577C318O7592C325O7614C340O7644C354O7659C358O7684C365O7726C380O7766C394O7804C398O7824C407O6649C413O7992,,
code-creation,LazyCompile,10,29224,0x3a1b5d311388,18,createWriteErrorHandler node:internal/console/constructor:358:33,0x13800b149598,~
code-source-info,0x3a1b5d311388,50,10710,11567,C0O10710C13O10739C17O11565,,
code-creation,LazyCompile,10,29282,0x3a1b5d3115a0,25,isBuildingSnapshot node:internal/v8/startup_snapshot:19:28,0x13800b15f580,~
script-source,57,node:internal/v8/startup_snapshot,'use strict';\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  codes: {\n    ERR_NOT_BUILDING_SNAPSHOT\x2C\n    ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  setSerializeCallback\x2C\n  setDeserializeCallback\x2C\n  setDeserializeMainFunction: _setDeserializeMainFunction\x2C\n} = internalBinding('mksnapshot');\n\nfunction isBuildingSnapshot() {\n  // For now this is the only way to build a snapshot.\n  return require('internal/options').getOptionValue('--build-snapshot');\n}\n\nfunction throwIfNotBuildingSnapshot() {\n  if (!isBuildingSnapshot()) {\n    throw new ERR_NOT_BUILDING_SNAPSHOT();\n  }\n}\n\nconst deserializeCallbacks = [];\nlet deserializeCallbackIsSet = false;\nfunction runDeserializeCallbacks() {\n  while (deserializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = deserializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addDeserializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  if (!deserializeCallbackIsSet) {\n    // TODO(joyeecheung): when the main function handling is done in JS\x2C\n    // the deserialize callbacks can always be invoked. For now only\n    // store it in C++ when it's actually used to avoid unnecessary\n    // C++ -> JS costs.\n    setDeserializeCallback(runDeserializeCallbacks);\n    deserializeCallbackIsSet = true;\n  }\n  deserializeCallbacks.push([callback\x2C data]);\n}\n\nconst serializeCallbacks = [];\nfunction runSerializeCallbacks() {\n  while (serializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = serializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addSerializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  serializeCallbacks.push([callback\x2C data]);\n}\n\nfunction initializeCallbacks() {\n  // Only run the serialize callbacks in snapshot building mode\x2C otherwise\n  // they throw.\n  if (isBuildingSnapshot()) {\n    setSerializeCallback(runSerializeCallbacks);\n  }\n}\n\nlet deserializeMainIsSet = false;\nfunction setDeserializeMainFunction(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  // TODO(joyeecheung): In lib/internal/bootstrap/node.js\x2C create a default\n  // main function to run the lib/internal/main scripts and make sure that\n  // the main function set in the snapshot building process takes precedence.\n  validateFunction(callback\x2C 'callback');\n  if (deserializeMainIsSet) {\n    throw new ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION();\n  }\n  deserializeMainIsSet = true;\n\n  _setDeserializeMainFunction(function deserializeMain() {\n    const {\n      prepareMainThreadExecution\x2C\n      markBootstrapComplete\x2C\n    } = require('internal/process/pre_execution');\n\n    // This should be in sync with run_main_module.js until we make that\n    // a built-in main function.\n    // TODO(joyeecheung): make a copy of argv[0] and insert it as argv[1].\n    prepareMainThreadExecution(false);\n    markBootstrapComplete();\n    callback(data);\n  });\n}\n\nmodule.exports = {\n  initializeCallbacks\x2C\n  runDeserializeCallbacks\x2C\n  // Exposed to require('v8').startupSnapshot\n  namespace: {\n    addDeserializeCallback\x2C\n    addSerializeCallback\x2C\n    setDeserializeMainFunction\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n};\n
code-source-info,0x3a1b5d3115a0,57,397,531,C0O459C6O466C11O493C19O494C24O529,,
code-creation,LazyCompile,10,29402,0x3a1b5d311aa8,63,addReadOnlyProcessAlias node:internal/process/pre_execution:230:33,0x1d7bd0eeea40,~
code-source-info,0x3a1b5d311aa8,67,7426,7675,C16O7478C21O7478C26O7504C28O7521C36O7551C43O7637C49O7655C56O7521C62O7674,,
code-creation,LazyCompile,10,29437,0x3a1b5d311ce8,46,setupTraceCategoryState node:internal/process/pre_execution:415:33,0x1d7bd0eeee60,~
code-source-info,0x3a1b5d311ce8,67,12435,12662,C0O12477C6O12477C11O12450C16O12549C22O12549C27O12520C32O12591C35O12616C40O12591C45O12661,,
code-creation,LazyCompile,10,29481,0x3a1b5d311e80,77,toggleTraceCategoryState node:internal/process/per_thread:408:34,0x32bbd7451058,~
script-source,33,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ObjectDefineProperty\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\nfunction nop() {}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\x2C\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\x2C\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\x2C\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\x2C\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    const {\n      handleProcessExit\x2C\n    } = require('internal/modules/esm/handle_process_exit');\n    process.off('exit'\x2C handleProcessExit);\n\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n\n    // If this is a worker\x2C v8::Isolate::TerminateExecution() is called above.\n    // That function spoofs the stack pointer to cause the stack guard\n    // check to throw the termination exception. Because v8 performs\n    // stack guard check upon every function call\x2C we give it a chance.\n    //\n    // Without this\x2C user code after `process.exit()` would take effect.\n    // test/parallel/test-worker-voluntarily-exit-followed-by-addition.js\n    // test/parallel/test-worker-voluntarily-exit-followed-by-throw.js\n    nop();\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\x2C\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\x2C\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvvar }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvvar) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvvar;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeExec(leadingDashesRegex\x2C key) !== null) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\x2C\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  const flagSetValues = NodeEnvironmentFlagsSet.prototype.values;\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C SymbolIterator\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C 'keys'\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\x2C\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0x3a1b5d311e80,33,11918,12215,C0O11942C4O11971C10O12006C16O12037C21O12081C26O12082C33O12027C39O12106C44O12127C49O12127C55O12146C61O12178C66O12199C71O12199C76O12214,,
tick,0x7f6e64f83003,29979,0,0x0,3,0x12da7b0,0x3a1b5d311d10,0x3a1b5d307040,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,29991,0x3a1b5d312d70,22,setupPerfHooks node:internal/process/pre_execution:421:24,0x1d7bd0eeeeb0,~
code-source-info,0x3a1b5d312d70,67,12687,12747,C0O12694C6O12694C11O12724C16O12725C21O12746,,
code-creation,LazyCompile,10,30013,0x3a1b5d312e68,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x13800b15bc18,~
script-source,55,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\x2C\n};\n
code-source-info,0x3a1b5d312e68,55,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,30078,0x3a1b5d3130d8,62,setupInspectorHooks node:internal/process/pre_execution:425:29,0x1d7bd0eeef00,~
code-source-info,0x3a1b5d3130d8,67,12777,13331,C0O13120C6O13124C11O13149C17O13215C23O13215C28O13184C33O13198C38O13261C44O13261C49O13289C54O13290C61O13330,,
code-creation,LazyCompile,10,30113,0x3a1b5d313360,126,setupWarningHandler node:internal/process/pre_execution:243:29,0x1d7bd0eeea90,~
code-source-info,0x3a1b5d313360,67,7705,8197,C0O7705C11O7768C19O7768C24O7724C30O7739C36O7807C46O7811C57O7855C62O7859C69O7876C74O7891C79O7899C90O7899C96O8026C103O8030C108O8060C120O8060C125O8196,,
code-creation,LazyCompile,10,30192,0x3a1b5d313950,189,setupFetch node:internal/process/pre_execution:264:20,0x1d7bd0eeeae0,~
code-source-info,0x3a1b5d313950,67,8252,9384,C0O8252C24O8259C29O8271C34O8278C39O8288C49O8321C55O8321C61O8370C62O8377C63O8389C64O8389C66O8647C77O8663C86O8647C91O8940C102O8963C113O8991C124O9031C135O9070C146O9110C154O8940C159O9219C167O9219C172O9250C182O9251C188O9383,,
code-creation,LazyCompile,10,30230,0x3a1b5d313bc0,5,get node:internal/bootstrap/node:170:6,0x23f41f7a6ec8,~
script-source,17,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `Realm::BootstrapRealm()` in `src/node_realm.cc`\x2C\n// and is responsible for setting up Node.js core before main scripts\n// under `lib/internal/main/` are executed.\n//\n// By default\x2C Node.js binaries come with an embedded V8 startup snapshot\n// that is generated at build-time with a `node_mksnapshot` executable.\n// The snapshot generation code can be found in `SnapshotBuilder::Generate()`\n// from `src/node_snapshotable.cc`.\n// This snapshot captures the V8 heap initialized by scripts under\n// `lib/internal/bootstrap/`\x2C including this file. When initializing the main\n// thread\x2C Node.js deserializes the heap from the snapshot\x2C instead of actually\n// running this script and others in `lib/internal/bootstrap/`. To disable this\n// behavior\x2C pass `--no-node-snapshot` when starting the process so that\n// Node.js actually runs this script to initialize the heap.\n//\n// This script is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/process/pre_execution.js` or in main scripts. It should not\n// query any run-time states (e.g. command line arguments\x2C environment\n// variables) when being executed - functions in this script that are invoked\n// at a later time can\x2C however\x2C query those states lazily.\n// The majority of the code here focuses on setting up the global object and\n// the process object in a synchronous\x2C environment-independent manner.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: this saves copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/per_context/domexception.js`: implementation of the\n//   `DOMException` class.\n// - `lib/internal/per_context/messageport.js`: JS-side components of the\n//   `MessagePort` implementation.\n// - `lib/internal/bootstrap/realm.js`: this sets up internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `BuiltinModule`\x2C and per-realm internal states\n//   and bindings\x2C including `prepare_stack_trace_callback`.\n//\n// The initialization done in this script is included in both the main thread\n// and the worker threads. After this\x2C further initialization is done based\n// on the configuration of the Node.js instance by executing the scripts in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/process/pre_execution.js` depending on the run-time states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by `BuiltinLoader::CompileAndCall()`.\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nconst {\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPreventExtensions\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  ReflectSet\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst {\n  defineOperation\x2C\n  deprecate\x2C\n  defineLazyProperties\x2C\n} = require('internal/util');\nconst {\n  privateSymbols: {\n    exiting_aliased_Uint32Array\x2C\n  }\x2C\n} = internalBinding('util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\n{\n  const exitingAliasedUint32Array = process[exiting_aliased_Uint32Array];\n  ObjectDefineProperty(process\x2C '_exiting'\x2C {\n    __proto__: null\x2C\n    get() {\n      return exitingAliasedUint32Array[0] === 1;\n    }\x2C\n    set(value) {\n      exitingAliasedUint32Array[0] = value ? 1 : 0;\n    }\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n  });\n}\nprocess._exiting = false;\n\n// TODO(@jasnell): Once this has gone through one full major\n// release cycle\x2C remove the Proxy and setter and update the\n// getter to either return a read-only object or always return\n// a freshly parsed version of nativeModule.config.\n\nconst deprecationHandler = {\n  warned: false\x2C\n  message: 'Setting process.config is deprecated. ' +\n           'In the future the property will be read-only.'\x2C\n  code: 'DEP0150'\x2C\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message\x2C {\n        type: 'DeprecationWarning'\x2C\n        code: this.code\x2C\n      });\n      this.warned = true;\n    }\n  }\x2C\n\n  defineProperty(target\x2C key\x2C descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target\x2C key\x2C descriptor);\n  }\x2C\n\n  deleteProperty(target\x2C key) {\n    this.maybeWarn();\n    delete target[key];\n  }\x2C\n\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  }\x2C\n\n  set(target\x2C key\x2C value) {\n    this.maybeWarn();\n    return ReflectSet(target\x2C key\x2C value);\n  }\x2C\n\n  get(target\x2C key\x2C receiver) {\n    const val = ReflectGet(target\x2C key\x2C receiver);\n    if (val != null && typeof val === 'object') {\n      // eslint-disable-next-line node-core/prefer-primordials\n      return new Proxy(val\x2C deprecationHandler);\n    }\n    return val;\n  }\x2C\n\n  setPrototypeOf(target\x2C proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target\x2C proto);\n  }\x2C\n};\n\n// process.config is serialized config.gypi\nconst binding = internalBinding('builtins');\n\n// eslint-disable-next-line node-core/prefer-primordials\nlet processConfig = new Proxy(\n  JSONParse(binding.config)\x2C\n  deprecationHandler);\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n  get() { return processConfig; }\x2C\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\x2C\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n  process.getActiveResourcesInfo = rawMethods.getActiveResourcesInfo;\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.constrainedMemory = rawMethods.constrainedMemory;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n  queueMicrotask\x2C\n} = require('internal/process/task_queues');\n\n// Non-standard extensions:\ndefineOperation(globalThis\x2C 'queueMicrotask'\x2C queueMicrotask);\n\nconst timers = require('timers');\ndefineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\ndefineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\ndefineLazyProperties(\n  globalThis\x2C\n  'internal/structured_clone'\x2C\n  ['structuredClone']\x2C\n);\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  __proto__: null\x2C\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      __proto__: null\x2C\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\x2C\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because --no-node-snapshot disables the\n  // code cache even if the binary is built with embedded code cache.\n  get cached_builtins() {\n    return binding.hasCachedBuiltins();\n  }\x2C\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\x2C\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\x2C\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n{\n  const {\n    getSourceMapsEnabled\x2C\n    setSourceMapsEnabled\x2C\n    maybeCacheGeneratedSourceMap\x2C\n  } = require('internal/source_map/source_map_cache');\n  const {\n    setMaybeCacheGeneratedSourceMap\x2C\n  } = internalBinding('errors');\n\n  ObjectDefineProperty(process\x2C 'sourceMapsEnabled'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return getSourceMapsEnabled();\n    }\x2C\n  });\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n  // The C++ land calls back to maybeCacheGeneratedSourceMap()\n  // when code is generated by user with eval() or new Function()\n  // to cache the source maps from the evaluated code\x2C if any.\n  setMaybeCacheGeneratedSourceMap(maybeCacheGeneratedSourceMap);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\x2C\n  });\n\n  // Create global.process as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n  globalThis.global = globalThis;\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  // Create global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n
code-source-info,0x3a1b5d313bc0,17,5689,5717,C0O5694C4O5715,,
tick,0x7f6e64f83003,30666,0,0x0,3,0x12da7b0,0x3a1b5d31396d,0x3a1b5d307058,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,30690,0x3a1b5d314af8,52,get node:internal/bootstrap/node:143:6,0x23f41f7a6e28,~
code-source-info,0x3a1b5d314af8,17,4970,5234,C0O5012C14O5012C20O5051C29O5166C35O5188C43O5173C48O5208C49O5219C51O5230,,
code-creation,LazyCompile,10,30736,0x3a1b5d314d98,33,lazyInterface node:internal/process/pre_execution:286:25,0x3a1b5d313760,~
code-source-info,0x3a1b5d314d98,67,8717,8936,C0O8717C9O8730C14O8796C22O8854C32O8932,,
code-creation,LazyCompile,10,30787,0x3a1b5d315170,102,setupWebCrypto node:internal/process/pre_execution:314:24,0x1d7bd0eeeb90,~
code-source-info,0x3a1b5d315170,67,9513,9940,C0O9520C3O9532C8O9539C13O9549C21O9583C27O9583C33O9640C34O9647C35O9655C41O9659C46O9684C52O9703C59O9741C72O9703C77O9812C84O9840C95O9812C101O9939,,
code-creation,LazyCompile,10,30817,0x3a1b5d315378,74,setupCustomEvent node:internal/process/pre_execution:346:26,0x1d7bd0eeec30,~
code-source-info,0x3a1b5d315378,67,10596,10857,C0O10603C3O10615C8O10622C13O10632C21O10666C27O10666C33O10725C34O10732C35O10763C41O10763C46O10747C51O10799C58O10815C67O10799C73O10856,,
code-creation,LazyCompile,10,30841,0x3a1b5d315530,64,setupCodeCoverage node:internal/process/pre_execution:331:27,0x1d7bd0eeebe0,~
code-source-info,0x3a1b5d315530,67,9968,10463,C0O10274C3O10286C8O10290C16O10317C22O10317C28O10371C31O10379C38O10408C44O10435C49O10439C54O10408C58O10400C63O10462,,
code-creation,LazyCompile,10,30864,0x3a1b5d315710,75,setupDebugEnv node:internal/process/pre_execution:377:23,0x1d7bd0eeed48,~
code-source-info,0x3a1b5d315710,67,11359,11568,C0O11366C6O11366C11O11399C19O11427C24O11431C29O11400C34O11446C42O11450C48O11494C54O11494C59O11529C64O11543C69O11544C74O11567,,
code-creation,LazyCompile,10,30915,0x3a1b5d315a90,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x28d42e2a6ae0,~
script-source,28,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nlet utilColors;\nfunction lazyUtilColors() {\n  utilColors ??= require('internal/util/colors');\n  return utilColors;\n}\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = lazyUtilColors().shouldColorize(process.stderr);\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    __proto__: null\x2C\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\x2C\n};\n
code-source-info,0x3a1b5d315a90,28,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,31088,0x3a1b5d316138,31,initializeReport node:internal/process/pre_execution:365:26,0x1d7bd0eeecd0,~
code-source-info,0x3a1b5d316138,67,11111,11335,C0O11118C11O11139C16O11231C24O11118C30O11334,,
code-creation,LazyCompile,10,31114,0x3a1b5d3162f8,35,initializeSourceMapsHandlers node:internal/process/pre_execution:604:38,0x1d7bd0eef130,~
code-source-info,0x3a1b5d3162f8,67,18877,19038,C0O18924C6O18924C11O18896C16O18975C18O18996C24O18996C29O18975C34O19037,,
code-creation,LazyCompile,10,31160,0x3a1b5d316530,94,setSourceMapsEnabled node:internal/source_map/source_map_cache:60:30,0x32bbd7472778,~
script-source,44,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolSplit\x2C\n  SafeMap\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\n\nconst { validateBoolean } = require('internal/validators');\nconst {\n  setSourceMapsEnabled: setSourceMapsNative\x2C\n  setPrepareStackTraceCallback\x2C\n} = internalBinding('errors');\nconst { getLazy } = require('internal/util');\n\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst getCjsSourceMapCache = getLazy(() => {\n  const { IterableWeakMap } = require('internal/util/iterable_weak_map');\n  return new IterableWeakMap();\n});\n\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\n// The generated sources is not mutable\x2C so we can use a Map without memory concerns:\nconst generatedSourceMapCache = new SafeMap();\nconst kLeadingProtocol = /^\\w+:\\/\\//;\nconst kSourceMappingURLMagicComment = /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/g;\nconst kSourceURLMagicComment = /\\/[*/]#\\s+sourceURL=(?<sourceURL>[^\\s]+)/g;\n\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\n\nlet SourceMap;\n\n// This is configured with --enable-source-maps during pre-execution.\nlet sourceMapsEnabled = false;\nfunction getSourceMapsEnabled() {\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  setSourceMapsNative(val);\n  if (val) {\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction extractSourceURLMagicComment(content) {\n  let match;\n  let matchSourceURL;\n  // A while loop is used here to get the last occurrence of sourceURL.\n  // This is needed so that we don't match sourceURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceURLMagicComment\x2C content))) {\n    matchSourceURL = match;\n  }\n  if (matchSourceURL == null) {\n    return null;\n  }\n  let sourceURL = matchSourceURL.groups.sourceURL;\n  if (sourceURL != null && RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  return sourceURL;\n}\n\nfunction extractSourceMapURLMagicComment(content) {\n  let match;\n  let lastMatch;\n  // A while loop is used here to get the last occurrence of sourceMappingURL.\n  // This is needed so that we don't match sourceMappingURL in string literals.\n  while ((match = RegExpPrototypeExec(kSourceMappingURLMagicComment\x2C content))) {\n    lastMatch = match;\n  }\n  if (lastMatch == null) {\n    return null;\n  }\n  return lastMatch.groups.sourceMappingURL;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance\x2C isGeneratedSource\x2C sourceURL\x2C sourceMapURL) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    const { normalizeReferrerURL } = require('internal/modules/helpers');\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an invalid filename in sourceURL of [eval]-wrapper.\n    debug(err);\n    return;\n  }\n\n  if (sourceMapURL === undefined) {\n    sourceMapURL = extractSourceMapURLMagicComment(content);\n  }\n\n  // Bail out when there is no source map url.\n  if (typeof sourceMapURL !== 'string') {\n    return;\n  }\n\n  if (sourceURL === undefined) {\n    sourceURL = extractSourceURLMagicComment(content);\n  }\n\n  const data = dataFromUrl(filename\x2C sourceMapURL);\n  const url = data ? null : sourceMapURL;\n  if (cjsModuleInstance) {\n    getCjsSourceMapCache().set(cjsModuleInstance\x2C {\n      filename\x2C\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    });\n  } else if (isGeneratedSource) {\n    const entry = {\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    generatedSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      generatedSourceMapCache.set(sourceURL\x2C entry);\n    }\n  } else {\n    // If there is no cjsModuleInstance and is not generated source assume we are in a\n    // "modules/esm" context.\n    const entry = {\n      lineLengths: lineLengths(content)\x2C\n      data\x2C\n      url\x2C\n      sourceURL\x2C\n    };\n    esmSourceMapCache.set(filename\x2C entry);\n    if (sourceURL) {\n      esmSourceMapCache.set(sourceURL\x2C entry);\n    }\n  }\n}\n\nfunction maybeCacheGeneratedSourceMap(content) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n\n  const sourceURL = extractSourceURLMagicComment(content);\n  if (sourceURL === null) {\n    return;\n  }\n  try {\n    maybeCacheSourceMap(sourceURL\x2C content\x2C null\x2C true\x2C sourceURL);\n  } catch (err) {\n    // This can happen if the filename is not a valid URL.\n    // If we fail to cache the source map\x2C we should not fail the whole process.\n    debug(err);\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(RegExpPrototypeSymbolSplit(/\\n|\\u2028|\\u2029/\x2C content)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const fs = require('fs');\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of getCjsSourceMapCache()) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\x2C\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL) ?? generatedSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of getCjsSourceMapCache()) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      const cachedSourceURL = ObjectGetValueSafe(value\x2C 'sourceURL');\n      if (sourceURL === filename || sourceURL === cachedSourceURL) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\x2C\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  maybeCacheGeneratedSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x3a1b5d316530,44,1953,2466,C0O1963C8O1963C13O1995C18O1995C22O2023C26O2079C32O2079C37O2052C42O2135C47O2135C53O2193C59O2352C65O2352C70O2325C75O2384C80O2384C84O2440C86O2458C93O2465,,
code-creation,LazyCompile,10,31462,0x3a1b5d317120,30,validateBoolean node:internal/validators:216:25,0x23f41f7bc0a8,~
script-source,20,node:internal/validators,/* eslint jsdoc/require-jsdoc: "error" */\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg\x2C value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateUint32(value\x2C name);\n  return value;\n}\n\n/**\n * @callback validateInteger\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInteger} */\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\x2C\n);\n\n/**\n * @callback validateInt32\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateInt32} */\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\x2C\n);\n\n/**\n * @callback validateUint32\n * @param {*} value\n * @param {string} name\n * @param {number|boolean} [positive=false]\n * @returns {asserts value is number}\n */\n\n/** @type {validateUint32} */\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive = false) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n});\n\n/**\n * @callback validateString\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string}\n */\n\n/** @type {validateString} */\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\n/**\n * @callback validateNumber\n * @param {*} value\n * @param {string} name\n * @param {number} [min]\n * @param {number} [max]\n * @returns {asserts value is number}\n */\n\n/** @type {validateNumber} */\nfunction validateNumber(value\x2C name\x2C min = undefined\x2C max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n      ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name\x2C\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`\x2C\n      value);\n  }\n}\n\n/**\n * @callback validateOneOf\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} oneOf\n */\n\n/** @type {validateOneOf} */\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateBoolean\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean}\n */\n\n/** @type {validateBoolean} */\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {any} options\n * @param {string} key\n * @param {boolean} defaultValue\n * @returns {boolean}\n */\nfunction getOwnPropertyValueOrDefault(options\x2C key\x2C defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options\x2C key) ?\n    defaultValue :\n    options[key];\n}\n\n/**\n * @callback validateObject\n * @param {*} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\n\n/** @type {validateObject} */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options = null) => {\n    const allowArray = getOwnPropertyValueOrDefault(options\x2C 'allowArray'\x2C false);\n    const allowFunction = getOwnPropertyValueOrDefault(options\x2C 'allowFunction'\x2C false);\n    const nullable = getOwnPropertyValueOrDefault(options\x2C 'nullable'\x2C false);\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\n/**\n * @callback validateDictionary - We are using the Web IDL Standard definition\n *                                of "dictionary" here\x2C which means any value\n *                                whose Type is either Undefined\x2C Null\x2C or\n *                                Object (which includes functions).\n * @param {*} value\n * @param {string} name\n * @see https://webidl.spec.whatwg.org/#es-dictionary\n * @see https://tc39.es/ecma262/#table-typeof-operator-results\n */\n\n/** @type {validateDictionary} */\nconst validateDictionary = hideStackFrames(\n  (value\x2C name) => {\n    if (value != null && typeof value !== 'object' && typeof value !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'a dictionary'\x2C value);\n    }\n  });\n\n/**\n * @callback validateArray\n * @param {*} value\n * @param {string} name\n * @param {number} [minLength]\n * @returns {asserts value is any[]}\n */\n\n/** @type {validateArray} */\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\n/**\n * @callback validateStringArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is string[]}\n */\n\n/** @type {validateStringArray} */\nfunction validateStringArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    validateString(value[i]\x2C `${name}[${i}]`);\n  }\n}\n\n/**\n * @callback validateBooleanArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is boolean[]}\n */\n\n/** @type {validateBooleanArray} */\nfunction validateBooleanArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    validateBoolean(value[i]\x2C `${name}[${i}]`);\n  }\n}\n\n/**\n * @callback validateAbortSignalArray\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is AbortSignal[]}\n */\n\n/** @type {validateAbortSignalArray} */\nfunction validateAbortSignalArray(value\x2C name) {\n  validateArray(value\x2C name);\n  for (let i = 0; i < value.length; i++) {\n    const signal = value[i];\n    const indexedName = `${name}[${i}]`;\n    if (signal == null) {\n      throw new ERR_INVALID_ARG_TYPE(indexedName\x2C 'AbortSignal'\x2C signal);\n    }\n    validateAbortSignal(signal\x2C indexedName);\n  }\n}\n\n/**\n * @param {*} signal\n * @param {string} [name='signal']\n * @returns {asserts signal is keyof signals}\n */\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\n/**\n * @callback validateBuffer\n * @param {*} buffer\n * @param {string} [name='buffer']\n * @returns {asserts buffer is ArrayBufferView}\n */\n\n/** @type {validateBuffer} */\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\n/**\n * @param {string} data\n * @param {string} encoding\n */\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n/**\n * Check that the port number is not NaN when coerced to a number\x2C\n * is an integer and that it falls within the legal range of port numbers.\n * @param {*} port\n * @param {string} [name='Port']\n * @param {boolean} [allowZero=true]\n * @returns {number}\n */\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\n/**\n * @callback validateAbortSignal\n * @param {*} signal\n * @param {string} name\n */\n\n/** @type {validateAbortSignal} */\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\n/**\n * @callback validateFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validateFunction} */\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validatePlainFunction\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is Function}\n */\n\n/** @type {validatePlainFunction} */\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\n/**\n * @callback validateUndefined\n * @param {*} value\n * @param {string} name\n * @returns {asserts value is undefined}\n */\n\n/** @type {validateUndefined} */\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\n/**\n * @template T\n * @param {T} value\n * @param {string} name\n * @param {T[]} union\n */\nfunction validateUnion(value\x2C name\x2C union) {\n  if (!ArrayPrototypeIncludes(union\x2C value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C `('${ArrayPrototypeJoin(union\x2C '|')}')`\x2C value);\n  }\n}\n\n/*\n  The rules for the Link header field are described here:\n  https://www.rfc-editor.org/rfc/rfc8288.html#section-3\n\n  This regex validates any string surrounded by angle brackets\n  (not necessarily a valid URI reference) followed by zero or more\n  link-params separated by semicolons.\n*/\nconst linkValueRegExp = /^(?:<[^>]*>)(?:\\s*;\\s*[^;"\\s]+(?:=(")?[^;"\\s]*\\1)?)*$/;\n\n/**\n * @param {any} value\n * @param {string} name\n */\nfunction validateLinkHeaderFormat(value\x2C name) {\n  if (\n    typeof value === 'undefined' ||\n    !RegExpPrototypeExec(linkValueRegExp\x2C value)\n  ) {\n    throw new ERR_INVALID_ARG_VALUE(\n      name\x2C\n      value\x2C\n      'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n    );\n  }\n}\n\n/**\n * @param {any} hints\n * @return {string}\n */\nfunction validateLinkHeaderValue(hints) {\n  if (typeof hints === 'string') {\n    validateLinkHeaderFormat(hints\x2C 'hints');\n    return hints;\n  } else if (ArrayIsArray(hints)) {\n    const hintsLength = hints.length;\n    let result = '';\n\n    if (hintsLength === 0) {\n      return result;\n    }\n\n    for (let i = 0; i < hintsLength; i++) {\n      const link = hints[i];\n      validateLinkHeaderFormat(link\x2C 'hints');\n      result += link;\n\n      if (i !== hintsLength - 1) {\n        result += '\x2C ';\n      }\n    }\n\n    return result;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(\n    'hints'\x2C\n    hints\x2C\n    'must be an array or string of format "</styles.css>; rel=preload; as=style"'\x2C\n  );\n}\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateStringArray\x2C\n  validateBooleanArray\x2C\n  validateAbortSignalArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateDictionary\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateUnion\x2C\n  validateAbortSignal\x2C\n  validateLinkHeaderValue\x2C\n};\n
code-source-info,0x3a1b5d317120,20,5597,5708,C0O5615C6O5651C22O5657C27O5651C29O5707,,
tick,0x7f6e65373f79,31911,0,0x0,3,0x12da7b0,0x3a1b5d316538,0x3a1b5d316315,0x3a1b5d30707c,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,31968,0x3a1b5d318910,358,initializeDeprecations node:internal/process/pre_execution:443:32,0x1d7bd0eeef50,~
code-source-info,0x3a1b5d318910,67,13557,15478,C0O13586C6O13586C11O13572C16O13641C24O13641C29O13832C35O13832C40O13873C46O13873C51O13926C80O13918C108O13918C111O14244C122O14264C126O14306C137O14380C148O14470C159O14425C168O14291C177O14529C180O14262C184O13907C249O14806C255O14806C260O14785C265O14835C267O14863C278O14884C285O15025C289O14863C294O15058C298O15088C304O15124C314O15201C321O15106C326O15104C330O15287C336O15329C347O15311C352O15309C357O15477,,
code-creation,LazyCompile,10,32032,0x3a1b5d318d00,72,initializeDns node:internal/dns/utils:203:23,0x1d7bd0ef81b8,~
script-source,71,node:internal/dns/utils,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  ObjectCreate\x2C\n  Symbol\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst { isIP } = require('internal/net');\nconst { getOptionValue } = require('internal/options');\nconst {\n  validateArray\x2C\n  validateInt32\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nlet binding;\nfunction lazyBinding() {\n  binding ??= internalBinding('cares_wrap');\n  return binding;\n}\nconst IANA_DNS_PORT = 53;\nconst IPv6RE = /^\\[([^[\\]]*)\\]/;\nconst addrSplitRE = /(^.+?)(?::(\\d+))?$/;\nconst {\n  ERR_DNS_SET_SERVERS_FAILED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_IP_ADDRESS\x2C\n} = errors.codes;\n\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    addDeserializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n\nfunction validateTimeout(options) {\n  const { timeout = -1 } = { ...options };\n  validateInt32(timeout\x2C 'options.timeout'\x2C -1);\n  return timeout;\n}\n\nfunction validateTries(options) {\n  const { tries = 4 } = { ...options };\n  validateInt32(tries\x2C 'options.tries'\x2C 1);\n  return tries;\n}\n\nconst kSerializeResolver = Symbol('dns:resolver:serialize');\nconst kDeserializeResolver = Symbol('dns:resolver:deserialize');\nconst kSnapshotStates = Symbol('dns:resolver:config');\nconst kInitializeHandle = Symbol('dns:resolver:initializeHandle');\nconst kSetServersInteral = Symbol('dns:resolver:setServers');\n\n// Resolver instances correspond 1:1 to c-ares channels.\n\nclass ResolverBase {\n  constructor(options = undefined) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    // If we are building snapshot\x2C save the states of the resolver along\n    // the way.\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates] = { timeout\x2C tries };\n    }\n    this[kInitializeHandle](timeout\x2C tries);\n  }\n\n  [kInitializeHandle](timeout\x2C tries) {\n    const { ChannelWrap } = lazyBinding();\n    this._handle = new ChannelWrap(timeout\x2C tries);\n  }\n\n  cancel() {\n    this._handle.cancel();\n  }\n\n  getServers() {\n    return ArrayPrototypeMap(this._handle.getServers() || []\x2C (val) => {\n      if (!val[1] || val[1] === IANA_DNS_PORT)\n        return val[0];\n\n      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n      return `${host}:${val[1]}`;\n    });\n  }\n\n  setServers(servers) {\n    validateArray(servers\x2C 'servers');\n\n    // Cache the original servers because in the event of an error while\n    // setting the servers\x2C c-ares won't have any servers available for\n    // resolution.\n    const newSet = [];\n    ArrayPrototypeForEach(servers\x2C (serv\x2C index) => {\n      validateString(serv\x2C `servers[${index}]`);\n      let ipVersion = isIP(serv);\n\n      if (ipVersion !== 0)\n        return ArrayPrototypePush(newSet\x2C [ipVersion\x2C serv\x2C IANA_DNS_PORT]);\n\n      const match = RegExpPrototypeExec(IPv6RE\x2C serv);\n\n      // Check for an IPv6 in brackets.\n      if (match) {\n        ipVersion = isIP(match[1]);\n\n        if (ipVersion !== 0) {\n          const port = NumberParseInt(\n            RegExpPrototypeSymbolReplace(addrSplitRE\x2C serv\x2C '$2')) || IANA_DNS_PORT;\n          return ArrayPrototypePush(newSet\x2C [ipVersion\x2C match[1]\x2C port]);\n        }\n      }\n\n      // addr::port\n      const addrSplitMatch = RegExpPrototypeExec(addrSplitRE\x2C serv);\n\n      if (addrSplitMatch) {\n        const hostIP = addrSplitMatch[1];\n        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n\n        ipVersion = isIP(hostIP);\n\n        if (ipVersion !== 0) {\n          return ArrayPrototypePush(\n            newSet\x2C [ipVersion\x2C hostIP\x2C NumberParseInt(port)]);\n        }\n      }\n\n      throw new ERR_INVALID_IP_ADDRESS(serv);\n    });\n\n    this[kSetServersInteral](newSet\x2C servers);\n  }\n\n  [kSetServersInteral](newSet\x2C servers) {\n    const orig = this._handle.getServers() || [];\n    const errorNumber = this._handle.setServers(newSet);\n\n    if (errorNumber !== 0) {\n      // Reset the servers to the old servers\x2C because ares probably unset them.\n      this._handle.setServers(ArrayPrototypeJoin(orig\x2C '\x2C'));\n      const { strerror } = lazyBinding();\n      const err = strerror(errorNumber);\n      throw new ERR_DNS_SET_SERVERS_FAILED(err\x2C servers);\n    }\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].servers = newSet;\n    }\n  }\n\n\n  setLocalAddress(ipv4\x2C ipv6) {\n    validateString(ipv4\x2C 'ipv4');\n\n    if (ipv6 !== undefined) {\n      validateString(ipv6\x2C 'ipv6');\n    }\n\n    this._handle.setLocalAddress(ipv4\x2C ipv6);\n\n    if (isBuildingSnapshot()) {\n      this[kSnapshotStates].localAddress = { ipv4\x2C ipv6 };\n    }\n  }\n\n  // TODO(joyeecheung): consider exposing this if custom DNS resolvers\n  // end up being useful for snapshot users.\n  [kSerializeResolver]() {\n    this._handle = null;  // We'll restore it during deserialization.\n    addDeserializeCallback(function deserializeResolver(resolver) {\n      resolver[kDeserializeResolver]();\n    }\x2C this);\n  }\n\n  [kDeserializeResolver]() {\n    const { timeout\x2C tries\x2C localAddress\x2C servers } = this[kSnapshotStates];\n    this[kInitializeHandle](timeout\x2C tries);\n    if (localAddress) {\n      const { ipv4\x2C ipv6 } = localAddress;\n      this._handle.setLocalAddress(ipv4\x2C ipv6);\n    }\n    if (servers) {\n      this[kSetServersInteral](servers\x2C servers);\n    }\n  }\n}\n\nlet defaultResolver;\nlet dnsOrder;\n\nfunction initializeDns() {\n  const orderFromCLI = getOptionValue('--dns-result-order');\n  if (!orderFromCLI) {\n    dnsOrder ??= 'verbatim';\n  } else {\n    // Allow the deserialized application to override order from CLI.\n    dnsOrder = orderFromCLI;\n  }\n\n  if (!isBuildingSnapshot()) {\n    return;\n  }\n\n  addSerializeCallback(() => {\n    defaultResolver?.[kSerializeResolver]();\n  });\n}\n\nconst resolverKeys = [\n  'getServers'\x2C\n  'resolve'\x2C\n  'resolve4'\x2C\n  'resolve6'\x2C\n  'resolveAny'\x2C\n  'resolveCaa'\x2C\n  'resolveCname'\x2C\n  'resolveMx'\x2C\n  'resolveNaptr'\x2C\n  'resolveNs'\x2C\n  'resolvePtr'\x2C\n  'resolveSoa'\x2C\n  'resolveSrv'\x2C\n  'resolveTxt'\x2C\n  'reverse'\x2C\n];\n\nfunction getDefaultResolver() {\n  // We do this here instead of pre-execution so that the default resolver is\n  // only ever created when the user loads any dns module.\n  if (defaultResolver === undefined) {\n    defaultResolver = new ResolverBase();\n  }\n  return defaultResolver;\n}\n\nfunction setDefaultResolver(resolver) {\n  defaultResolver = resolver;\n}\n\nfunction bindDefaultResolver(target\x2C source) {\n  const defaultResolver = getDefaultResolver();\n  ArrayPrototypeForEach(resolverKeys\x2C (key) => {\n    target[key] = FunctionPrototypeBind(source[key]\x2C defaultResolver);\n  });\n}\n\nfunction validateHints(hints) {\n  const { AI_ADDRCONFIG\x2C AI_ALL\x2C AI_V4MAPPED } = lazyBinding();\n  if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('hints'\x2C hints);\n  }\n}\n\nlet invalidHostnameWarningEmitted = false;\nfunction emitInvalidHostnameWarning(hostname) {\n  if (!invalidHostnameWarningEmitted) {\n    process.emitWarning(\n      `The provided hostname "${hostname}" is not a valid ` +\n      'hostname\x2C and is supported in the dns module solely for compatibility.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0118'\x2C\n    );\n    invalidHostnameWarningEmitted = true;\n  }\n}\n\nfunction getDefaultVerbatim() {\n  return dnsOrder !== 'ipv4first';\n}\n\nfunction setDefaultResultOrder(value) {\n  validateOneOf(value\x2C 'dnsOrder'\x2C ['verbatim'\x2C 'ipv4first']);\n  dnsOrder = value;\n}\n\nfunction getDefaultResultOrder() {\n  return dnsOrder;\n}\n\nfunction createResolverClass(resolver) {\n  const resolveMap = ObjectCreate(null);\n\n  class Resolver extends ResolverBase {}\n\n  Resolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\n  Resolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\n  Resolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\n  Resolver.prototype.resolveCaa = resolveMap.CAA = resolver('queryCaa');\n  Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\n  Resolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\n  Resolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\n  Resolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\n  Resolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\n  Resolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\n  Resolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\n  Resolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\n  Resolver.prototype.reverse = resolver('getHostByAddr');\n\n  return {\n    resolveMap\x2C\n    Resolver\x2C\n  };\n}\n\n// ERROR CODES\nconst errorCodes = {\n  NODATA: 'ENODATA'\x2C\n  FORMERR: 'EFORMERR'\x2C\n  SERVFAIL: 'ESERVFAIL'\x2C\n  NOTFOUND: 'ENOTFOUND'\x2C\n  NOTIMP: 'ENOTIMP'\x2C\n  REFUSED: 'EREFUSED'\x2C\n  BADQUERY: 'EBADQUERY'\x2C\n  BADNAME: 'EBADNAME'\x2C\n  BADFAMILY: 'EBADFAMILY'\x2C\n  BADRESP: 'EBADRESP'\x2C\n  CONNREFUSED: 'ECONNREFUSED'\x2C\n  TIMEOUT: 'ETIMEOUT'\x2C\n  EOF: 'EOF'\x2C\n  FILE: 'EFILE'\x2C\n  NOMEM: 'ENOMEM'\x2C\n  DESTRUCTION: 'EDESTRUCTION'\x2C\n  BADSTR: 'EBADSTR'\x2C\n  BADFLAGS: 'EBADFLAGS'\x2C\n  NONAME: 'ENONAME'\x2C\n  BADHINTS: 'EBADHINTS'\x2C\n  NOTINITIALIZED: 'ENOTINITIALIZED'\x2C\n  LOADIPHLPAPI: 'ELOADIPHLPAPI'\x2C\n  ADDRGETNETWORKPARAMS: 'EADDRGETNETWORKPARAMS'\x2C\n  CANCELLED: 'ECANCELLED'\x2C\n};\n\nmodule.exports = {\n  bindDefaultResolver\x2C\n  getDefaultResolver\x2C\n  setDefaultResolver\x2C\n  validateHints\x2C\n  validateTimeout\x2C\n  validateTries\x2C\n  emitInvalidHostnameWarning\x2C\n  getDefaultVerbatim\x2C\n  getDefaultResultOrder\x2C\n  setDefaultResultOrder\x2C\n  errorCodes\x2C\n  createResolverClass\x2C\n  initializeDns\x2C\n};\n
code-source-info,0x3a1b5d318d00,71,5465,5829,C0O5493C8O5493C13O5533C15O5558C28O5567C36O5668C38O5677C44O5700C49O5705C54O5733C55O5740C56O5748C66O5748C71O5828,,
code-creation,LazyCompile,10,32313,0x3a1b5d319ae0,90,setupSymbolDisposePolyfill node:internal/process/pre_execution:120:36,0x1d7bd0eee900,~
code-source-info,0x3a1b5d319ae0,67,3333,4033,C0O3503C5O3521C13O3549C20O3570C33O3679C39O3549C44O3791C49O3809C57O3842C64O3863C77O3977C83O3842C89O4032,,
code-creation,LazyCompile,10,32349,0x3a1b5d319c20,21,assert node:internal/assert:11:16,0x28d42e2a5aa8,~
script-source,27,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x3a1b5d319c20,27,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,32434,0x3a1b5d31a1b8,431,readPolicyFromDisk node:internal/process/pre_execution:532:28,0x1d7bd0eef040,~
code-source-info,0x3a1b5d31a1b8,67,16346,18138,C0O16380C10O16380C15O16423C17O16453C21O16461C35O16461C41O16586C49O16586C55O16563C60O16578C65O16705C67O16722C75O16726C81O16741C87O16742C94O16796C101O16865C105O16887C111O16887C117O16865C123O16901C134O16917C138O16931C146O16945C152O17003C160O17003C165O17037C175O17037C182O17112C192O17112C197O17154C199O17207C207O17207C212O17285C220O17285C226O17253C231O17265C236O17334C242O17334C248O17384C254O17384C260O17443C262O17469C264O17493C268O17474C273O17584C275O17600C280O17534C285O17562C290O17626C296O17662C302O17662C307O17703C313O17703C319O17732C325O17752C329O17739C334O17772C341O17819C343O17848C345O17889C351O17911C361O17911C368O17889C374O17502C379O17456C382O17946C386O17973C400O17979C405O17973C406O18062C414O18090C418O18120C428O18132C430O18137,,
code-creation,LazyCompile,10,32468,0x3a1b5d31a5c8,49,setupStacktracePrinterOnSigint node:internal/process/pre_execution:355:40,0x1d7bd0eeec80,~
code-source-info,0x3a1b5d31a5c8,67,10898,11084,C0O10905C8O10910C14O10950C15O10957C16O10991C22O10991C27O10972C32O11041C38O11074C43O11074C48O11083,,
code-creation,LazyCompile,10,32488,0x3a1b5d31a770,35,initializeReportSignalHandlers node:internal/process/pre_execution:385:40,0x1d7bd0eeed98,~
code-source-info,0x3a1b5d31a770,67,11669,11818,C0O11676C8O11680C14O11753C20O11753C25O11732C30O11793C34O11817,,
code-creation,LazyCompile,10,32518,0x3a1b5d31aa18,136,initializeHeapSnapshotSignalHandlers node:internal/process/pre_execution:392:46,0x1d7bd0eeede8,~
code-source-info,0x3a1b5d31aa18,67,11865,12401,C0O11865C17O11887C27O11887C31O11887C33O11931C37O11948C38O11955C39O11959C47O11959C52O11989C60O11990C65O12050C73O12050C78O12028C84O12132C89O12140C100O12140C106O12268C113O12272C118O12300C130O12300C135O12400,,
code-creation,LazyCompile,10,32551,0x3a1b5d31ad40,138,setupChildProcessIpcChannel node:internal/process/pre_execution:504:37,0x1d7bd0eeefa0,~
code-source-info,0x3a1b5d31ad40,67,15516,16045,C0O15523C3O15535C8O15539C14O15577C20O15577C25O15621C33O15644C38O15648C46O15621C52O15674C53O15684C57O15674C61O15765C64O15780C73O15838C76O15846C81O15850C90O15897C93O15912C102O15954C108O15954C113O15978C118O15979C124O16018C127O16033C132O16018C137O16044,,
code-creation,LazyCompile,10,32581,0x3a1b5d31af68,63,initializeClusterIPC node:internal/process/pre_execution:523:30,0x1d7bd0eeeff0,~
code-source-info,0x3a1b5d31af68,67,16076,16317,C0O16083C3O16095C10O16099C18O16114C23O16118C29O16156C35O16156C40O16188C45O16188C49O16277C52O16292C62O16316,,
code-creation,LazyCompile,10,32609,0x3a1b5d31b0c0,53,runDeserializeCallbacks node:internal/v8/startup_snapshot:32:33,0x13800b15f758,~
code-source-info,0x3a1b5d31b0c0,57,757,898,C0O799C5O792C11O799C16O843C21O864C26O864C31O821C37O834C44O877C48O764C52O897,,
code-creation,LazyCompile,10,32635,0x3a1b5d31b218,69,setupUserModules node:internal/process/pre_execution:145:26,0x1d7bd0eee950,~
code-source-info,0x3a1b5d31b218,67,4060,4463,C10O4089C13O4089C16O4114C19O4114C23O4171C29O4171C34O4213C39O4231C45O4213C49O4324C53O4350C54O4357C55O4364C58O4364C61O4432C64O4432C68O4462,,
code-creation,LazyCompile,10,32653,0x3a1b5d31b368,21,initializeCJSLoader node:internal/process/pre_execution:582:29,0x1d7bd0eef090,~
code-source-info,0x3a1b5d31b368,67,18168,18261,C0O18201C6O18201C11O18183C16O18243C20O18260,,
tick,0x11f8230,32735,0,0x0,3,0x12da7b0,0x3a1b5d31b378,0x3a1b5d31b225,0x3a1b5d307147,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,32820,0x3a1b5d31b4f0,90,initializeCJS node:internal/modules/cjs/loader:382:23,0x1d7bd0ee1670,~
script-source,63,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  Symbol\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\x2C\n  initializeCJS\x2C\n};\n\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURL } = require('internal/url');\nconst {\n  pendingDeprecate\x2C\n  emitExperimentalWarning\x2C\n  kEmptyObject\x2C\n  setOwnProperty\x2C\n  getLazy\x2C\n} = require('internal/util');\nconst {\n  internalCompileFunction\x2C\n  makeContextifyScript\x2C\n  runScriptInThisContext\x2C\n} = require('internal/vm');\n\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst path = require('path');\nconst { internalModuleStat } = internalBinding('fs');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\nconst {\n  getCjsConditions\x2C\n  initializeCjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n  toRealPath\x2C\n} = require('internal/modules/helpers');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { getOptionValue\x2C getEmbedderOptions } = require('internal/options');\nconst policy = getLazy(\n  () => (getOptionValue('--experimental-policy') ? require('internal/process/policy') : null)\x2C\n);\nconst shouldReportRequiredModules = getLazy(() => process.env.WATCH_REPORT_DEPENDENCIES);\n\nconst getCascadedLoader = getLazy(\n  () => require('internal/process/esm_loader').esmLoader\x2C\n);\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\n\nconst {\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n} = require('internal/constants');\n\nconst {\n  isProxy\x2C\n} = require('internal/util/types');\n\nconst { kEvaluated } = internalBinding('module_wrap');\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet isPreloading = false;\nlet statCache = null;\n\n/**\n * Our internal implementation of `require`.\n * @param {Module} module Parent module of what is being required\n * @param {string} id Specifier of the child module being imported\n */\nfunction internalRequire(module\x2C id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C module\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n}\n\n/**\n * Get a path's properties\x2C using an in-memory cache to minimize lookups.\n * @param {string} filename Absolute path to the file\n */\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) { return result; }\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nlet _stat = stat;\nObjectDefineProperty(Module\x2C '_stat'\x2C {\n  __proto__: null\x2C\n  get() { return _stat; }\x2C\n  set(stat) {\n    emitExperimentalWarning('Module._stat');\n    _stat = stat;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\n/**\n * Update the parent's children array with the child module.\n * @param {Module} parent Module requiring the children\n * @param {Module} child Module being required\n * @param {boolean} scan Add the child to the parent's children if not already present\n */\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child))) {\n    ArrayPrototypePush(children\x2C child);\n  }\n}\n\n/**\n * Tell the watch mode that a module was required.\n * @param {string} filename Absolute path of the module\n */\nfunction reportModuleToWatchMode(filename) {\n  if (shouldReportRequiredModules() && process.send) {\n    process.send({ 'watch:require': [filename] });\n  }\n}\n\n/**\n * Tell the watch mode that a module was not found.\n * @param {string} basePath The absolute path that errored\n * @param {string[]} extensions The extensions that were tried\n */\nfunction reportModuleNotFoundToWatchMode(basePath\x2C extensions) {\n  if (shouldReportRequiredModules() && process.send) {\n    process.send({ 'watch:require': ArrayPrototypeMap(extensions\x2C (ext) => path.resolve(`${basePath}${ext}`)) });\n  }\n}\n\n/** @type {Map<Module\x2C Module>} */\nconst moduleParentCache = new SafeWeakMap();\n/**\n * Create a new module instance.\n * @param {string} id\n * @param {Module} parent\n */\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  setOwnProperty(this\x2C 'exports'\x2C {});\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n  let redirects;\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const moduleURL = pathToFileURL(id);\n    redirects = manifest.getDependencyMapper(moduleURL);\n    // TODO(rafaelgss): remove the necessity of this branch\n    setOwnProperty(this\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n    // eslint-disable-next-line no-proto\n    setOwnProperty(this.__proto__\x2C 'require'\x2C makeRequireFunction(this\x2C redirects));\n  }\n  this[require_private_symbol] = internalRequire;\n}\n\n/** @type {Record<string\x2C Module>} */\nModule._cache = { __proto__: null };\n/** @type {Record<string\x2C string>} */\nModule._pathCache = { __proto__: null };\n/** @type {Record<string\x2C (module: Module\x2C filename: string) => void>} */\nModule._extensions = { __proto__: null };\n/** @type {string[]} */\nlet modulePaths = [];\n/** @type {string[]} */\nModule.globalPaths = [];\n\nlet patched = false;\n\n/**\n * Add the CommonJS wrapper around a module's source code.\n * @param {string} script Module source code\n */\nlet wrap = function(script) { // eslint-disable-line func-style\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  __proto__: null\x2C\n\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\x2C\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\x2C\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(BuiltinModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\n/**\n * Get the parent of the current module from our cache.\n */\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\n/**\n * Set the parent of the current module in our cache.\n * @param {Module} value\n */\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  get: pendingDeprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  )\x2C\n  set: pendingDeprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\x2C\n  )\x2C\n});\nModule._debug = pendingDeprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\nModule.isBuiltin = BuiltinModule.isBuiltin;\n\n/**\n * Prepare to run CommonJS code.\n * This function is called during pre-execution\x2C before any user code is run.\n */\nfunction initializeCJS() {\n  // This need to be done at runtime in case --expose-internals is set.\n  const builtinModules = BuiltinModule.getCanBeRequiredByUsersWithoutSchemeList();\n  Module.builtinModules = ObjectFreeze(builtinModules);\n\n  initializeCjsConditions();\n\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    Module._initPaths();\n  }\n\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nlet _readPackage = packageJsonReader.readPackage;\nObjectDefineProperty(Module\x2C '_readPackage'\x2C {\n  __proto__: null\x2C\n  get() { return _readPackage; }\x2C\n  set(readPackage) {\n    emitExperimentalWarning('Module._readPackage');\n    _readPackage = readPackage;\n    return true;\n  }\x2C\n  configurable: true\x2C\n});\n\n/**\n * Try to load a specifier as a package.\n * @param {string} requestPath The path to what we are trying to load\n * @param {string[]} exts File extensions to try appending in order to resolve the file\n * @param {boolean} isMain Whether the file is the main entry point of the app\n * @param {string} originalPath The specifier passed to `require`\n */\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = _readPackage(requestPath).main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\x2C\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\x2C\n      );\n    }\n  }\n  return actual;\n}\n\n/**\n * Check if the file exists and is not a directory if using `--preserve-symlinks` and `isMain` is false\x2C keep symlinks\n * intact\x2C otherwise resolve to the absolute realpath.\n * @param {string} requestPath The path to the file to load.\n * @param {boolean} isMain Whether the file is the main module.\n */\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = _stat(requestPath);\n  if (rc !== 0) { return; }\n  if (getOptionValue('--preserve-symlinks') && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\n/**\n * Given a path\x2C check if the file exists with any of the set extensions.\n * @param {string} basePath The path and filename without extension\n * @param {string[]} exts The extensions to try\n * @param {boolean} isMain Whether the module is the main module\n */\nfunction tryExtensions(basePath\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(basePath + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n/**\n * Find the longest (possibly multi-dot) extension registered in `Module._extensions`.\n * @param {string} filename The filename to find the longest registered extension for.\n */\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) { continue; } // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) { return currentExtension; }\n  }\n  return '.js';\n}\n\n/**\n * Tries to get the absolute file path of the parent module.\n * @param {Module} parent The parent module object.\n */\nfunction trySelfParentPath(parent) {\n  if (!parent) { return false; }\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Attempt to resolve a module request using the parent module package metadata.\n * @param {string} parentPath The path of the parent module\n * @param {string} request The module request to resolve\n */\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) { return false; }\n\n  const { data: pkg\x2C path: pkgPath } = packageJsonReader.readPackageScope(parentPath);\n  if (!pkg || pkg.exports == null || pkg.name === undefined) {\n    return false;\n  }\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    const { packageExportsResolve } = require('internal/modules/esm/resolve');\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C getCjsConditions())\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND') {\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    }\n    throw e;\n  }\n}\n\n/**\n * This only applies to requests of a specific form:\n * 1. `name/.*`\n * 2. `@scope/name/.*`\n */\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\n\n/**\n * Resolves the exports for a given module path and request.\n * @param {string} nmPath The path to the module.\n * @param {string} request The request for the module.\n */\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    RegExpPrototypeExec(EXPORTS_PATTERN\x2C request) || kEmptyObject;\n  if (!name) { return; }\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = _readPackage(pkgPath);\n  if (pkg.exists && pkg.exports != null) {\n    try {\n      const { packageExportsResolve } = require('internal/modules/esm/resolve');\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        getCjsConditions())\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND') {\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      }\n      throw e;\n    }\n  }\n}\n\n/**\n * Get the absolute path to a module.\n * @param {string} request Relative or absolute file path\n * @param {Array<string>} paths Folders to search as file paths\n * @param {boolean} isMain Whether the request is the main app entry point\n * @returns {string | false}\n */\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry) {\n    return entry;\n  }\n\n  let exts;\n  const trailingSlash = request.length > 0 &&\n    (StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_FORWARD_SLASH || (\n      StringPrototypeCharCodeAt(request\x2C request.length - 1) === CHAR_DOT &&\n      (\n        request.length === 1 ||\n        StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_FORWARD_SLASH ||\n        (StringPrototypeCharCodeAt(request\x2C request.length - 2) === CHAR_DOT && (\n          request.length === 2 ||\n          StringPrototypeCharCodeAt(request\x2C request.length - 3) === CHAR_FORWARD_SLASH\n        ))\n      )\n    ));\n\n  const isRelative = StringPrototypeCharCodeAt(request\x2C 0) === CHAR_DOT &&\n    (\n      request.length === 1 ||\n      StringPrototypeCharCodeAt(request\x2C 1) === CHAR_FORWARD_SLASH ||\n      (isWindows && StringPrototypeCharCodeAt(request\x2C 1) === CHAR_BACKWARD_SLASH) ||\n      (StringPrototypeCharCodeAt(request\x2C 1) === CHAR_DOT && ((\n        request.length === 2 ||\n        StringPrototypeCharCodeAt(request\x2C 2) === CHAR_FORWARD_SLASH) ||\n        (isWindows && StringPrototypeCharCodeAt(request\x2C 2) === CHAR_BACKWARD_SLASH)))\n    );\n  let insidePath = true;\n  if (isRelative) {\n    const normalizedRequest = path.normalize(request);\n    if (StringPrototypeStartsWith(normalizedRequest\x2C '..')) {\n      insidePath = false;\n    }\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist and request is inside the path\n    const curPath = paths[i];\n    if (insidePath && curPath && _stat(curPath) < 1) {\n      continue;\n    }\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved) {\n        return exportsResolved;\n      }\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = _stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (getOptionValue('--preserve-symlinks')) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (getOptionValue('--preserve-symlinks-main')) {\n          // For the main module\x2C we use the --preserve-symlinks-main flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the --preserve-symlinks-main option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined) {\n          exts = ObjectKeys(Module._extensions);\n        }\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined) {\n        exts = ObjectKeys(Module._extensions);\n      }\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n\n    const extensions = [''];\n    if (exts !== undefined) {\n      ArrayPrototypePushApply(extensions\x2C exts);\n    }\n    reportModuleNotFoundToWatchMode(basePath\x2C extensions);\n  }\n\n  return false;\n};\n\n/** `node_modules` character codes reversed */\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  /**\n   * Get the paths to the `node_modules` folder for a given path.\n   * @param {string} from `__dirname` of the module\n   */\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON) {\n      return [from + 'node_modules'];\n    }\n\n    /** @type {string[]} */\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen) {\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\x2C\n          );\n        }\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  /**\n   * Get the paths to the `node_modules` folder for a given path.\n   * @param {string} from `__dirname` of the module\n   */\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/') {\n      return ['/node_modules'];\n    }\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    /** @type {string[]} */\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen) {\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\x2C\n          );\n        }\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\n/**\n * Get the paths for module resolution.\n * @param {string} request\n * @param {Module} parent\n */\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (BuiltinModule.normalizeRequirableId(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    /** @type {string[]} */\n    let paths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeSlice(modulePaths);\n      ArrayPrototypeUnshiftApply(paths\x2C parent.paths);\n    } else {\n      paths = modulePaths;\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\n/**\n * Emits a warning when a non-existent property of module exports is accessed inside a circular dependency.\n * @param {string} prop The name of the non-existent property.\n */\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\x2C\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  __proto__: null\x2C\n\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') { return target[prop]; }\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule') {\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    }\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n});\n\n/**\n * Returns the exports object for a module that has a circular `require`.\n * If the exports object is a plain object\x2C it is wrapped in a proxy that warns\n * about circular dependencies.\n * @param {Module} module The module instance\n */\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n/**\n * Load a module from cache if it exists\x2C otherwise create a new module instance.\n * 1. If a module already exists in the cache: return its exports object.\n * 2. If the module is native: call\n *    `BuiltinModule.prototype.compileForPublicLoader()` and return the exports.\n * 3. Otherwise\x2C create a new module for the file and save it to the cache.\n *    Then have it load the file contents before returning its exports object.\n * @param {string} request Specifier of module to load via `require`\n * @param {string} parent Absolute path of the module importing the child\n * @param {boolean} isMain Whether the module is the main entry point\n */\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    reportModuleToWatchMode(filename);\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded) {\n          return getExportsForCircularRequire(cachedModule);\n        }\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(request\x2C 5);\n\n    if (!BuiltinModule.canBeRequiredByUsers(id)) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n\n    const module = loadBuiltinModule(id\x2C request);\n    return module.exports;\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded) {\n        return getExportsForCircularRequire(cachedModule);\n      }\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  if (BuiltinModule.canBeRequiredWithoutScheme(filename)) {\n    const mod = loadBuiltinModule(filename\x2C request);\n    return mod.exports;\n  }\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    setOwnProperty(process\x2C 'mainModule'\x2C module);\n    setOwnProperty(module.require\x2C 'main'\x2C process.mainModule);\n    module.id = '.';\n  }\n\n  reportModuleToWatchMode(filename);\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\n/**\n * Given a `require` string and its context\x2C get its absolute file path.\n * @param {string} request The specifier to resolve\n * @param {Module} parent The module containing the `require` call\n * @param {boolean} isMain Whether the module is the main entry point\n * @param {ResolveFilenameOptions} options Options object\n * @typedef {object} ResolveFilenameOptions\n * @property {string[]} paths Paths to search for modules in\n */\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (BuiltinModule.normalizeRequirableId(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j])) {\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n            }\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (request[0] === '#' && (parent?.filename || parent?.id === '<repl>')) {\n    const parentPath = parent?.filename ?? process.cwd() + path.sep;\n    const pkg = packageJsonReader.readPackageScope(parentPath) || { __proto__: null };\n    if (pkg.data?.imports != null) {\n      try {\n        const { packageImportsResolve } = require('internal/modules/esm/resolve');\n        return finalizeEsmResolution(\n          packageImportsResolve(request\x2C pathToFileURL(parentPath)\x2C\n                                getCjsConditions())\x2C parentPath\x2C\n          pkg.path);\n      } catch (e) {\n        if (e.code === 'ERR_MODULE_NOT_FOUND') {\n          throw createEsmNotFoundErr(request);\n        }\n        throw e;\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain);\n  if (filename) { return filename; }\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\n/**\n * Finishes resolving an ES module specifier into an absolute file path.\n * @param {string} resolved The resolved module specifier\n * @param {string} parentPath The path of the parent module\n * @param {string} pkgPath The path of the package.json file\n * @throws {ERR_INVALID_MODULE_SPECIFIER} If the resolved module specifier contains encoded `/` or `\\\\` characters\n * @throws {Error} If the module cannot be found\n */\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  const { encodedSepRegEx } = require('internal/modules/esm/resolve');\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved) !== null) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  }\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual) {\n    return actual;\n  }\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\n/**\n * Creates an error object for when a requested ES module cannot be found.\n * @param {string} request The name of the requested module\n * @param {string} [path] The path to the requested module\n */\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path) {\n    err.path = path;\n  }\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n/**\n * Given a file name\x2C pass it to the proper extension handler.\n * @param {string} filename The `require` specifier\n */\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs']) {\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n  }\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const cascadedLoader = getCascadedLoader();\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !cascadedLoader.cjsCache.has(this)) {\n    cascadedLoader.cjsCache.set(this\x2C exports);\n  }\n};\n\n/**\n * Loads a module at the given file path. Returns that module's `exports` property.\n * Note: when using the experimental policy mechanism this function is overridden.\n * @param {string} id\n * @throws {ERR_INVALID_ARG_TYPE} When `id` is not a string\n */\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n/**\n * Resolved path to `process.argv[1]` will be lazily placed here\n * (needed for setting breakpoint when called with `--inspect-brk`).\n * @type {string | undefined}\n */\nlet resolvedArgv;\nlet hasPausedEntry = false;\n/** @type {import('vm').Script} */\n\n/**\n * Wraps the given content in a script and runs it in a new context.\n * @param {string} filename The name of the file being loaded\n * @param {string} content The content of the file being loaded\n * @param {Module} cjsModuleInstance The CommonJS loader instance\n */\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  const hostDefinedOptionId = Symbol(`cjs:${filename}`);\n  async function importModuleDynamically(specifier\x2C _\x2C importAttributes) {\n    const cascadedLoader = getCascadedLoader();\n    return cascadedLoader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                                 importAttributes);\n  }\n  if (patched) {\n    const wrapped = Module.wrap(content);\n    const script = makeContextifyScript(\n      wrapped\x2C                 // code\n      filename\x2C                // filename\n      0\x2C                       // lineOffset\n      0\x2C                       // columnOffset\n      undefined\x2C               // cachedData\n      false\x2C                   // produceCachedData\n      undefined\x2C               // parsingContext\n      hostDefinedOptionId\x2C     // hostDefinedOptionId\n      importModuleDynamically\x2C // importModuleDynamically\n    );\n\n    // Cache the source map for the module if present.\n    if (script.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C script.sourceMapURL);\n    }\n\n    return runScriptInThisContext(script\x2C true\x2C false);\n  }\n\n  const params = [ 'exports'\x2C 'require'\x2C 'module'\x2C '__filename'\x2C '__dirname' ];\n  try {\n    const result = internalCompileFunction(\n      content\x2C                           // code\x2C\n      filename\x2C                          // filename\n      0\x2C                                 // lineOffset\n      0\x2C                                 // columnOffset\x2C\n      undefined\x2C                         // cachedData\n      false\x2C                             // produceCachedData\n      undefined\x2C                         // parsingContext\n      undefined\x2C                         // contextExtensions\n      params\x2C                            // params\n      hostDefinedOptionId\x2C               // hostDefinedOptionId\n      importModuleDynamically\x2C           // importModuleDynamically\n    );\n\n    // Cache the source map for the module if present.\n    if (result.sourceMapURL) {\n      maybeCacheSourceMap(filename\x2C content\x2C this\x2C false\x2C undefined\x2C result.sourceMapURL);\n    }\n\n    return result.function;\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance) {\n      const { enrichCJSError } = require('internal/modules/esm/translators');\n      enrichCJSError(err\x2C content);\n    }\n    throw err;\n  }\n}\n\n/**\n * Run the file contents in the correct scope or sandbox. Expose the correct helper variables (`require`\x2C `module`\x2C\n * `exports`) to the file. Returns exception\x2C if any.\n * @param {string} content The source code of the module\n * @param {string} filename The file path of the module\n */\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = manifest.getDependencyMapper(moduleURL);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) { statCache = new SafeMap(); }\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) { statCache = null; }\n  return result;\n};\n\n/**\n * Native handler for `.js` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = packageJsonReader.readPackageScope(filename) || { __proto__: null };\n    // Function require shouldn't be used in ES modules.\n    if (pkg.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n/**\n * Native handler for `.json` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const moduleURL = pathToFileURL(filename);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    setOwnProperty(module\x2C 'exports'\x2C JSONParse(stripBOM(content)));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n/**\n * Native handler for `.node` files.\n * @param {Module} module The module to compile\n * @param {string} filename The file path of the module\n */\nModule._extensions['.node'] = function(module\x2C filename) {\n  const manifest = policy()?.manifest;\n  if (manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\n/**\n * Creates a `require` function that can be used to load modules from the specified path.\n * @param {string} filename The path to the module\n */\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\n/**\n * Creates a new `require` function that can be used to load modules.\n * @param {string | URL} filename The path or URL to the module context for this `require`\n * @throws {ERR_INVALID_ARG_VALUE} If `filename` is not a string or URL\x2C or if it is a relative path that cannot be\n * resolved to an absolute path.\n */\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURL(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\n/**\n * Define the paths to use for resolving a module.\n */\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\x2C\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\n/**\n * Handle modules loaded via `--require`.\n * @param {string[]} requests The values of `--require`\n */\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests)) { return; }\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++) {\n    internalRequire(parent\x2C requests[n]);\n  }\n  isPreloading = false;\n};\n\n/**\n * If the user has overridden an export from a builtin module\x2C this function can ensure that the override is used in\n * both CommonJS and ES module contexts.\n */\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of BuiltinModule.map.values()) {\n    if (BuiltinModule.canBeRequiredWithoutScheme(mod.id)) {\n      mod.syncExports();\n    }\n  }\n};\n\nObjectDefineProperty(Module.prototype\x2C 'constructor'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return policy() ? undefined : Module;\n  }\x2C\n  configurable: false\x2C\n  enumerable: false\x2C\n});\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x3a1b5d31b4f0,63,10621,11099,C0O10723C5O10737C10O10737C15O10783C20O10807C23O10807C27O10805C31O10840C36O10840C39O10870C44O10875C48O10895C54O10923C57O10930C62O10930C66O11017C75O11038C80O11074C84O11032C89O11098,,
tick,0x7f6e64f83003,34209,0,0x0,3,0x12da7b0,0x3a1b5d31b378,0x3a1b5d31b225,0x3a1b5d307147,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,34239,0x3a1b5d31e858,19,getCanBeRequiredByUsersWithoutSchemeList node:internal/bootstrap/realm:298:50,0x23f41f78f7e0,~
script-source,15,node:internal/bootstrap/realm,// This file is executed in every realm that is created by Node.js\x2C including\n// the context of main thread\x2C worker threads\x2C and ShadowRealms.\n// Only per-realm internal states and bindings should be bootstrapped in this\n// file and no globals should be exposed to the user code.\n//\n// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_BINDING_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_BINDING_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - BuiltinModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/realm') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  __proto__: null\x2C\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// The code bellow assumes that the two lists must not contain any modules\n// beginning with "internal/".\n// Modules that can only be imported via the node: scheme.\nconst schemelessBlockList = new SafeSet([\n  'test'\x2C\n  'test/reporters'\x2C\n]);\n// Modules that will only be enabled at run time.\nconst experimentalModuleList = new SafeSet();\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return requireBuiltin('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst selfId = 'internal/bootstrap/realm';\nconst {\n  builtinIds\x2C\n  compileFunction\x2C\n  setInternalLoaders\x2C\n} = internalBinding('builtins');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\nconst publicBuiltinIds = builtinIds\n  .filter((id) =>\n    !StringPrototypeStartsWith(id\x2C 'internal/') &&\n      !experimentalModuleList.has(id)\x2C\n  );\n// Do not expose the loaders to user land even with --expose-internals.\nconst internalBuiltinIds = builtinIds\n  .filter((id) => StringPrototypeStartsWith(id\x2C 'internal/') && id !== selfId);\n\n// When --expose-internals is on we'll add the internal builtin ids to these.\nconst canBeRequiredByUsersList = new SafeSet(publicBuiltinIds);\nconst canBeRequiredByUsersWithoutSchemeList =\n  new SafeSet(publicBuiltinIds.filter((id) => !schemelessBlockList.has(id)));\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass BuiltinModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C BuiltinModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(builtinIds\x2C (id) => [id\x2C new BuiltinModule(id)])\x2C\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the built-in module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  static allowRequireByUsers(id) {\n    if (id === selfId) {\n      // No code because this is an assertion against bugs.\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not allow ${id}`);\n    }\n    canBeRequiredByUsersList.add(id);\n    if (!schemelessBlockList.has(id)) {\n      canBeRequiredByUsersWithoutSchemeList.add(id);\n    }\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (let i = 0; i < internalBuiltinIds.length; ++i) {\n      BuiltinModule.allowRequireByUsers(internalBuiltinIds[i]);\n    }\n  }\n\n  static exists(id) {\n    return BuiltinModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    return canBeRequiredByUsersList.has(id);\n  }\n\n  static canBeRequiredWithoutScheme(id) {\n    return canBeRequiredByUsersWithoutSchemeList.has(id);\n  }\n\n  static isBuiltin(id) {\n    return BuiltinModule.canBeRequiredWithoutScheme(id) || (\n      typeof id === 'string' &&\n        StringPrototypeStartsWith(id\x2C 'node:') &&\n        BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(id\x2C 5))\n    );\n  }\n\n  static getCanBeRequiredByUsersWithoutSchemeList() {\n    return ArrayFrom(canBeRequiredByUsersWithoutSchemeList);\n  }\n\n  static normalizeRequirableId(id) {\n    if (StringPrototypeStartsWith(id\x2C 'node:')) {\n      const normalizedId = StringPrototypeSlice(id\x2C 5);\n      if (BuiltinModule.canBeRequiredByUsers(normalizedId)) {\n        return normalizedId;\n      }\n    } else if (BuiltinModule.canBeRequiredWithoutScheme(id)) {\n      return id;\n    }\n\n    return undefined;\n  }\n\n  static getSchemeOnlyModuleNames() {\n    return ArrayFrom(schemelessBlockList);\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!BuiltinModule.canBeRequiredByUsers(this.id)) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    // TODO(aduh95): move this to C++\x2C alongside the initialization of the class.\n    ObjectSetPrototypeOf(ModuleWrap.prototype\x2C null);\n    const url = `node:${this.id}`;\n    const builtin = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        builtin.syncExports();\n        this.setExport('default'\x2C builtin.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : requireBuiltin;\n\n      const fn = compileFunction(id);\n      // Arguments must match the parameters specified in\n      // BuiltinLoader::LookupAndCompile().\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    // "NativeModule" is a legacy name of "BuiltinModule". We keep it\n    // here to avoid breaking users who parse process.moduleLoadList.\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  BuiltinModule\x2C\n  require: requireBuiltin\x2C\n};\n\nfunction requireBuiltin(id) {\n  if (id === selfId) {\n    return loaderExports;\n  }\n\n  const mod = BuiltinModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    request = StringPrototypeSlice(request\x2C 5);\n  } else if (!BuiltinModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return requireBuiltin(request);\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\x2C\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\x2C\n    }\x2C\n  } = requireBuiltin('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\n// Store the internal loaders in C++.\nsetInternalLoaders(internalBinding\x2C requireBuiltin);\n\n// Setup per-realm bindings.\nsetupPrepareStackTrace();\n
code-source-info,0x3a1b5d31e858,15,9357,9426,C0O9366C11O9383C14O9373C18O9422,,
code-creation,LazyCompile,10,34659,0x3a1b5d31f7b0,13,desc.value node:internal/per_context/primordials:387:32,0x23f41f788738,~
script-source,12,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringFromCharCode'\x2C\n  'StringFromCodePoint'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    __proto__: null\x2C\n    value: uncurryThis(get)\x2C\n    enumerable\x2C\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      __proto__: null\x2C\n      value: uncurryThis(set)\x2C\n      enumerable\x2C\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Define Symbol.dispose and Symbol.asyncDispose\n// Until these are defined by the environment.\n// TODO(MoLow): Remove this polyfill once Symbol.dispose and Symbol.asyncDispose are available in V8.\nprimordials.SymbolDispose ??= primordials.SymbolFor('nodejs.dispose');\nprimordials.SymbolAsyncDispose ??= primordials.SymbolFor('nodejs.asyncDispose');\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\nprimordials.IteratorPrototype = Reflect.getPrototypeOf(primordials.ArrayIteratorPrototype);\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  Array: ArrayConstructor\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectSet\x2C\n  ReflectGet\x2C\n  RegExp\x2C\n  RegExpPrototype\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetFlags\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSource\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  SymbolMatch\x2C\n  SymbolMatchAll\x2C\n  SymbolReplace\x2C\n  SymbolSearch\x2C\n  SymbolSpecies\x2C\n  SymbolSplit\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n\n/**\n * Creates a class that can be safely iterated over.\n *\n * Because these functions are used by `makeSafe`\x2C which is exposed on the\n * `primordials` object\x2C it's important to use const references to the\n * primordials that they use.\n * @template {Iterable} T\n * @template {*} TReturn\n * @template {*} TNext\n * @param {(self: T) => IterableIterator<T>} factory\n * @param {(...args: [] | [TNext]) => IteratorResult<T\x2C TReturn>} next\n * @returns {Iterator<T\x2C TReturn\x2C TNext>}\n */\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\x2C\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\x2C\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        { __proto__: null\x2C ...ReflectGetOwnPropertyDescriptor(src\x2C key) });\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C { __proto__: null\x2C ...desc });\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\x2C\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\x2C\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\x2C\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\x2C\n);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\x2C\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nconst arrayToSafePromiseIterable = (promises\x2C mapFn) =>\n  new primordials.SafeArrayIterator(\n    ArrayPrototypeMap(\n      promises\x2C\n      (promise\x2C i) =>\n        new SafePromise((a\x2C b) => PromisePrototypeThen(mapFn == null ? promise : mapFn(promise\x2C i)\x2C a\x2C b))\x2C\n    )\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>[]>}\n */\nprimordials.SafePromiseAll = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.all(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used for internal functions\x2C this would produce similar\n * results as `Promise.all` but without prototype pollution\x2C and the return\n * value is not a genuine Array but an array-like object.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<ArrayLike<Awaited<U>>>}\n */\nprimordials.SafePromiseAllReturnArrayLike = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    const { length } = promises;\n\n    const returnVal = ArrayConstructor(length);\n    ObjectSetPrototypeOf(returnVal\x2C null);\n    if (length === 0) resolve(returnVal);\n\n    let pendingPromises = length;\n    for (let i = 0; i < length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C (result) => {\n        returnVal[i] = result;\n        if (--pendingPromises === 0) resolve(returnVal);\n      }\x2C reject);\n    }\n  });\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * resolve\x2C not what value they resolve to.\n * @template T\x2CU\n * @param {ArrayLike<T | PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllReturnVoid = (promises\x2C mapFn) =>\n  new Promise((resolve\x2C reject) => {\n    let pendingPromises = promises.length;\n    if (pendingPromises === 0) resolve();\n    for (let i = 0; i < promises.length; i++) {\n      const promise = mapFn != null ? mapFn(promises[i]\x2C i) : promises[i];\n      PromisePrototypeThen(PromiseResolve(promise)\x2C () => {\n        if (--pendingPromises === 0) resolve();\n      }\x2C reject);\n    }\n  });\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<PromiseSettledResult<any>[]>}\n */\nprimordials.SafePromiseAllSettled = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.allSettled(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * Should only be used when we only care about waiting for all the promises to\n * settle\x2C not what value they resolve or reject to.\n * @template T\x2CU\n * @param {ArrayLike<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<void>}\n */\nprimordials.SafePromiseAllSettledReturnVoid = async (promises\x2C mapFn) => {\n  await primordials.SafePromiseAllSettled(promises\x2C mapFn);\n};\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseAny = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.any(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n/**\n * @template T\x2CU\n * @param {Array<T|PromiseLike<T>>} promises\n * @param {(v: T|PromiseLike<T>\x2C k: number) => U|PromiseLike<U>} [mapFn]\n * @returns {Promise<Awaited<U>>}\n */\nprimordials.SafePromiseRace = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.race(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\x2C\n  );\n\n\nconst {\n  exec: OriginalRegExpPrototypeExec\x2C\n  [SymbolMatch]: OriginalRegExpPrototypeSymbolMatch\x2C\n  [SymbolMatchAll]: OriginalRegExpPrototypeSymbolMatchAll\x2C\n  [SymbolReplace]: OriginalRegExpPrototypeSymbolReplace\x2C\n  [SymbolSearch]: OriginalRegExpPrototypeSymbolSearch\x2C\n  [SymbolSplit]: OriginalRegExpPrototypeSymbolSplit\x2C\n} = RegExpPrototype;\n\nclass RegExpLikeForStringSplitting {\n  #regex;\n  constructor() {\n    this.#regex = ReflectConstruct(RegExp\x2C arguments);\n  }\n\n  get lastIndex() {\n    return ReflectGet(this.#regex\x2C 'lastIndex');\n  }\n  set lastIndex(value) {\n    ReflectSet(this.#regex\x2C 'lastIndex'\x2C value);\n  }\n\n  exec() {\n    return ReflectApply(OriginalRegExpPrototypeExec\x2C this.#regex\x2C arguments);\n  }\n}\nObjectSetPrototypeOf(RegExpLikeForStringSplitting.prototype\x2C null);\n\n/**\n * @param {RegExp} pattern\n * @returns {RegExp}\n */\nprimordials.hardenRegExp = function hardenRegExp(pattern) {\n  ObjectDefineProperties(pattern\x2C {\n    [SymbolMatch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatch\x2C\n    }\x2C\n    [SymbolMatchAll]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolMatchAll\x2C\n    }\x2C\n    [SymbolReplace]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolReplace\x2C\n    }\x2C\n    [SymbolSearch]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSearch\x2C\n    }\x2C\n    [SymbolSplit]: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeSymbolSplit\x2C\n    }\x2C\n    constructor: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: {\n        [SymbolSpecies]: RegExpLikeForStringSplitting\x2C\n      }\x2C\n    }\x2C\n    dotAll: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetDotAll(pattern)\x2C\n    }\x2C\n    exec: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: OriginalRegExpPrototypeExec\x2C\n    }\x2C\n    global: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetGlobal(pattern)\x2C\n    }\x2C\n    hasIndices: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetHasIndices(pattern)\x2C\n    }\x2C\n    ignoreCase: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetIgnoreCase(pattern)\x2C\n    }\x2C\n    multiline: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetMultiline(pattern)\x2C\n    }\x2C\n    source: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSource(pattern)\x2C\n    }\x2C\n    sticky: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetSticky(pattern)\x2C\n    }\x2C\n    unicode: {\n      __proto__: null\x2C\n      configurable: true\x2C\n      value: RegExpPrototypeGetUnicode(pattern)\x2C\n    }\x2C\n  });\n  ObjectDefineProperty(pattern\x2C 'flags'\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    value: RegExpPrototypeGetFlags(pattern)\x2C\n  });\n  return pattern;\n};\n\n\n/**\n * @param {string} str\n * @param {RegExp} regexp\n * @returns {number}\n */\nprimordials.SafeStringPrototypeSearch = (str\x2C regexp) => {\n  regexp.lastIndex = 0;\n  const match = RegExpPrototypeExec(regexp\x2C str);\n  return match ? match.index : -1;\n};\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x3a1b5d31f7b0,12,11247,11306,C0O11264C7O11271C12O11294,,
tick,0x7f6e65374b68,35340,0,0x0,3,0x12da7b0,0x17292ef,0x3a1b5d31e866,0x3a1b5d31b4fa,0x3a1b5d31b378,0x3a1b5d31b225,0x3a1b5d307147,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,LazyCompile,10,35355,0x3a1b5d320fe8,13,SafeIterator node:internal/per_context/primordials:332:16,0x23f41f787e78,~
code-source-info,0x3a1b5d320fe8,12,9510,9570,C0O9529C3O9546C7O9544C12O9569,,
code-creation,LazyCompile,10,35384,0x3a1b5d321118,13,next node:internal/per_context/primordials:335:9,0x23f41f787ec8,~
code-source-info,0x3a1b5d321118,12,9579,9624,C0O9590C3O9607C8O9597C12O9618,,
code-creation,LazyCompile,10,35448,0x3a1b5d321408,170,initializeCjsConditions node:internal/modules/helpers:66:33,0x1d7bd0ee51d0,~
script-source,64,node:internal/modules/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n} = require('internal/errors').codes;\nconst { BuiltinModule } = require('internal/bootstrap/realm');\n\nconst { validateString } = require('internal/validators');\nconst fs = require('fs'); // Import all of `fs` so that it can be monkey-patched.\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst { setOwnProperty } = require('internal/util');\n\nconst {\n  privateSymbols: {\n    require_private_symbol\x2C\n  }\x2C\n} = internalBinding('util');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\n/** @typedef {import('internal/modules/cjs/loader.js').Module} Module */\n\n/**\n * Cache for storing resolved real paths of modules.\n * In order to minimize unnecessary lstat() calls\x2C this cache is a list of known-real paths.\n * Set to an empty Map to reset.\n * @type {Map<string\x2C string>}\n */\nconst realpathCache = new SafeMap();\n/**\n * Resolves the path of a given `require` specifier\x2C following symlinks.\n * @param {string} requestPath The `require` specifier\n */\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\x2C\n  });\n}\n\n/** @type {Set<string>} */\nlet cjsConditions;\n/**\n * Define the conditions that apply to the CommonJS loader.\n */\nfunction initializeCjsConditions() {\n  const userConditions = getOptionValue('--conditions');\n  const noAddons = getOptionValue('--no-addons');\n  const addonConditions = noAddons ? [] : ['node-addons'];\n  // TODO: Use this set when resolving pkg#exports conditions in loader.js.\n  cjsConditions = new SafeSet([\n    'require'\x2C\n    'node'\x2C\n    ...addonConditions\x2C\n    ...userConditions\x2C\n  ]);\n}\n\n/**\n * Get the conditions that apply to the CommonJS loader.\n */\nfunction getCjsConditions() {\n  if (cjsConditions === undefined) {\n    initializeCjsConditions();\n  }\n  return cjsConditions;\n}\n\n/**\n * Provide one of Node.js' public modules to user code.\n * @param {string} id - The identifier/specifier of the builtin module to load\n * @param {string} request - The module requiring or importing the builtin module\n */\nfunction loadBuiltinModule(id\x2C request) {\n  if (!BuiltinModule.canBeRequiredByUsers(id)) {\n    return;\n  }\n  /** @type {import('internal/bootstrap/realm.js').BuiltinModule} */\n  const mod = BuiltinModule.map.get(id);\n  debug('load built-in module %s'\x2C request);\n  // compileForPublicLoader() throws if canBeRequiredByUsers is false:\n  mod.compileForPublicLoader();\n  return mod;\n}\n\n/** @type {Module} */\nlet $Module = null;\n/**\n * Import the Module class on first use.\n */\nfunction lazyModule() {\n  $Module = $Module || require('internal/modules/cjs/loader').Module;\n  return $Module;\n}\n\n/**\n * Invoke with `makeRequireFunction(module)` where `module` is the `Module` object to use as the context for the\n * `require()` function.\n * Use redirects to set up a mapping from a policy and restrict dependencies.\n */\nconst urlToFileCache = new SafeMap();\n/**\n * Create the module-scoped `require` function to pass into CommonJS modules.\n * @param {Module} mod - The module to create the `require` function for.\n * @param {ReturnType<import('internal/policy/manifest.js').Manifest['getDependencyMapper']>} redirects\n * @typedef {(specifier: string) => unknown} RequireFunction\n */\nfunction makeRequireFunction(mod\x2C redirects) {\n  // lazy due to cycle\n  const Module = lazyModule();\n  if (mod instanceof Module !== true) {\n    throw new ERR_INVALID_ARG_TYPE('mod'\x2C 'Module'\x2C mod);\n  }\n\n  /** @type {RequireFunction} */\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = getCjsConditions();\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const { href\x2C protocol } = destination;\n        if (protocol === 'node:') {\n          const specifier = destination.pathname;\n\n          if (BuiltinModule.canBeRequiredByUsers(specifier)) {\n            const mod = loadBuiltinModule(specifier\x2C href);\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (protocol === 'file:') {\n          let filepath = urlToFileCache.get(href);\n          if (!filepath) {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod[require_private_symbol](mod\x2C filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\x2C\n        ));\n      }\n      return mod[require_private_symbol](mod\x2C specifier);\n    };\n  } else {\n    require = function require(path) {\n      // When no policy manifest\x2C the original prototype.require is sustained\n      return mod.require(path);\n    };\n  }\n\n  /**\n   * The `resolve` method that gets attached to module-scope `require`.\n   * @param {string} request\n   * @param {Parameters<Module['_resolveFilename']>[3]} options\n   */\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  /**\n   * The `paths` method that gets attached to module-scope `require`.\n   * @param {string} request\n   */\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  setOwnProperty(require\x2C 'main'\x2C process.mainModule);\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n * @param {string} content\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\n/**\n * Add built-in modules to a global or REPL scope object.\n * @param {Record<string\x2C unknown>} object - The object such as `globalThis` to add the built-in modules to.\n * @param {string} dummyModuleName - The label representing the set of built-in modules to add.\n */\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      __proto__: null\x2C\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        try {\n          // Override the current getter/setter and set up a new\n          // non-enumerable property.\n          ObjectDefineProperty(object\x2C name\x2C {\n            __proto__: null\x2C\n            get: () => lib\x2C\n            set: setReal\x2C\n            configurable: true\x2C\n            enumerable: false\x2C\n          });\n        } catch {\n          // If the property is no longer configurable\x2C ignore the error.\n        }\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\x2C\n    });\n  });\n}\n\n/**\n * If a referrer is an URL instance or absolute path\x2C convert it into an URL string.\n * @param {string | URL} referrer\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n/**\n * For error messages only\x2C check if ESM syntax is in use.\n * @param {string} code\n */\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  getCjsConditions\x2C\n  initializeCjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n  toRealPath\x2C\n};\n
code-source-info,0x3a1b5d321408,64,1828,2188,C0O1858C8O1858C13O1909C21O1909C26O1966C37O2077C49O2141C50O2141C101O2165C154O2093C162O2091C169O2187,,
code-creation,LazyCompile,10,35741,0x3a1b5d322048,28,getEmbedderOptions node:internal/options:32:28,0x28d42e28a900,~
code-source-info,0x3a1b5d322048,22,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,35792,0x3a1b5d322358,315,Module._initPaths node:internal/modules/cjs/loader:1517:29,0x1d7bd0ee2320,~
code-source-info,0x3a1b5d322358,63,49095,50052,C0O49118C9O49138C14O49142C22O49156C28O49156C33O49195C42O49215C47O49219C55O49231C61O49231C66O49426C74O49442C77O49447C85O49463C93O49447C103O49485C106O49490C114O49506C125O49490C131O49546C140O49547C143O49552C157O49552C169O49591C173O49610C180O49639C183O49644C191O49644C198O49610C203O49686C210O49715C213O49720C221O49720C228O49686C233O49763C237O49783C244O49817C249O49845C254O49876C257O49881C262O49845C270O49899C273O49817C279O49783C284O49923C286O49935C292O49996C297O50017C302O50037C305O50017C309O50015C314O50051,,
new,MemoryChunk,0x2ffc48500000,262144
new,MemoryChunk,0x65c0000,262144
tick,0x7f6e65021aab,35918,0,0x0,0,0x12e35b0,0x3a1b5d30e6c1,0x3a1b5d30abee,0x3a1b5d3223d5,0x3a1b5d31b52e,0x3a1b5d31b378,0x3a1b5d31b225,0x3a1b5d307147,0x3a1b5d305900,0x3a1b5d3055b6
code-creation,Function,11,35949,0x65c3080,3004,normalizeString node:path:66:25,0x32bbd746bd70,^
code-source-info,0x65c3080,40,2161,4085,,,
code-creation,Function,11,35970,0x65c3cc0,100,isPosixPathSeparator node:path:56:30,0x32bbd746bcd0,^
code-source-info,0x65c3cc0,40,1854,1902,,,
code-creation,Function,11,35982,0x65c3dc0,556,getOptionValue node:internal/options:44:24,0x28d42e28a9a0,^
code-source-info,0x65c3dc0,22,985,1228,,,
code-creation,Function,11,35995,0x65c4080,620,requireBuiltin node:internal/bootstrap/realm:412:24,0x23f41f78fc58,^
code-source-info,0x65c4080,15,13102,13444,,,
code-creation,Function,11,36004,0x65c4380,408,getCLIOptionsFromBinding node:internal/options:18:34,0x28d42e28a788,^
code-source-info,0x65c4380,22,497,598,,,
code-creation,Function,11,36011,0x65c45c0,100,next node:internal/per_context/primordials:335:9,0x23f41f787ec8,^
code-source-info,0x65c45c0,12,9579,9624,,,
code-creation,LazyCompile,10,36108,0x3a1b5d322bf8,91,initializeESMLoader node:internal/process/pre_execution:587:29,0x1d7bd0eef0e0,~
code-source-info,0x3a1b5d322bf8,67,18291,18838,C0O18338C6O18338C11O18320C16O18379C20O18542C28O18546C34O18662C40O18662C45O18611C50O18619C55O18637C60O18708C66O18708C71O18727C73O18737C77O18751C79O18771C83O18795C85O18814C90O18837,,
code-creation,LazyCompile,10,36149,0x3a1b5d322d70,50,initializeESM node:internal/modules/esm/utils:192:23,0x1d7bd0ee92a8,~
script-source,66,node:internal/modules/esm/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  ObjectFreeze\x2C\n} = primordials;\n\nconst {\n  privateSymbols: {\n    host_defined_option_symbol\x2C\n  }\x2C\n} = internalBinding('util');\nconst {\n  default_host_defined_options\x2C\n  vm_dynamic_import_missing_flag\x2C\n} = internalBinding('symbols');\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG\x2C\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\nconst { getOptionValue } = require('internal/options');\nconst {\n  loadPreloadModules\x2C\n  initializeFrozenIntrinsics\x2C\n} = require('internal/process/pre_execution');\nconst { getCWDURL } = require('internal/util');\nconst {\n  setImportModuleDynamicallyCallback\x2C\n  setInitializeImportMetaObjectCallback\x2C\n} = internalBinding('module_wrap');\nconst assert = require('internal/assert');\n\nlet defaultConditions;\n/**\n * Returns the default conditions for ES module loading.\n */\nfunction getDefaultConditions() {\n  assert(defaultConditions !== undefined);\n  return defaultConditions;\n}\n\n/** @type {Set<string>} */\nlet defaultConditionsSet;\n/**\n * Returns the default conditions for ES module loading\x2C as a Set.\n */\nfunction getDefaultConditionsSet() {\n  assert(defaultConditionsSet !== undefined);\n  return defaultConditionsSet;\n}\n\n/**\n * Initializes the default conditions for ESM module loading.\n * This function is called during pre-execution\x2C before any user code is run.\n */\nfunction initializeDefaultConditions() {\n  const userConditions = getOptionValue('--conditions');\n  const noAddons = getOptionValue('--no-addons');\n  const addonConditions = noAddons ? [] : ['node-addons'];\n\n  defaultConditions = ObjectFreeze([\n    'node'\x2C\n    'import'\x2C\n    ...addonConditions\x2C\n    ...userConditions\x2C\n  ]);\n  defaultConditionsSet = new SafeSet(defaultConditions);\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== getDefaultConditions()) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return getDefaultConditionsSet();\n}\n\n/**\n * @callback ImportModuleDynamicallyCallback\n * @param {string} specifier\n * @param {ModuleWrap|ContextifyScript|Function|vm.Module} callbackReferrer\n * @param {object} attributes\n * @returns { Promise<void> }\n */\n\n/**\n * @callback InitializeImportMetaCallback\n * @param {object} meta\n * @param {ModuleWrap|ContextifyScript|Function|vm.Module} callbackReferrer\n */\n\n/**\n * @typedef {{\n *   callbackReferrer: ModuleWrap|ContextifyScript|Function|vm.Module\n *   initializeImportMeta? : InitializeImportMetaCallback\x2C\n *   importModuleDynamically? : ImportModuleDynamicallyCallback\n * }} ModuleRegistry\n */\n\n/**\n * @type {WeakMap<symbol\x2C ModuleRegistry>}\n */\nconst moduleRegistries = new SafeWeakMap();\n\n/**\n * V8 would make sure that as long as import() can still be initiated from\n * the referrer\x2C the symbol referenced by |host_defined_option_symbol| should\n * be alive\x2C which in term would keep the settings object alive through the\n * WeakMap\x2C and in turn that keeps the referrer object alive\x2C which would be\n * passed into the callbacks.\n * The reference goes like this:\n * [v8::internal::Script] (via host defined options) ----1--> [idSymbol]\n * [callbackReferrer] (via host_defined_option_symbol) ------2------^  |\n *                                 ^----------3---- (via WeakMap)------\n * 1+3 makes sure that as long as import() can still be initiated\x2C the\n * referrer wrap is still around and can be passed into the callbacks.\n * 2 is only there so that we can get the id symbol to configure the\n * weak map.\n * @param {ModuleWrap|ContextifyScript|Function} referrer The referrer to\n *   get the id symbol from. This is different from callbackReferrer which\n *   could be set by the caller.\n * @param {ModuleRegistry} registry\n */\nfunction registerModule(referrer\x2C registry) {\n  const idSymbol = referrer[host_defined_option_symbol];\n  if (idSymbol === default_host_defined_options ||\n      idSymbol === vm_dynamic_import_missing_flag) {\n    // The referrer is compiled without custom callbacks\x2C so there is\n    // no registry to hold on to. We'll throw\n    // ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING when a callback is\n    // needed.\n    return;\n  }\n  // To prevent it from being GC'ed.\n  registry.callbackReferrer ??= referrer;\n  moduleRegistries.set(idSymbol\x2C registry);\n}\n\n/**\n * Defines the `import.meta` object for a given module.\n * @param {symbol} symbol - Reference to the module.\n * @param {Record<string\x2C string | Function>} meta - The import.meta object to initialize.\n */\nfunction initializeImportMetaObject(symbol\x2C meta) {\n  if (moduleRegistries.has(symbol)) {\n    const { initializeImportMeta\x2C callbackReferrer } = moduleRegistries.get(symbol);\n    if (initializeImportMeta !== undefined) {\n      meta = initializeImportMeta(meta\x2C callbackReferrer);\n    }\n  }\n}\n\n/**\n * Asynchronously imports a module dynamically using a callback function. The native callback.\n * @param {symbol} symbol - Reference to the module.\n * @param {string} specifier - The module specifier string.\n * @param {Record<string\x2C string>} attributes - The import attributes object.\n * @returns {Promise<import('internal/modules/esm/loader.js').ModuleExports>} - The imported module object.\n * @throws {ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING} - If the callback function is missing.\n */\nasync function importModuleDynamicallyCallback(symbol\x2C specifier\x2C attributes) {\n  if (moduleRegistries.has(symbol)) {\n    const { importModuleDynamically\x2C callbackReferrer } = moduleRegistries.get(symbol);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(specifier\x2C callbackReferrer\x2C attributes);\n    }\n  }\n  if (symbol === vm_dynamic_import_missing_flag) {\n    throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG();\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n}\n\nlet _isLoaderWorker = false;\n/**\n * Initializes handling of ES modules.\n * This is configured during pre-execution. Specifically it's set to true for\n * the loader worker in internal/main/worker_thread.js.\n * @param {boolean} [isLoaderWorker=false] - A boolean indicating whether the loader is a worker or not.\n */\nfunction initializeESM(isLoaderWorker = false) {\n  _isLoaderWorker = isLoaderWorker;\n  initializeDefaultConditions();\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(importModuleDynamicallyCallback);\n}\n\n/**\n * Determine whether the current process is a loader worker.\n * @returns {boolean} Whether the current process is a loader worker.\n */\nfunction isLoaderWorker() {\n  return _isLoaderWorker;\n}\n\n/**\n * Register module customization hooks.\n */\nasync function initializeHooks() {\n  const customLoaderURLs = getOptionValue('--experimental-loader');\n\n  const { Hooks } = require('internal/modules/esm/hooks');\n  const esmLoader = require('internal/process/esm_loader').esmLoader;\n\n  const hooks = new Hooks();\n  esmLoader.setCustomizations(hooks);\n\n  // We need the loader customizations to be set _before_ we start invoking\n  // `--require`\x2C otherwise loops can happen because a `--require` script\n  // might call `register(...)` before we've installed ourselves. These\n  // global values are magically set in `setupUserModules` just for us and\n  // we call them in the correct order.\n  // N.B.  This block appears here specifically in order to ensure that\n  // `--require` calls occur before `--loader` ones do.\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n\n  const parentURL = getCWDURL().href;\n  for (let i = 0; i < customLoaderURLs.length; i++) {\n    await hooks.register(\n      customLoaderURLs[i]\x2C\n      parentURL\x2C\n    );\n  }\n\n  const preloadScripts = hooks.initializeGlobalPreload();\n\n  return { __proto__: null\x2C hooks\x2C preloadScripts };\n}\n\nmodule.exports = {\n  registerModule\x2C\n  initializeESM\x2C\n  initializeHooks\x2C\n  getDefaultConditions\x2C\n  getConditionsSet\x2C\n  loaderWorkerId: 'internal/modules/esm/worker'\x2C\n  isLoaderWorker\x2C\n};\n
code-source-info,0x3a1b5d322d70,66,6374,6728,C10O6403C12O6419C18O6439C21O6439C24O6589C32O6589C36O6658C44O6658C49O6727,,
code-creation,LazyCompile,10,36393,0x3a1b5d323760,193,initializeDefaultConditions node:internal/modules/esm/utils:60:37,0x1d7bd0ee9118,~
code-source-info,0x3a1b5d323760,66,1463,1809,C0O1493C8O1493C13O1544C21O1544C26O1601C37O1637C49O1705C50O1705C101O1729C152O1657C159O1655C165O1753C172O1788C177O1776C185O1774C192O1808,,
code-creation,LazyCompile,10,36423,0x3a1b5d323968,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:73:32,0x1d7bd0edfab8,~
code-source-info,0x3a1b5d323968,63,2233,2273,C0O2238C4O2271,,
code-creation,LazyCompile,10,36448,0x3a1b5d323a70,53,loadPreloadModules node:internal/process/pre_execution:619:28,0x1d7bd0eef1d0,~
code-source-info,0x3a1b5d323a70,67,19326,19647,C0O19413C8O19413C13O19444C15O19481C21O19488C26O19565C32O19565C37O19565C42O19531C47O19609C52O19646,,
code-creation,LazyCompile,10,36469,0x3a1b5d323c58,50,initializeFrozenIntrinsics node:internal/process/pre_execution:611:36,0x1d7bd0eef180,~
code-source-info,0x3a1b5d323c58,67,19075,19297,C0O19082C8O19086C14O19131C17O19139C28O19139C34O19251C40O19251C45O19288C49O19296,,
code-creation,LazyCompile,10,36485,0x3a1b5d323d80,22,markBootstrapComplete node:internal/process/pre_execution:632:31,0x1d7bd0eef220,~
code-source-info,0x3a1b5d323d80,67,19679,19743,C0O19686C6O19686C11O19716C16O19717C21O19742,,
code-creation,LazyCompile,10,36552,0x3a1b5d323ee0,94,executeUserEntryPoint node:internal/modules/run_main:120:31,0x1d7bd0ef5288,~
script-source,70,node:internal/modules/run_main,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\n\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\n/**\n * Get the absolute path to the main entry point.\n * @param {string} main - Entry point path\n */\nfunction resolveMainPath(main) {\n  const defaultType = getOptionValue('--experimental-default-type');\n  /** @type {string} */\n  let mainPath;\n  if (defaultType === 'module') {\n    if (getOptionValue('--preserve-symlinks-main')) { return; }\n    mainPath = path.resolve(main);\n  } else {\n    // Extension searching for the main entry point is supported only in legacy mode.\n    // Module._findPath is monkey-patchable here.\n    const { Module } = require('internal/modules/cjs/loader');\n    mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  }\n  if (!mainPath) { return; }\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain) {\n    const { toRealPath } = require('internal/modules/helpers');\n    try {\n      mainPath = toRealPath(mainPath);\n    } catch (err) {\n      if (defaultType === 'module' && err?.code === 'ENOENT') {\n        const { decorateErrorWithCommonJSHints } = require('internal/modules/esm/resolve');\n        const { getCWDURL } = require('internal/util');\n        decorateErrorWithCommonJSHints(err\x2C mainPath\x2C getCWDURL());\n      }\n      throw err;\n    }\n  }\n\n  return mainPath;\n}\n\n/**\n * Determine whether the main entry point should be loaded through the ESM Loader.\n * @param {string} mainPath - Absolute path to the main entry point\n */\nfunction shouldUseESMLoader(mainPath) {\n  if (getOptionValue('--experimental-default-type') === 'module') { return true; }\n\n  /**\n   * @type {string[]} userLoaders A list of custom loaders registered by the user\n   * (or an empty list when none have been registered).\n   */\n  const userLoaders = getOptionValue('--experimental-loader');\n  /**\n   * @type {string[]} userImports A list of preloaded modules registered by the user\n   * (or an empty list when none have been registered).\n   */\n  const userImports = getOptionValue('--import');\n  if (userLoaders.length > 0 || userImports.length > 0) {\n    return true;\n  }\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node') {\n    return true;\n  }\n  // Determine the module format of the entry point.\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs')) { return true; }\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs')) { return false; }\n\n  const { readPackageScope } = require('internal/modules/package_json_reader');\n  const pkg = readPackageScope(mainPath);\n  // No need to guard `pkg` as it can only be an object or `false`.\n  return pkg.data?.type === 'module' || getOptionValue('--experimental-default-type') === 'module';\n}\n\n/**\n * Run the main entry point through the ESM Loader.\n * @param {string} mainPath - Absolute path for the main entry point\n */\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n  const main = pathToFileURL(mainPath).href;\n\n  handleMainPromise(loadESM((esmLoader) => {\n    return esmLoader.import(main\x2C undefined\x2C { __proto__: null });\n  }));\n}\n\n/**\n * Handle process exit events around the main entry point promise.\n * @param {Promise} promise - Main entry point promise\n */\nasync function handleMainPromise(promise) {\n  const {\n    handleProcessExit\x2C\n  } = require('internal/modules/esm/handle_process_exit');\n  process.on('exit'\x2C handleProcessExit);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handleProcessExit);\n  }\n}\n\n/**\n * Parse the CLI main entry point string and run it.\n * For backwards compatibility\x2C we have to run a bunch of monkey-patchable code that belongs to the CJS loader (exposed\n * by `require('module')`) even when the entry point is ESM.\n * This monkey-patchable code is bypassed under `--experimental-default-type=module`.\n * Because of backwards compatibility\x2C this function is exposed publicly via `import { runMain } from 'node:module'`.\n * @param {string} main - First positional CLI argument\x2C such as `'entry.js'` from `node entry.js`\n */\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    const { Module } = require('internal/modules/cjs/loader');\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x3a1b5d323ee0,70,4291,4659,C7O4307C14O4311C22O4341C25O4341C30O4387C33O4387C38O4423C40O4447C45O4458C50O4447C56O4578C62O4578C67O4567C72O4629C87O4629C93O4658,,
code-creation,LazyCompile,10,36722,0x3a1b5d324678,248,resolveMainPath node:internal/modules/run_main:14:25,0x1d7bd0ef5070,~
code-source-info,0x3a1b5d324678,70,280,1415,C0O311C8O311C13O388C15O400C17O416C22O436C30O440C36O486C37O493C38O500C43O516C48O516C56O701C62O701C67O690C72O763C79O773C82O778C87O778C100O763C106O812C110O829C111O836C112O871C120O871C125O917C127O973C133O973C138O958C146O1037C154O1035C164O1085C166O1101C176O1120C186O1127C191O1194C199O1194C204O1159C209O1265C217O1265C222O1251C227O1299C230O1345C237O1299C242O1373C244O1373C245O1397C247O1413,,
code-creation,LazyCompile,10,36846,0x3a1b5d324bc8,847,Module._findPath node:internal/modules/cjs/loader:609:28,0x1d7bd0ee1990,~
code-source-info,0x3a1b5d324bc8,63,17971,21970,C0O18024C6O18029C11O18029C17O18052C19O18079C27O18102C31O18122C37O18129C42O18142C43O18155C44O18180C46O18188C52O18199C60O18199C65O18197C69O18250C72O18257C79O18267C83O18281C85O18298C87O18311C88O18323C90O18361C96O18368C103O18380C106O18423C110O18430C115O18380C123O18439C125O18435C132O18469C135O18512C139O18519C144O18469C152O18528C154O18524C159O18564C166O18571C173O18588C176O18631C180O18638C185O18588C193O18647C195O18643C202O18678C205O18721C209O18728C214O18678C222O18737C224O18733C229O18769C236O18776C243O18795C246O18838C250O18845C255O18795C263O18854C265O18850C269O18922C277O18922C285O18964C287O18960C292O18996C299O19003C306O19018C313O19018C321O19060C323O19056C330O19089C336O19102C343O19102C351O19144C353O19140C360O19175C367O19175C375O19217C377O19213C382O19248C389O19255C396O19272C403O19272C411O19314C413O19310C420O19346C426O19359C433O19359C441O19401C443O19397C447O19450C449O19458C453O19506C459O19511C464O19511C470O19535C479O19539C486O19599C488O19664C490O19677C494O19669C499O19793C501O19798C505O19807C511O19825C515O19836C518O19836C525O19851C530O19864C532O19885C536O19939C539O19939C545O19979C547O20010C549O20033C550O20070C556O20075C561O20075C568O20110C570O20136C575O20136C580O20157C584O20185C585O20192C590O20219C594O20244C603O20248C609O20301C615O20317C620O20317C628O20367C633O20378C640O20427C649O20431C655O21071C661O21087C666O21087C674O21133C679O21144C684O21191C688O21262C692O21298C701O21323C707O21305C712O21355C724O21366C730O21424C736O21444C741O21529C745O21563C754O21588C760O21570C765O21616C780O21627C786O21683C790O21705C793O21712C800O21733C804O21751C806O21767C807O21798C812O21808C816O21840C821O21840C826O21893C829O21893C834O19686C839O19651C845O21955C846O21968,,
code-creation,LazyCompile,10,36893,0x3a1b5d3251e0,45,isAbsolute node:path:1155:13,0x32bbd746c220,~
code-source-info,0x3a1b5d3251e0,40,35491,35637,C0O35504C8O35504C13O35550C19O35557C26O35575C31O35575C39O35614C41O35610C44O35633,,
code-creation,LazyCompile,10,36935,0x3a1b5d325370,85,stat node:internal/modules/cjs/loader:184:14,0x1d7bd0ee10d0,~
code-source-info,0x3a1b5d325370,63,5174,5575,C0O5189C5O5205C10O5205C17O5235C23O5280C28O5290C33O5290C39O5309C41O5337C43O5351C44O5375C49O5375C54O5407C61O5440C66O5520C71O5530C76O5530C82O5559C84O5573,,
code-creation,LazyCompile,10,36953,0x3a1b5d3254b0,3,toNamespacedPath node:path:1265:19,0x32bbd746c310,~
code-source-info,0x3a1b5d3254b0,40,38652,38712,C0O38696C2O38708,,
tick,0x167a269,36994,1,0xb9fcb0,6,0xdd1310,0x3a1b5d3253a1,0x3a1b5d324e07,0x3a1b5d3246dc,0x3a1b5d323ef9,0x3a1b5d305600
code-creation,LazyCompile,10,37026,0x3a1b5d3255c0,42,toRealPath node:internal/modules/helpers:55:20,0x1d7bd0ee5180,~
code-source-info,0x3a1b5d3255c0,64,1567,1680,C0O1585C5O1595C10O1608C17O1628C20O1639C28O1658C35O1595C41O1678,,
code-creation,LazyCompile,10,37266,0x3a1b5d325cc0,1079,realpathSync node:fs:2577:22,0x13800b178fd0,~
script-source,59,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  Boolean\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\x2C\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n  deprecate\x2C\n  kEmptyObject\x2C\n  promisify: {\n    custom: kCustomPromisifiedSymbol\x2C\n  }\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n  defineLazyProperties\x2C\n} = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\nlet kResistStopPropagation;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nconst showStringCoercionDeprecation = deprecate(\n  () => {}\x2C\n  'Implicit coercion of objects with own toString property is deprecated.'\x2C\n  'DEP0162'\x2C\n);\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C kCustomPromisifiedSymbol\x2C {\n  __proto__: null\x2C\n  value: function exists(path) { // eslint-disable-line func-name-matching\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\x2C\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // TODO(BridgeAR): Check if allocating a smaller chunk is better performance\n  // wise\x2C similar to the promise based version (less peak memory and chunked\n  // stringify operations vs multiple C++/JS boundary crossings).\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      // TODO(BridgeAR): If an encoding is set\x2C use the StringDecoder to concat\n      // the result and reuse the buffer instead of allocating a new one.\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const ReadFileContext = require('internal/fs/read_file_context');\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offsetOrOptions\n * @param {number} length\n * @param {number | bigint | null} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  let params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4) {\n      // This is fs.read(fd\x2C buffer\x2C options\x2C callback)\n      validateObject(offsetOrOptions\x2C 'options'\x2C { nullable: true });\n      callback = length;\n      params = offsetOrOptions;\n    } else if (arguments.length === 3) {\n      // This is fs.read(fd\x2C bufferOrParams\x2C callback)\n      if (!isArrayBufferView(buffer)) {\n        // This is fs.read(fd\x2C params\x2C callback)\n        params = buffer;\n        ({ buffer = Buffer.alloc(16384) } = params ?? kEmptyObject);\n      }\n      callback = offsetOrOptions;\n    } else {\n      // This is fs.read(fd\x2C callback)\n      callback = buffer;\n      buffer = Buffer.alloc(16384);\n    }\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = params ?? kEmptyObject);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint | null;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.readSync(fd\x2C buffer\x2C options)\n    const options = offset || kEmptyObject;\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number | object} [offsetOrOptions]\n * @param {number} [length]\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  if (typeof buffer !== 'string') {\n    showStringCoercionDeprecation();\n  }\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | null;\n *   }} [offsetOrOptions]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C kCustomPromisifyArgsSymbol\x2C {\n  __proto__: null\x2C\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\x2C\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * An iterative algorithm for reading the entire contents of the `basePath` directory.\n * This function does not validate `basePath` as a directory. It is passed directly to\n * `binding.readdir`.\n * @param {string} basePath\n * @param {{ encoding: string\x2C withFileTypes: boolean }} options\n * @returns {string[] | Dirent[]}\n */\nfunction readdirSyncRecursive(basePath\x2C options) {\n  const withFileTypes = Boolean(options.withFileTypes);\n  const encoding = options.encoding;\n\n  const readdirResults = [];\n  const pathsQueue = [basePath];\n\n  const ctx = { path: basePath };\n  function read(path) {\n    ctx.path = path;\n    const readdirResult = binding.readdir(\n      pathModule.toNamespacedPath(path)\x2C\n      encoding\x2C\n      withFileTypes\x2C\n      undefined\x2C\n      ctx\x2C\n    );\n    handleErrorFromBinding(ctx);\n\n    if (withFileTypes) {\n      // Calling `readdir` with `withFileTypes=true`\x2C the result is an array of arrays.\n      // The first array is the names\x2C and the second array is the types.\n      // They are guaranteed to be the same length; hence\x2C setting `length` to the length\n      // of the first array within the result.\n      const length = readdirResult[0].length;\n      for (let i = 0; i < length; i++) {\n        const dirent = getDirent(path\x2C readdirResult[0][i]\x2C readdirResult[1][i]);\n        ArrayPrototypePush(readdirResults\x2C dirent);\n        if (dirent.isDirectory()) {\n          ArrayPrototypePush(pathsQueue\x2C pathModule.join(dirent.path\x2C dirent.name));\n        }\n      }\n    } else {\n      for (let i = 0; i < readdirResult.length; i++) {\n        const resultPath = pathModule.join(path\x2C readdirResult[i]);\n        const relativeResultPath = pathModule.relative(basePath\x2C resultPath);\n        const stat = binding.internalModuleStat(resultPath);\n        ArrayPrototypePush(readdirResults\x2C relativeResultPath);\n        // 1 indicates directory\n        if (stat === 1) {\n          ArrayPrototypePush(pathsQueue\x2C resultPath);\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < pathsQueue.length; i++) {\n    read(pathsQueue[i]);\n  }\n\n  return readdirResults;\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    callback(null\x2C readdirSyncRecursive(path\x2C options));\n    return;\n  }\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   recursive?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive != null) {\n    validateBoolean(options.recursive\x2C 'options.recursive');\n  }\n\n  if (options.recursive) {\n    return readdirSyncRecursive(path\x2C options);\n  }\n\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction statfs(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = maybeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = (err\x2C stats) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(err\x2C getStatFsFromBinding(stats));\n  };\n  binding.statfs(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\nfunction statfsSync(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.statfs(pathModule.toNamespacedPath(path)\x2C\n                               options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatFsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options);\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n\n  const watchers = require('internal/fs/watchers');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n      options.signal.addEventListener('abort'\x2C listener\x2C { __proto__: null\x2C [kResistStopPropagation]: true });\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\x2C\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n  const watchers = require('internal/fs/watchers');\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n  const watchers = require('internal/fs/watchers');\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return SideEffectFreeRegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard.add(base);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base) || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard.add(base);\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks.has(id)) {\n          linkTarget = seenLinks.get(id);\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks.set(id\x2C linkTarget);\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard.add(base);\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard.has(base)) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard.add(base);\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base)) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard.add(base);\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks.has(id)) {\n        return gotTarget(null\x2C seenLinks.get(id));\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks.set(id\x2C target);\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard.add(base);\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string | Buffer | URL} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n\n  prefix = getValidatedPath(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n\n  let path;\n  if (typeof prefix === 'string') {\n    path = `${prefix}XXXXXX`;\n  } else {\n    path = Buffer.concat([prefix\x2C Buffer.from('XXXXXX')]);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(path\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string | Buffer | URL} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options);\n\n  prefix = getValidatedPath(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n\n  let path;\n  if (typeof prefix === 'string') {\n    path = `${prefix}XXXXXX`;\n  } else {\n    path = Buffer.concat([prefix\x2C Buffer.from('XXXXXX')]);\n  }\n\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 KiB.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statfs\x2C\n  statSync\x2C\n  statfsSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\x2C\n};\n\ndefineLazyProperties(\n  fs\x2C\n  'internal/fs/dir'\x2C\n  ['Dir'\x2C 'opendir'\x2C 'opendirSync']\x2C\n);\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { __proto__: null\x2C enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { __proto__: null\x2C enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { __proto__: null\x2C enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { __proto__: null\x2C enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  promises: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x3a1b5d325cc0,59,69615,73506,C0O69632C6O69642C12O69665C18O69669C24O69691C28O69724C38O69739C44O69739C48O69758C54O69773C60O69773C67O69802C69O69810C71O69809C75O69857C79O69862C85O69864C94O69874C96O69903C98O69928C99O69954C105O69954C111O69989C117O69989C123O70023C126O70070C128O70145C130O70240C132O70316C134O70350C140O70367C146O70397C151O70479C157O70512C165O70520C172O70532C178O70540C186O70546C190O70557C196O70557C212O70540C217O70609C223O70609C227O70652C233O70652C238O70795C242O70791C247O70850C253O70850C259O70872C262O70896C264O70907C269O70936C275O70936C282O70972C284O70983C291O70995C293O71011C297O71033C304O71060C306O71071C312O71107C323O71071C335O71119C337O71137C350O71137C355O71135C359O71181C361O71194C365O71281C371O71281C385O71299C391O71301C403O71311C408O71329C414O71344C418O71352C426O71364C430O71333C443O71397C447O71405C455O71417C459O71386C466O71438C468O71459C470O71484C472O71530C479O71535C485O71537C494O71552C496O71585C503O71767C509O71778C515O71778C521O71820C529O71828C536O71856C542O71864C560O71864C566O71909C572O71909C576O71945C582O71968C586O71950C593O71998C599O71998C604O72017C611O72022C617O72024C626O72049C628O72203C631O72219C634O72229C640O72267C647O72296C656O72267C663O72326C671O72355C680O72326C687O72373C701O72388C707O72417C713O72417C720O72461C726O72461C733O72494C737O72541C745O72549C752O72565C758O72573C776O72573C781O72620C787O72620C791O72657C797O72678C815O72678C822O72733C828O72733C832O72776C838O72802C844O72802C851O72840C858O72845C864O72847C873O72878C879O72904C885O72904C891O72977C897O72992C905O73014C909O73014C916O72992C924O73073C930O73090C936O73122C941O73208C947O73236C953O73236C960O73267C968O73275C975O73289C981O73297C989O73303C993O73314C999O73314C1015O73297C1020O73368C1026O73368C1030O73413C1036O73413C1041O70780C1047O73437C1054O73442C1060O73444C1069O73464C1073O73471C1078O73504,,
tick,0x106e5a6,39618,0,0x0,3,0x12da7b0,0x3a1b5d3255e3,0x3a1b5d324e6f,0x3a1b5d3246dc,0x3a1b5d323ef9,0x3a1b5d305600
tick,0x7f6e64f82f76,39624,0,0x0,3,0x12da7b0,0x3a1b5d3255e3,0x3a1b5d324e6f,0x3a1b5d3246dc,0x3a1b5d323ef9,0x3a1b5d305600
code-creation,LazyCompile,10,39683,0x3a1b5d32c978,135,getOptions node:internal/fs/utils:326:20,0x1d7bd0ec96d0,~
script-source,60,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  MathMin\x2C\n  MathRound\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  Symbol\x2C\n  TypedArrayPrototypeAt\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n  hideStackFrames\x2C\n  uvException\x2C\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isBigInt64Array\x2C\n  isDate\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\x2C\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\x2C\n    }\x2C\n  }\x2C\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\x2C\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GiB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type\x2C path\x2C filepath = path && join(path\x2C name)) {\n    this.name = name;\n    this.parentPath = path;\n    this.path = filepath;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats\x2C path\x2C filepath) {\n    super(name\x2C null\x2C path\x2C filepath);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats\x2C path\x2C filepath);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]\x2C path);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats\x2C path\x2C filepath));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type\x2C path));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const filepath = join(path\x2C name);\n    const stats = lazyLoadFs().lstatSync(filepath);\n    // callback === true: Quirk to not introduce a breaking change.\n    return new DirentFromStats(name\x2C stats\x2C path\x2C callback === true ? filepath : path);\n  } else if (callback === true) {\n    // callback === true: Quirk to not introduce a breaking change.\n    return new Dirent(name\x2C type\x2C path);\n  } else {\n    return new Dirent(name\x2C type\x2C path\x2C path);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions = kEmptyObject) {\n  if (options == null || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\x2C\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return RegExpPrototypeSymbolReplace(/\\//g\x2C path\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() on the absolute value\n// of the timestamp: https://tc39.es/ecma262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\n// Refs: https://github.com/nodejs/node/pull/43714\nfunction dateFromMs(ms) {\n  // Coercing to number\x2C ms can be bigint\n  return new Date(MathRound(Number(ms)));\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigInt64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigInt64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\x2C\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\x2C\n  );\n}\n\nclass StatFs {\n  constructor(type\x2C bsize\x2C blocks\x2C bfree\x2C bavail\x2C files\x2C ffree) {\n    this.type = type;\n    this.bsize = bsize;\n    this.blocks = blocks;\n    this.bfree = bfree;\n    this.bavail = bavail;\n    this.files = files;\n    this.ffree = ffree;\n  }\n}\n\nfunction getStatFsFromBinding(stats) {\n  return new StatFs(\n    stats[0]\x2C stats[1]\x2C stats[2]\x2C stats[3]\x2C stats[4]\x2C stats[5]\x2C stats[6]\x2C\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\x2C\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\x2C\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn &&\n    ((typeof template === 'string' && StringPrototypeEndsWith(template\x2C 'X')) ||\n    (typeof template !== 'string' && TypedArrayPrototypeAt(template\x2C -1) === 0x58))) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  options.mode = getValidMode(options.mode\x2C 'copyFile');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .lstatSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\x2C\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\x2C\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  validateInteger(mode\x2C 'mode'\x2C min\x2C max);\n  return mode;\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\x2C\n  );\n});\n\nconst validatePrimitiveStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      buffer\x2C\n    );\n  }\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C name);\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C ['integer'\x2C 'bigint']\x2C position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n};\n
code-source-info,0x3a1b5d32c978,60,7774,8381,C9O7801C16O7819C27O7879C29O7901C30O7909C36O7948C41O7992C43O8016C47O8031C54O8066C60O8105C78O8111C83O8105C84O8198C91O8207C96O8225C99O8248C104O8225C108O8274C114O8302C119O8330C127O8302C132O8364C134O8379,,
tick,0x7f6e64f82f76,40448,0,0x0,3,0x12da7b0,0x3a1b5d325cc6,0x3a1b5d3255e3,0x3a1b5d324e6f,0x3a1b5d3246dc,0x3a1b5d323ef9,0x3a1b5d305600
code-creation,LazyCompile,10,40466,0x3a1b5d32ea38,48,assertEncoding node:internal/fs/utils:156:24,0x1d7bd0ec91a8,~
code-source-info,0x3a1b5d32ea38,60,3613,3790,C0O3628C6O3645C9O3652C14O3652C21O3695C24O3722C40O3728C45O3722C47O3789,,
code-creation,LazyCompile,10,40543,0x3a1b5d32eb50,20,toPathIfFileURL node:internal/url:1565:25,0x23f41f7bdf38,~
script-source,45,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  Int8Array\x2C\n  IteratorPrototype\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\x2C\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\x2C\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst bindingUrl = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst FORWARD_SLASH = /\\//g;\n\nconst context = Symbol('context');\nconst searchParams = Symbol('query');\n\n/**\n * We cannot use private fields without a breaking change\x2C so a WeakMap is the alternative.\n * @type {WeakMap<URL\x2CURLSearchParams>}\n */\nconst internalSearchParams = new SafeWeakMap();\n\n// `unsafeProtocol`\x2C `hostlessProtocol` and `slashedProtocol` is\n// deliberately moved to `internal/url` rather than `url`.\n// Workers does not bootstrap URL module. Therefore\x2C `SafeSet`\n// is not initialized on bootstrap. This case breaks the\n// test-require-delete-array-iterator test.\n\n// Protocols that can allow "unsafe" and "unwise" chars.\nconst unsafeProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that never have a hostname.\nconst hostlessProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that always contain a // bit.\nconst slashedProtocol = new SafeSet([\n  'http'\x2C\n  'http:'\x2C\n  'https'\x2C\n  'https:'\x2C\n  'ftp'\x2C\n  'ftp:'\x2C\n  'gopher'\x2C\n  'gopher:'\x2C\n  'file'\x2C\n  'file:'\x2C\n  'ws'\x2C\n  'ws:'\x2C\n  'wss'\x2C\n  'wss:'\x2C\n]);\n\nconst updateActions = {\n  kProtocol: 0\x2C\n  kHost: 1\x2C\n  kHostname: 2\x2C\n  kPort: 3\x2C\n  kUsername: 4\x2C\n  kPassword: 5\x2C\n  kPathname: 6\x2C\n  kSearch: 7\x2C\n  kHash: 8\x2C\n  kHref: 9\x2C\n};\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  // This is the maximum value uint32_t can get.\n  // Ada uses uint32_t(-1) for declaring omitted values.\n  static #omitted = 4294967295;\n\n  href = '';\n  protocol_end = 0;\n  username_end = 0;\n  host_start = 0;\n  host_end = 0;\n  pathname_start = 0;\n  search_start = 0;\n  hash_start = 0;\n  port = 0;\n  /**\n   * Refers to `ada::scheme::type`\n   *\n   * enum type : uint8_t {\n   *   HTTP = 0\x2C\n   *   NOT_SPECIAL = 1\x2C\n   *   HTTPS = 2\x2C\n   *   WS = 3\x2C\n   *   FTP = 4\x2C\n   *   WSS = 5\x2C\n   *   FILE = 6\n   * };\n   * @type {number}\n   */\n  scheme_type = 1;\n\n  get hasPort() {\n    return this.port !== URLContext.#omitted;\n  }\n\n  get hasSearch() {\n    return this.search_start !== URLContext.#omitted;\n  }\n\n  get hasHash() {\n    return this.hash_start !== URLContext.#omitted;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self?.[searchParams];\n}\n\nclass URLSearchParams {\n  [searchParams] = [];\n\n  // "associated url object"\n  [context] = null;\n\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init == null) {\n      // Do nothing\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method != null) {\n        // Sequence<sequence<USVString>>\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // The following implementationd differs from the URL specification:\n        // Sequences must first be converted from ECMAScript objects before\n        // and operations are done on them\x2C and the operation of converting\n        // the sequences would first exhaust the iterators. If the iterator\n        // returns something invalid in the middle\x2C whether it would be called\n        // after that would be an observable change to the users.\n        // Exhausting the iterator and later converting them to USVString comes\n        // with a significant cost (~40-80%). In order optimize URLSearchParams\n        // creation duration\x2C Node.js merges the iteration and converting\n        // iterations into a single iteration.\n        for (const pair of init) {\n          if (pair == null) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          } else if (ArrayIsArray(pair)) {\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (pair.length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n            // Append (innerSequence[0]\x2C innerSequence[1]) to querys list.\n            ArrayPrototypePush(this[searchParams]\x2C toUSVString(pair[0])\x2C toUSVString(pair[1]));\n          } else {\n            if (((typeof pair !== 'object' && typeof pair !== 'function') ||\n                typeof pair[SymbolIterator] !== 'function')) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n\n            let length = 0;\n\n            for (const element of pair) {\n              length++;\n              ArrayPrototypePush(this[searchParams]\x2C toUSVString(element));\n            }\n\n            // If innerSequence's size is not 2\x2C then throw a TypeError.\n            if (length !== 2) {\n              throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n            }\n          }\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = new SafeMap();\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different keys may become the same USVString after normalization.\n            // In that case\x2C we retain the later one. Refer to WPT.\n            const keyIdx = visited.get(typedKey);\n            if (keyIdx !== undefined) {\n              this[searchParams][keyIdx] = typedValue;\n            } else {\n              visited.set(typedKey\x2C ArrayPrototypePush(this[searchParams]\x2C\n                                                       typedKey\x2C\n                                                       typedValue) - 1);\n            }\n          }\n        }\n      }\n    } else {\n      // https://url.spec.whatwg.org/#dom-urlsearchparams-urlsearchparams\n      init = toUSVString(init);\n      this[searchParams] = init ? parseParams(init) : [];\n    }\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\x2C\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  get size() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n    return this[searchParams].length / 2;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  delete(name\x2C value = undefined) {\n    if (typeof this !== 'object' || this === null || !isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n\n    if (value !== undefined) {\n      value = toUSVString(value);\n      for (let i = 0; i < list.length;) {\n        if (list[i] === name && list[i + 1] === value) {\n          list.splice(i\x2C 2);\n        } else {\n          i += 2;\n        }\n      }\n    } else {\n      for (let i = 0; i < list.length;) {\n        if (list[i] === name) {\n          list.splice(i\x2C 2);\n        } else {\n          i += 2;\n        }\n      }\n    }\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name\x2C value = undefined) {\n    if (typeof this !== 'object' || this === null || !isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n\n    if (value !== undefined) {\n      value = toUSVString(value);\n    }\n\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        if (value === undefined || list[i + 1] === value) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    if (this[context]) {\n      this[context].search = this.toString();\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateFunction(callback\x2C 'callback');\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\n/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron)\x2C so instead we are\n * checking some well known properties for a lack of a better test.\n * @param {*} self\n * @returns {self is URL}\n */\nfunction isURL(self) {\n  return self != null && ObjectPrototypeHasOwnProperty(self\x2C context);\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    if (arguments.length === 0) {\n      throw new ERR_MISSING_ARGS('url');\n    }\n\n    // toUSVString is not needed.\n    input = `${input}`;\n    this[context] = new URLContext();\n\n    if (base !== undefined) {\n      base = `${base}`;\n    }\n\n    const href = bindingUrl.parse(input\x2C base);\n\n    if (!href) {\n      throw new ERR_INVALID_URL(input);\n    }\n\n    this.#updateContext(href);\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  #updateContext(href) {\n    const ctx = this[context];\n    ctx.href = href;\n\n    const {\n      0: protocol_end\x2C\n      1: username_end\x2C\n      2: host_start\x2C\n      3: host_end\x2C\n      4: port\x2C\n      5: pathname_start\x2C\n      6: search_start\x2C\n      7: hash_start\x2C\n      8: scheme_type\x2C\n    } = bindingUrl.urlComponents;\n\n    ctx.protocol_end = protocol_end;\n    ctx.username_end = username_end;\n    ctx.host_start = host_start;\n    ctx.host_end = host_end;\n    ctx.port = port;\n    ctx.pathname_start = pathname_start;\n    ctx.search_start = search_start;\n    ctx.hash_start = hash_start;\n    ctx.scheme_type = scheme_type;\n\n    const alreadyInstantiatedSearchParams = internalSearchParams.get(this);\n    if (alreadyInstantiatedSearchParams) {\n      if (ctx.hasSearch) {\n        alreadyInstantiatedSearchParams[searchParams] = parseParams(this.search);\n      } else {\n        alreadyInstantiatedSearchParams[searchParams] = [];\n      }\n    }\n  }\n\n  toString() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  get href() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  set href(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    value = `${value}`;\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHref\x2C value);\n    if (!href) { throw ERR_INVALID_URL(value); }\n    this.#updateContext(href);\n  }\n\n  // readonly\n  get origin() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    const protocol = StringPrototypeSlice(ctx.href\x2C 0\x2C ctx.protocol_end);\n\n    // Check if scheme_type is not `NOT_SPECIAL`\n    if (ctx.scheme_type !== 1) {\n      // Check if scheme_type is `FILE`\n      if (ctx.scheme_type === 6) {\n        return 'null';\n      }\n      return `${protocol}//${this.host}`;\n    }\n\n    if (protocol === 'blob:') {\n      const path = this.pathname;\n      if (path.length > 0) {\n        try {\n          const out = new URL(path);\n          // Only return origin of scheme is `http` or `https`\n          // Otherwise return a new opaque origin (null).\n          if (out[context].scheme_type === 0 || out[context].scheme_type === 2) {\n            return `${out.protocol}//${out.host}`;\n          }\n        } catch {\n          // Do nothing.\n        }\n      }\n    }\n\n    return 'null';\n  }\n\n  get protocol() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return StringPrototypeSlice(this[context].href\x2C 0\x2C this[context].protocol_end);\n  }\n\n  set protocol(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kProtocol\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get username() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (ctx.protocol_end + 2 < ctx.username_end) {\n      return StringPrototypeSlice(ctx.href\x2C ctx.protocol_end + 2\x2C ctx.username_end);\n    }\n    return '';\n  }\n\n  set username(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kUsername\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get password() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (ctx.host_start - ctx.username_end > 0) {\n      return StringPrototypeSlice(ctx.href\x2C ctx.username_end + 1\x2C ctx.host_start);\n    }\n    return '';\n  }\n\n  set password(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPassword\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get host() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let startsAt = ctx.host_start;\n    if (ctx.href[startsAt] === '@') {\n      startsAt++;\n    }\n    // If we have an empty host\x2C then the space between components.host_end and\n    // components.pathname_start may be occupied by /.\n    if (startsAt === ctx.host_end) {\n      return '';\n    }\n    return StringPrototypeSlice(ctx.href\x2C startsAt\x2C ctx.pathname_start);\n  }\n\n  set host(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHost\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get hostname() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let startsAt = ctx.host_start;\n    // host_start might be "@" if the URL has credentials\n    if (ctx.href[startsAt] === '@') {\n      startsAt++;\n    }\n    return StringPrototypeSlice(ctx.href\x2C startsAt\x2C ctx.host_end);\n  }\n\n  set hostname(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHostname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get port() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    if (this[context].hasPort) {\n      return `${this[context].port}`;\n    }\n    return '';\n  }\n\n  set port(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPort\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get pathname() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let endsAt;\n    if (ctx.hasSearch) {\n      endsAt = ctx.search_start;\n    } else if (ctx.hasHash) {\n      endsAt = ctx.hash_start;\n    }\n    return StringPrototypeSlice(ctx.href\x2C ctx.pathname_start\x2C endsAt);\n  }\n\n  set pathname(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kPathname\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  get search() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (!ctx.hasSearch) { return ''; }\n    let endsAt = ctx.href.length;\n    if (ctx.hasHash) { endsAt = ctx.hash_start; }\n    if (endsAt - ctx.search_start <= 1) { return ''; }\n    return StringPrototypeSlice(ctx.href\x2C ctx.search_start\x2C endsAt);\n  }\n\n  set search(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kSearch\x2C toUSVString(value));\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  // readonly\n  get searchParams() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n\n    const cachedValue = internalSearchParams.get(this);\n    if (cachedValue != null)\n      return cachedValue;\n\n    const value = new URLSearchParams(this.search);\n    value[context] = this;\n    internalSearchParams.set(this\x2C value);\n    return value;\n  }\n\n  get hash() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (!ctx.hasHash || (ctx.href.length - ctx.hash_start <= 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(ctx.href\x2C ctx.hash_start);\n  }\n\n  set hash(value) {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    const href = bindingUrl.update(this[context].href\x2C updateActions.kHash\x2C `${value}`);\n    if (href) {\n      this.#updateContext(href);\n    }\n  }\n\n  toJSON() {\n    if (!isURL(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].href;\n  }\n\n  static canParse(url\x2C base = undefined) {\n    if (arguments.length === 0) {\n      throw new ERR_MISSING_ARGS('url');\n    }\n\n    url = `${url}`;\n\n    if (base !== undefined) {\n      base = `${base}`;\n    }\n\n    return bindingUrl.canParse(url\x2C base);\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      // TODO(@anonrig): Remove this try/catch by calling `parse` directly.\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nObjectDefineProperties(URL\x2C {\n  canParse: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n  }\x2C\n  createObjectURL: kEnumerableProperty\x2C\n  revokeObjectURL: kEnumerableProperty\x2C\n});\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i = qs[0] === '?' ? 1 : 0;\n  let pairStart = i;\n  let lastPos = i;\n  for (; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\x2C\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\x2C\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\x2C\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\x2C\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\x2C\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\x2C\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\x2C\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\x2C\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\x2C\n    );\n    const breakLn = StringPrototypeIncludes(inspect(output\x2C innerOpts)\x2C '\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\x2C\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return bindingUrl.domainToUnicode(`${domain}`);\n}\n\n/**\n * Utility function that converts a URL object into an ordinary options object\n * as expected by the `http.request` and `https.request` APIs.\n * @param {URL} url\n * @returns {Record<string\x2C unknown>}\n */\nfunction urlToHttpOptions(url) {\n  const { hostname\x2C pathname\x2C port\x2C username\x2C password\x2C search } = url;\n  const options = {\n    __proto__: null\x2C\n    ...url\x2C // In case the url object was extended by the user.\n    protocol: url.protocol\x2C\n    hostname: hostname && StringPrototypeStartsWith(hostname\x2C '[') ?\n      StringPrototypeSlice(hostname\x2C 1\x2C -1) :\n      hostname\x2C\n    hash: url.hash\x2C\n    search: search\x2C\n    pathname: pathname\x2C\n    path: `${pathname || ''}${search || ''}`\x2C\n    href: url.href\x2C\n  };\n  if (port !== '') {\n    options.port = Number(port);\n  }\n  if (username || password) {\n    options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\x2C\n        );\n      }\n    }\n  }\n  pathname = SideEffectFreeRegExpPrototypeSymbolReplace(FORWARD_SLASH\x2C pathname\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = StringPrototypeCodePointAt(pathname\x2C 1) | 0x20;\n  const sep = StringPrototypeCharAt(pathname\x2C 2);\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return StringPrototypeSlice(pathname\x2C 1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = StringPrototypeCodePointAt(pathname\x2C n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\x2C\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURL(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\nconst questionRegex = /\\?/g;\nconst hashRegex = /#/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIndexOf(filepath\x2C '%') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(percentRegEx\x2C filepath\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIndexOf(filepath\x2C '\\\\') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(backslashRegEx\x2C filepath\x2C '%5C');\n  if (StringPrototypeIndexOf(filepath\x2C '\\n') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(newlineRegEx\x2C filepath\x2C '%0A');\n  if (StringPrototypeIndexOf(filepath\x2C '\\r') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(carriageReturnRegEx\x2C filepath\x2C '%0D');\n  if (StringPrototypeIndexOf(filepath\x2C '\\t') !== -1)\n    filepath = RegExpPrototypeSymbolReplace(tabRegEx\x2C filepath\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    const outURL = new URL('file://');\n    // UNC path format: \\\\server\\share\\resource\n    const hostnameEndIndex = StringPrototypeIndexOf(filepath\x2C '\\\\'\x2C 2);\n    if (hostnameEndIndex === -1) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'path'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\x2C\n      );\n    }\n    if (hostnameEndIndex === 2) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'path'\x2C\n        filepath\x2C\n        'Empty UNC servername'\x2C\n      );\n    }\n    const hostname = StringPrototypeSlice(filepath\x2C 2\x2C hostnameEndIndex);\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      RegExpPrototypeSymbolReplace(backslashRegEx\x2C StringPrototypeSlice(filepath\x2C hostnameEndIndex)\x2C '/'));\n    return outURL;\n  }\n  let resolved = path.resolve(filepath);\n  // path.resolve strips trailing slashes so we must add them back\n  const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                 filepath.length - 1);\n  if ((filePathLast === CHAR_FORWARD_SLASH ||\n       (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n      resolved[resolved.length - 1] !== path.sep)\n    resolved += '/';\n\n  // Call encodePathChars first to avoid encoding % again for ? and #.\n  resolved = encodePathChars(resolved);\n\n  // Question and hash character should be included in pathname.\n  // Therefore\x2C encoding is required to eliminate parsing them in different states.\n  // This is done as an optimization to not creating a URL instance and\n  // later triggering pathname setter\x2C which impacts performance\n  if (StringPrototypeIndexOf(resolved\x2C '?') !== -1)\n    resolved = RegExpPrototypeSymbolReplace(questionRegex\x2C resolved\x2C '%3F');\n  if (StringPrototypeIndexOf(resolved\x2C '#') !== -1)\n    resolved = RegExpPrototypeSymbolReplace(hashRegex\x2C resolved\x2C '%23');\n  return new URL(`file://${resolved}`);\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURL(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  encodeStr\x2C\n  isURL\x2C\n\n  urlUpdateActions: updateActions\x2C\n  unsafeProtocol\x2C\n  hostlessProtocol\x2C\n  slashedProtocol\x2C\n};\n
code-source-info,0x3a1b5d32eb50,45,43965,44078,C0O43985C3O43990C9O44016C11O44037C12O44040C15O44047C19O44076,,
tick,0x7f6e65373fda,41731,0,0x0,3,0x12da7b0,0x3a1b5d325cd2,0x3a1b5d3255e3,0x3a1b5d324e6f,0x3a1b5d3246dc,0x3a1b5d323ef9,0x3a1b5d305600
code-creation,LazyCompile,10,41743,0x3a1b5d331e20,22,isURL node:internal/url:655:15,0x32bbd747fb48,~
code-source-info,0x3a1b5d331e20,45,17733,17814,C0O17744C3O17756C8O17767C13O17803C16O17767C21O17812,,
code-creation,LazyCompile,10,41780,0x3a1b5d331f90,81, node:internal/fs/utils:700:38,0x1d7bd0eca170,~
code-source-info,0x3a1b5d331f90,60,19212,19482,C14O19245C22O19278C25O19278C31O19304C36O19335C49O19310C54O19304C55O19400C68O19400C74O19437C76O19466C78O19466C80O19481,,
code-creation,LazyCompile,10,41812,0x3a1b5d3321a8,110, node:internal/fs/utils:369:35,0x1d7bd0ec9770,~
code-source-info,0x3a1b5d3321a8,60,9109,9699,C16O9173C21O9226C26O9226C31O9320C37O9343C41O9371C45O9388C51O9388C60O9439C64O9460C69O9460C76O9505C77O9512C78O9532C94O9532C100O9647C104O9669C106O9669C107O9686C109O9697,,
code-creation,LazyCompile,10,41839,0x3a1b5d332320,16,isUint8Array node:internal/util/types:13:22,0x28d42e28b7e0,~
script-source,23,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\x2C\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\x2C\n  }\x2C\n  isCryptoKey: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\x2C\n  }\x2C\n});\n
code-source-info,0x3a1b5d332320,23,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,41941,0x3a1b5d3327a8,61,splitRoot node:fs:2533:33,0x13800b178ee0,~
code-source-info,0x3a1b5d3327a8,59,68455,68647,C0O68480C2O68491C6O68485C11O68512C16O68516C24O68554C26O68550C31O68582C44O68589C49O68621C50O68501C55O68467C58O68632C60O68643,,
code-creation,LazyCompile,10,41964,0x3a1b5d3328e0,20,nextPart node:fs:2566:31,0x13800b178f80,~
code-source-info,0x3a1b5d3328e0,59,69362,69420,C0O69375C14O69382C19O69416,,
code-creation,LazyCompile,10,42006,0x3a1b5d332a68,63,handleErrorFromBinding node:internal/fs/utils:352:32,0x1d7bd0ec9720,~
code-source-info,0x3a1b5d332a68,60,8470,8968,C0O8488C6O8551C11O8551C16O8573C24O8573C29O8630C31O8630C32O8655C38O8883C43O8910C51O8883C56O8956C60O8946C62O8967,,
code-creation,LazyCompile,10,42031,0x3a1b5d332bb8,34,isFileType node:fs:209:20,0x13800b1771c8,~
code-source-info,0x3a1b5d332bb8,59,5299,5540,C0O5433C2O5438C6O5445C10O5479C15O5486C20O5502C22O5517C24O5515C30O5525C33O5538,,
code-creation,LazyCompile,10,42096,0x3a1b5d332e10,72,encodeRealpathResult node:fs:2542:30,0x13800b178f30,~
code-source-info,0x3a1b5d332e10,59,68681,68939,C0O68703C4O68728C10O68748C17O68757C22O68773C24O68787C25O68807C30O68814C35O68814C41O68842C48O68851C53O68871C55O68887C56O68910C61O68927C66O68910C71O68937,,
code-creation,LazyCompile,10,42162,0x3a1b5d333120,198,shouldUseESMLoader node:internal/modules/run_main:51:28,0x1d7bd0ef5198,~
code-source-info,0x3a1b5d333120,70,1603,2864,C0O1618C8O1622C15O1668C20O1684C21O1696C22O1872C30O1872C35O2088C43O2088C48O2134C54O2141C59O2160C65O2167C70O2178C71O2190C72O2237C80O2237C85O2294C87O2326C92O2344C93O2356C94O2416C100O2432C106O2432C113O2477C114O2489C115O2494C121O2511C127O2511C134O2556C135O2569C136O2604C142O2604C147O2583C152O2667C157O2776C164O2780C174O2787C181O2803C187O2803C194O2849C197O2862,,
code-creation,LazyCompile,10,42212,0x3a1b5d333448,133,readPackageScope node:internal/modules/package_json_reader:148:26,0x1d7bd0ee6bd0,~
script-source,65,node:internal/modules/package_json_reader,'use strict';\n\nconst {\n  JSONParse\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst {\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n} = require('internal/errors').codes;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { resolve\x2C sep\x2C toNamespacedPath } = require('path');\nconst { kEmptyObject } = require('internal/util');\n\nconst { fileURLToPath\x2C pathToFileURL } = require('internal/url');\n\nconst cache = new SafeMap();\nconst isAIX = process.platform === 'aix';\n\nlet manifest;\n\n/**\n * @typedef {{\n *   exists: boolean\x2C\n *   pjsonPath: string\x2C\n *   exports?: string | string[] | Record<string\x2C unknown>\x2C\n *   imports?: string | string[] | Record<string\x2C unknown>\x2C\n *   name?: string\x2C\n *   main?: string\x2C\n *   type: 'commonjs' | 'module' | 'none'\x2C\n * }} PackageConfig\n */\n\n/**\n * @param {string} jsonPath\n * @param {{\n *   base?: string\x2C\n *   specifier: string\x2C\n *   isESM: boolean\x2C\n * }} options\n * @returns {PackageConfig}\n */\nfunction read(jsonPath\x2C { base\x2C specifier\x2C isESM } = kEmptyObject) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const {\n    0: string\x2C\n    1: containsKeys\x2C\n  } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\x2C\n  );\n  const result = {\n    __proto__: null\x2C\n    exists: false\x2C\n    pjsonPath: jsonPath\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C // Ignore unknown types for forwards compatibility\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n\n  // Folder read operation succeeds in AIX.\n  // For libuv change\x2C see https://github.com/libuv/libuv/pull/2025.\n  // https://github.com/nodejs/node/pull/48477#issuecomment-1604586650\n  // TODO(anonrig): Follow-up on this change and remove it since it is a\n  // semver-major change.\n  const isResultValid = isAIX && !isESM ? containsKeys : string !== undefined;\n\n  if (isResultValid) {\n    let parsed;\n    try {\n      parsed = JSONParse(string);\n    } catch (error) {\n      if (isESM) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          jsonPath\x2C\n          (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n          error.message\x2C\n        );\n      } else {\n        // For backward compat\x2C we modify the error returned by JSON.parse rather than creating a new one.\n        // TODO(aduh95): make it throw ERR_INVALID_PACKAGE_CONFIG in a semver-major with original error as cause\n        error.message = 'Error parsing ' + jsonPath + ': ' + error.message;\n        error.path = jsonPath;\n        throw error;\n      }\n    }\n\n    result.exists = true;\n\n    // ObjectPrototypeHasOwnProperty is used to avoid prototype pollution.\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'name') && typeof parsed.name === 'string') {\n      result.name = parsed.name;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'main') && typeof parsed.main === 'string') {\n      result.main = parsed.main;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'exports')) {\n      result.exports = parsed.exports;\n    }\n\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'imports')) {\n      result.imports = parsed.imports;\n    }\n\n    // Ignore unknown types for forwards compatibility\n    if (ObjectPrototypeHasOwnProperty(parsed\x2C 'type') && (parsed.type === 'commonjs' || parsed.type === 'module')) {\n      result.type = parsed.type;\n    }\n\n    if (manifest === undefined) {\n      const { getOptionValue } = require('internal/options');\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\n/**\n * @param {string} requestPath\n * @return {PackageConfig}\n */\nfunction readPackage(requestPath) {\n  return read(resolve(requestPath\x2C 'package.json'));\n}\n\n/**\n * Get the nearest parent package.json file from a given path.\n * Return the package.json data and the path to the package.json file\x2C or false.\n * @param {string} checkPath The path to start searching from.\n */\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules')) {\n      return false;\n    }\n    const pjson = readPackage(checkPath + sep);\n    if (pjson.exists) {\n      return {\n        data: pjson\x2C\n        path: checkPath\x2C\n      };\n    }\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nmodule.exports = {\n  read\x2C\n  readPackage\x2C\n  readPackageScope\x2C\n};\n
code-source-info,0x3a1b5d333448,65,4203,4756,C0O4246C7O4280C10O4246C16O4292C18O4319C25O4374C28O4336C34O4384C47O4396C54O4452C61O4491C66O4495C70O4456C77O4522C78O4535C79O4560C84O4584C86O4582C90O4560C95O4604C101O4620C108O4643C114O4664C120O4683C121O4716C123O4716C128O4310C131O4741C132O4754,,
tick,0x7f6e64f82f76,42405,0,0x0,3,0x12da7b0,0x3a1b5d3331b8,0x3a1b5d323f01,0x3a1b5d305600
code-creation,LazyCompile,10,42418,0x3a1b5d333b90,22,readPackage node:internal/modules/package_json_reader:139:21,0x1d7bd0ee6b80,~
code-source-info,0x3a1b5d333b90,65,3891,3961,C0O3909C5O3921C11O3921C17O3916C21O3959,,
code-creation,LazyCompile,10,42517,0x3a1b5d333ff0,573,read node:internal/modules/package_json_reader:47:14,0x1d7bd0ee69a8,~
code-source-info,0x3a1b5d333ff0,65,1066,3803,C9O1106C16O1079C21O1085C26O1096C31O1124C36O1134C41O1134C48O1155C53O1168C58O1168C63O1182C64O1240C71O1268C74O1268C79O1240C84O1205C90O1220C97O1318C104O1375C109O1395C114O1416C119O1509C124O1533C131O1857C139O1867C148O1897C150O1915C152O1944C157O1968C162O1977C170O1975C180O2024C184O2045C196O2114C203O2125C222O2152C228O2166C234O2152C238O2150C246O2202C254O2051C259O2045C260O2465C268O2498C274O2509C281O2524C285O2516C288O2479C292O2541C297O2552C301O2572C303O2572C304O2604C305O2618C309O2706C317O2710C324O2773C332O2821C336O2812C340O2838C348O2842C355O2905C363O2953C367O2944C371O2970C379O2974C386O3056C390O3047C394O3076C402O3080C409O3162C413O3153C417O3237C425O3241C432O3298C439O3303C444O3328C451O3333C456O3377C460O3368C464O3394C470O3457C476O3457C481O3438C486O3492C489O3503C501O3553C506O3587C516O3501C522O3623C528O3670C533O3670C538O3701C543O3710C548O3710C554O3756C559O3762C564O3762C570O3787C572O3801,,
code-creation,LazyCompile,10,42627,0x3a1b5d334a20,76,runMainESM node:internal/modules/run_main:86:20,0x1d7bd0ef51e8,~
code-source-info,0x3a1b5d334a20,70,3014,3308,C0O3014C8O3049C16O3049C21O3037C26O3117C34O3117C39O3099C44O3157C49O3180C53O3157C55O3190C60O3208C65O3208C70O3190C75O3307,,
code-creation,Eval,10,42711,0x3a1b5d334e58,5, node:internal/process/esm_loader:1:1,0x3a1b5d334c80,~
script-source,391,node:internal/process/esm_loader,'use strict';\n\nconst {\n  SafePromiseAllReturnVoid\x2C\n} = primordials;\n\nconst { createModuleLoader } = require('internal/modules/esm/loader');\nconst { getOptionValue } = require('internal/options');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { kEmptyObject\x2C getCWDURL } = require('internal/util');\n\nlet esmLoader;\n\nmodule.exports = {\n  get esmLoader() {\n    return esmLoader ??= createModuleLoader(true);\n  }\x2C\n  async loadESM(callback) {\n    esmLoader ??= createModuleLoader(true);\n    try {\n      const userImports = getOptionValue('--import');\n      if (userImports.length > 0) {\n        const parentURL = getCWDURL().href;\n        await SafePromiseAllReturnVoid(userImports\x2C (specifier) => esmLoader.import(\n          specifier\x2C\n          parentURL\x2C\n          kEmptyObject\x2C\n        ));\n      } else {\n        esmLoader.forceLoadHooks();\n      }\n      await callback(esmLoader);\n    } catch (err) {\n      if (hasUncaughtExceptionCaptureCallback()) {\n        process._fatalException(err);\n        return;\n      }\n      internalBinding('errors').triggerUncaughtException(\n        err\x2C\n        true\x2C /* fromPromise */\n      );\n    }\n  }\x2C\n};\n
code-source-info,0x3a1b5d334e58,391,0,1190,C0O0C4O1190,,
code-creation,Function,10,42757,0x3a1b5d335050,146, node:internal/process/esm_loader:1:1,0x3a1b5d334dd0,~
code-source-info,0x3a1b5d335050,391,0,1190,C0O0C34O25C40O100C43O100C48O77C54O167C57O167C62O148C68O247C71O247C76O206C82O322C85O322C90O294C96O308C102O353C103O353C105O365C110O462C140O380C145O1189,,
code-creation,Eval,10,43018,0x3a1b5d3360a8,5, node:internal/modules/esm/loader:1:1,0x3a1b5d335c58,~
script-source,392,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypeReduce\x2C\n  FunctionPrototypeCall\x2C\n  JSONStringify\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeWeakMap\x2C\n  encodeURIComponent\x2C\n  hardenRegExp\x2C\n} = primordials;\n\nconst {\n  ERR_UNKNOWN_MODULE_FORMAT\x2C\n} = require('internal/errors').codes;\nconst { getOptionValue } = require('internal/options');\nconst { pathToFileURL\x2C isURL } = require('internal/url');\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  getDefaultConditions\x2C\n} = require('internal/modules/esm/utils');\nlet defaultResolve\x2C defaultLoad\x2C importMetaInitializer;\n\n/**\n * Lazy loads the module_map module and returns a new instance of ResolveCache.\n * @returns {import('./module_map.js').ResolveCache')}\n */\nfunction newResolveCache() {\n  const { ResolveCache } = require('internal/modules/esm/module_map');\n  return new ResolveCache();\n}\n\n/**\n * Generate a load cache (to store the final result of a load-chain for a particular module).\n * @returns {import('./module_map.js').LoadCache')}\n */\nfunction newLoadCache() {\n  const { LoadCache } = require('internal/modules/esm/module_map');\n  return new LoadCache();\n}\n\n/**\n * Lazy-load translators to avoid potentially unnecessary work at startup (ex if ESM is not used).\n * @returns {import('./translators.js').Translators}\n */\nfunction getTranslators() {\n  const { translators } = require('internal/modules/esm/translators');\n  return translators;\n}\n\n/**\n * @type {HooksProxy}\n * Multiple loader instances exist for various\x2C specific reasons (see code comments at site).\n * In order to maintain consistency\x2C we use a single worker (sandbox)\x2C which must sit apart of an\n * individual loader instance.\n */\nlet hooksProxy;\n\n/**\n * @typedef {Record<string\x2C any>} ModuleExports\n */\n\n/**\n * @typedef {'builtin'|'commonjs'|'json'|'module'|'wasm'} ModuleFormat\n */\n\n/**\n * @typedef {ArrayBuffer|TypedArray|string} ModuleSource\n */\n\nlet emittedSpecifierResolutionWarning = false;\n\n/**\n * This class covers the base machinery of module loading. To add custom\n * behavior you can pass a customizations object and this object will be\n * used to do the loading/resolving/registration process.\n */\nclass ModuleLoader {\n  /**\n   * The conditions for resolving packages if `--conditions` is not used.\n   */\n  #defaultConditions = getDefaultConditions();\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of resolved specifiers\n   */\n  #resolveCache = newResolveCache();\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  loadCache = newLoadCache();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = getTranslators();\n\n  /**\n   * Truthy to allow the use of `import.meta.resolve`. This is needed\n   * currently because the `Hooks` class does not have `resolveSync`\n   * implemented and `import.meta.resolve` requires it.\n   */\n  allowImportMetaResolve;\n\n  /**\n   * Customizations to pass requests to.\n   *\n   * Note that this value _MUST_ be set with `setCustomizations`\n   * because it needs to copy `customizations.allowImportMetaResolve`\n   *  to this property and failure to do so will cause undefined\n   * behavior when invoking `import.meta.resolve`.\n   * @see {ModuleLoader.setCustomizations}\n   */\n  #customizations;\n\n  constructor(customizations) {\n    if (getOptionValue('--experimental-network-imports')) {\n      emitExperimentalWarning('Network Imports');\n    }\n    if (\n      !emittedSpecifierResolutionWarning &&\n      getOptionValue('--experimental-specifier-resolution') === 'node'\n    ) {\n      process.emitWarning(\n        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.'\x2C\n        'ExperimentalWarning'\x2C\n      );\n      emittedSpecifierResolutionWarning = true;\n    }\n    this.setCustomizations(customizations);\n  }\n\n  /**\n   * Change the currently activate customizations for this module\n   * loader to be the provided `customizations`.\n   *\n   * If present\x2C this class customizes its core functionality to the\n   * `customizations` object\x2C including registration\x2C loading\x2C and resolving.\n   * There are some responsibilities that this class _always_ takes\n   * care of\x2C like validating outputs\x2C so that the customizations object\n   * does not have to do so.\n   *\n   * The customizations object has the shape:\n   *\n   * ```ts\n   * interface LoadResult {\n   *   format: ModuleFormat;\n   *   source: ModuleSource;\n   * }\n   *\n   * interface ResolveResult {\n   *   format: string;\n   *   url: URL['href'];\n   * }\n   *\n   * interface Customizations {\n   *   allowImportMetaResolve: boolean;\n   *   load(url: string\x2C context: object): Promise<LoadResult>\n   *   resolve(\n   *     originalSpecifier:\n   *     string\x2C parentURL: string\x2C\n   *     importAttributes: Record<string\x2C string>\n   *   ): Promise<ResolveResult>\n   *   resolveSync(\n   *     originalSpecifier:\n   *     string\x2C parentURL: string\x2C\n   *     importAttributes: Record<string\x2C string>\n   *   ) ResolveResult;\n   *   register(specifier: string\x2C parentURL: string): any;\n   *   forceLoadHooks(): void;\n   * }\n   * ```\n   *\n   * Note that this class _also_ implements the `Customizations`\n   * interface\x2C as does `CustomizedModuleLoader` and `Hooks`.\n   *\n   * Calling this function alters how modules are loaded and should be\n   * invoked with care.\n   * @param {object} customizations\n   */\n  setCustomizations(customizations) {\n    this.#customizations = customizations;\n    if (customizations) {\n      this.allowImportMetaResolve = customizations.allowImportMetaResolve;\n    } else {\n      this.allowImportMetaResolve = true;\n    }\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\x2C\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap } = internalBinding('module_wrap');\n      const { registerModule } = require('internal/modules/esm/utils');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      registerModule(module\x2C {\n        __proto__: null\x2C\n        initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n        importModuleDynamically: (specifier\x2C { url }\x2C importAttributes) => {\n          return this.import(specifier\x2C url\x2C importAttributes);\n        }\x2C\n      });\n\n      return module;\n    };\n    const ModuleJob = require('internal/modules/esm/module_job');\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.loadCache.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAttributes) {\n    const resolveResult = await this.resolve(specifier\x2C parentURL\x2C importAttributes);\n    return this.getJobFromResolveResult(resolveResult\x2C parentURL\x2C importAttributes);\n  }\n\n  getJobFromResolveResult(resolveResult\x2C parentURL\x2C importAttributes) {\n    const { url\x2C format } = resolveResult;\n    const resolvedImportAttributes = resolveResult.importAttributes ?? importAttributes;\n    let job = this.loadCache.get(url\x2C resolvedImportAttributes.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.loadCache.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C resolvedImportAttributes\x2C parentURL\x2C format);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAttributes\x2C parentURL\x2C format) {\n    const moduleProvider = async (url\x2C isMain) => {\n      const {\n        format: finalFormat\x2C\n        responseURL\x2C\n        source\x2C\n      } = await this.load(url\x2C {\n        format\x2C\n        importAttributes\x2C\n      });\n\n      const translator = getTranslators().get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C responseURL);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C responseURL\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {\n      process.send({ 'watch:import': [url] });\n    }\n\n    const ModuleJob = require('internal/modules/esm/module_job');\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAttributes\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\x2C\n    );\n\n    this.loadCache.set(url\x2C importAttributes.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Use directly with caution.\n   * @param {string} specifier The first parameter of an `import()` expression.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAttributes Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleExports>}\n   */\n  async import(specifier\x2C parentURL\x2C importAttributes) {\n    const moduleJob = await this.getModuleJob(specifier\x2C parentURL\x2C importAttributes);\n    const { module } = await moduleJob.run();\n    return module.getNamespace();\n  }\n\n  /**\n   * @see {@link CustomizedModuleLoader.register}\n   */\n  register(specifier\x2C parentURL\x2C data\x2C transferList) {\n    if (!this.#customizations) {\n      // `CustomizedModuleLoader` is defined at the bottom of this file and\n      // available well before this line is ever invoked. This is here in\n      // order to preserve the git diff instead of moving the class.\n      // eslint-disable-next-line no-use-before-define\n      this.setCustomizations(new CustomizedModuleLoader());\n    }\n    return this.#customizations.register(`${specifier}`\x2C `${parentURL}`\x2C data\x2C transferList);\n  }\n\n  /**\n   * Resolve the location of the module.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAttributes} importAttributes Attributes from the import\n   *                                            statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  resolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    if (this.#customizations) {\n      return this.#customizations.resolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n    }\n    const requestKey = this.#resolveCache.serializeKey(originalSpecifier\x2C importAttributes);\n    const cachedResult = this.#resolveCache.get(requestKey\x2C parentURL);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n    const result = this.defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n    this.#resolveCache.set(requestKey\x2C parentURL\x2C result);\n    return result;\n  }\n\n  /**\n   * Just like `resolve` except synchronous. This is here specifically to support\n   * `import.meta.resolve` which must happen synchronously.\n   */\n  resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    if (this.#customizations) {\n      return this.#customizations.resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes);\n    }\n    return this.defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  /**\n   * Our `defaultResolve` is synchronous and can be used in both\n   * `resolve` and `resolveSync`. This function is here just to avoid\n   * repeating the same code block twice in those functions.\n   */\n  defaultResolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    defaultResolve ??= require('internal/modules/esm/resolve').defaultResolve;\n\n    const context = {\n      __proto__: null\x2C\n      conditions: this.#defaultConditions\x2C\n      importAttributes\x2C\n      parentURL\x2C\n    };\n\n    return defaultResolve(originalSpecifier\x2C context);\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} [context] Metadata about the module\n   * @returns {Promise<{ format: ModuleFormat\x2C source: ModuleSource }>}\n   */\n  async load(url\x2C context) {\n    defaultLoad ??= require('internal/modules/esm/load').defaultLoad;\n    const result = this.#customizations ?\n      await this.#customizations.load(url\x2C context) :\n      await defaultLoad(url\x2C context);\n    this.validateLoadResult(url\x2C result?.format);\n    return result;\n  }\n\n  validateLoadResult(url\x2C format) {\n    if (format == null) {\n      require('internal/modules/esm/load').throwUnknownModuleFormat(url\x2C format);\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    if (this.#customizations) {\n      return this.#customizations.importMetaInitialize(meta\x2C context\x2C this);\n    }\n    importMetaInitializer ??= require('internal/modules/esm/initialize_import_meta').initializeImportMeta;\n    meta = importMetaInitializer(meta\x2C context\x2C this);\n    return meta;\n  }\n\n  /**\n   * No-op when no hooks have been supplied.\n   */\n  forceLoadHooks() {\n    this.#customizations?.forceLoadHooks();\n  }\n}\nObjectSetPrototypeOf(ModuleLoader.prototype\x2C null);\n\nclass CustomizedModuleLoader {\n\n  allowImportMetaResolve = true;\n\n  /**\n   * Instantiate a module loader that uses user-provided custom loader hooks.\n   */\n  constructor() {\n    getHooksProxy();\n  }\n\n  /**\n   * Register some loader specifier.\n   * @param {string} originalSpecifier The specified URL path of the loader to\n   *                                   be registered.\n   * @param {string} parentURL The parent URL from where the loader will be\n   *                           registered if using it package name as specifier\n   * @param {any} [data] Arbitrary data to be passed from the custom loader\n   * (user-land) to the worker.\n   * @param {any[]} [transferList] Objects in `data` that are changing ownership\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  register(originalSpecifier\x2C parentURL\x2C data\x2C transferList) {\n    return hooksProxy.makeSyncRequest('register'\x2C transferList\x2C originalSpecifier\x2C parentURL\x2C data);\n  }\n\n  /**\n   * Resolve the location of the module.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAttributes} importAttributes Attributes from the import\n   *                                            statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  resolve(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    return hooksProxy.makeAsyncRequest('resolve'\x2C undefined\x2C originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  resolveSync(originalSpecifier\x2C parentURL\x2C importAttributes) {\n    // This happens only as a result of `import.meta.resolve` calls\x2C which must be sync per spec.\n    return hooksProxy.makeSyncRequest('resolve'\x2C undefined\x2C originalSpecifier\x2C parentURL\x2C importAttributes);\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} [context] Metadata about the module\n   * @returns {Promise<{ format: ModuleFormat\x2C source: ModuleSource }>}\n   */\n  load(url\x2C context) {\n    return hooksProxy.makeAsyncRequest('load'\x2C undefined\x2C url\x2C context);\n  }\n\n  importMetaInitialize(meta\x2C context\x2C loader) {\n    hooksProxy.importMetaInitialize(meta\x2C context\x2C loader);\n  }\n\n  forceLoadHooks() {\n    hooksProxy.waitForWorker();\n  }\n}\n\nlet emittedLoaderFlagWarning = false;\n/**\n * A loader instance is used as the main entry point for loading ES modules. Currently\x2C this is a singleton; there is\n * only one used for loading the main module and everything in its dependency graph\x2C though separate instances of this\n * class might be instantiated as part of bootstrap for other purposes.\n * @param {boolean} useCustomLoadersIfPresent If the user has provided loaders via the --loader flag\x2C use them.\n * @returns {ModuleLoader}\n */\nfunction createModuleLoader(useCustomLoadersIfPresent = true) {\n  let customizations = null;\n  if (useCustomLoadersIfPresent &&\n      // Don't spawn a new worker if we're already in a worker thread created by instantiating CustomizedModuleLoader;\n      // doing so would cause an infinite loop.\n      !require('internal/modules/esm/utils').isLoaderWorker()) {\n    const userLoaderPaths = getOptionValue('--experimental-loader');\n    if (userLoaderPaths.length > 0) {\n      if (!emittedLoaderFlagWarning) {\n        const readableURIEncode = (string) => ArrayPrototypeReduce(\n          [\n            [/'/g\x2C '%27']\x2C // We need to URL-encode the single quote as it's the delimiter for the --import flag.\n            [/%22/g\x2C '"']\x2C // We can decode the double quotes to improve readability.\n            [/%2F/ig\x2C '/']\x2C // We can decode the slashes to improve readability.\n          ]\x2C\n          (str\x2C { 0: regex\x2C 1: replacement }) => RegExpPrototypeSymbolReplace(hardenRegExp(regex)\x2C str\x2C replacement)\x2C\n          encodeURIComponent(string));\n        process.emitWarning(\n          '`--experimental-loader` may be removed in the future; instead use `register()`:\\n' +\n          `--import 'data:text/javascript\x2Cimport { register } from "node:module"; import { pathToFileURL } from "node:url"; ${ArrayPrototypeJoin(\n            ArrayPrototypeMap(userLoaderPaths\x2C (loader) => `register(${readableURIEncode(JSONStringify(loader))}\x2C pathToFileURL("./"))`)\x2C\n            '; '\x2C\n          )};'`\x2C\n          'ExperimentalWarning'\x2C\n        );\n        emittedLoaderFlagWarning = true;\n      }\n      customizations = new CustomizedModuleLoader();\n    }\n  }\n\n  return new ModuleLoader(customizations);\n}\n\n\n/**\n * Get the HooksProxy instance. If it is not defined\x2C then create a new one.\n * @returns {HooksProxy}\n */\nfunction getHooksProxy() {\n  if (!hooksProxy) {\n    const { HooksProxy } = require('internal/modules/esm/hooks');\n    hooksProxy = new HooksProxy();\n  }\n\n  return hooksProxy;\n}\n\n/**\n * Register a single loader programmatically.\n * @param {string|import('url').URL} specifier\n * @param {string|import('url').URL} [parentURL] Base to use when resolving `specifier`; optional if\n * `specifier` is absolute. Same as `options.parentUrl`\x2C just inline\n * @param {object} [options] Additional options to apply\x2C described below.\n * @param {string|import('url').URL} [options.parentURL] Base to use when resolving `specifier`\n * @param {any} [options.data] Arbitrary data passed to the loader's `initialize` hook\n * @param {any[]} [options.transferList] Objects in `data` that are changing ownership\n * @returns {void} We want to reserve the return value for potential future extension of the API.\n * @example\n * ```js\n * register('./myLoader.js');\n * register('ts-node/esm'\x2C { parentURL: import.meta.url });\n * register('./myLoader.js'\x2C { parentURL: import.meta.url });\n * register('ts-node/esm'\x2C import.meta.url);\n * register('./myLoader.js'\x2C import.meta.url);\n * register(new URL('./myLoader.js'\x2C import.meta.url));\n * register('./myLoader.js'\x2C {\n *   parentURL: import.meta.url\x2C\n *   data: { banana: 'tasty' }\x2C\n * });\n * register('./myLoader.js'\x2C {\n *   parentURL: import.meta.url\x2C\n *   data: someArrayBuffer\x2C\n *   transferList: [someArrayBuffer]\x2C\n * });\n * ```\n */\nfunction register(specifier\x2C parentURL = undefined\x2C options) {\n  const moduleLoader = require('internal/process/esm_loader').esmLoader;\n  if (parentURL != null && typeof parentURL === 'object' && !isURL(parentURL)) {\n    options = parentURL;\n    parentURL = options.parentURL;\n  }\n  moduleLoader.register(\n    specifier\x2C\n    parentURL ?? 'data:'\x2C\n    options?.data\x2C\n    options?.transferList\x2C\n  );\n}\n\nmodule.exports = {\n  createModuleLoader\x2C\n  getHooksProxy\x2C\n  register\x2C\n};\n
code-source-info,0x3a1b5d3360a8,392,0,21355,C0O0C4O21355,,
code-creation,Function,10,43637,0x3a1b5d3370f0,576, node:internal/modules/esm/loader:1:1,0x3a1b5d336020,~
code-source-info,0x3a1b5d3370f0,392,0,21355,C0O0C120O79C126O79C130O130C136O152C142O173C148O197C154O222C160O239C165O263C171O295C177O310C183O332C189O405C195O405C200O431C205O374C211O466C217O466C222O447C228O528C234O528C239O503C245O518C251O589C257O589C262O561C268O651C274O651C279O625C285O694C286O694C288O710C289O710C291O723C292O723C294O1840C295O1840C297O2096C298O2096C463O2316C465O14670C468O14704C475O14670C540O14723C542O17163C543O17163C545O21282C552O21303C558O21325C564O21342C570O21297C575O21354,,
code-creation,Function,10,43680,0x3a1b5d337458,7,<instance_members_initializer> node:internal/modules/esm/loader:446:1,0x3a1b5d3369d0,~
code-source-info,0x3a1b5d337458,392,14723,17130,C0O14782C6O17130,,
code-creation,Function,10,43715,0x3a1b5d337518,92,<instance_members_initializer> node:internal/modules/esm/loader:84:1,0x3a1b5d336768,~
code-source-info,0x3a1b5d337518,392,2316,14669,C3O2446C10O2446C17O2542C24O2542C33O2660C41O2731C46O2731C53O2834C58O2834C65O2956C70O2956C78O3184C86O3563C91O14669,,
tick,0x7f6e64f82fe8,43756,1,0xb795c0,3,0xdd1310,0x23f41f78fa9e,0x65c42db,0x3a1b5d33507b,0x23f41f78fabf,0x65c42db,0x3a1b5d334a30,0x3a1b5d323f12,0x3a1b5d305600
code-creation,LazyCompile,10,43901,0x3a1b5d339020,400,pathToFileURL node:internal/url:1517:23,0x23f41f7bdee8,~
code-source-info,0x3a1b5d339020,45,41984,43939,C0O41999C8O42016C14O42016C21O42082C31O42082C37O42179C51O42179C57O42226C59O42247C64O42263C80O42269C85O42263C86O42386C88O42407C93O42422C109O42428C114O42422C115O42557C129O42557C135O42614C138O42632C142O42630C146O42661C151O42702C156O42731C161O42747C164O42747C173O42702C179O42679C183O42677C187O42808C189O42822C190O42844C195O42849C200O42849C206O42958C211O43052C215O43059C219O42958C225O43067C227O43089C229O43085C236O43119C242O43149C244O43145C249O43198C253O43205C256O43188C262O43214C265O43219C269O43210C274O43228C283O43319C286O43330C291O43646C299O43650C307O43688C312O43700C319O43740C328O43711C334O43775C342O43779C350O43817C355O43829C362O43869C371O43840C377O43900C387O43925C394O43907C399O43937,,
code-creation,LazyCompile,10,43956,0x3a1b5d3393e0,229,encodePathChars node:internal/url:1502:25,0x23f41f7bde98,~
code-source-info,0x3a1b5d3393e0,45,41208,41960,C0O41223C8O41227C16O41265C21O41277C28O41317C37O41288C44O41407C52O41425C58O41425C66O41464C71O41476C78O41516C87O41487C94O41552C102O41556C110O41595C115O41607C122O41647C131O41618C138O41681C146O41685C154O41724C159O41736C166O41776C175O41747C182O41817C190O41821C198O41860C203O41872C210O41912C219O41883C226O41942C228O41958,,
code-creation,LazyCompile,10,43997,0x3a1b5d339630,145,URL node:internal/url:660:14,0x32bbd747fb98,~
code-source-info,0x3a1b5d339630,45,17841,18256,C0O17841C24O17887C30O17894C35O17909C47O17915C52O17909C53O17989C57O18013C61O18018C68O18033C71O18029C76O18027C80O18052C84O18084C88O18126C95O18137C100O18137C107O18162C109O18181C118O18187C123O18181C124O18226C126O18231C138O18245C144O18255,,
code-creation,LazyCompile,10,44020,0x3a1b5d3397d8,16,URLContext node:internal/url:180:1,0x32bbd747f2c8,~
code-source-info,0x3a1b5d3397d8,45,3902,3902,C0O3902C15O3902,,
code-creation,LazyCompile,10,44091,0x3a1b5d339a98,212,#updateContext node:internal/url:714:17,0x32bbd747fca0,~
code-source-info,0x3a1b5d339a98,45,19131,20056,C0O19156C4O19161C6O19160C10O19175C12O19184C16O19405C23O19416C28O19214C34O19237C41O19260C48O19281C55O19300C62O19315C69O19340C76O19363C83O19384C90O19436C92O19453C96O19473C98O19490C102O19510C104O19525C108O19543C110O19556C114O19572C116O19581C120O19593C122O19612C126O19634C128O19651C132O19671C134O19686C138O19704C140O19720C144O19780C151O19801C156O19801C162O19816C164O19869C170O19890C174O19922C182O19955C187O19938C191O19936C197O19987C201O20019C206O20033C211O20055,,
code-creation,LazyCompile,10,44135,0x3a1b5d339cf8,44,get href node:internal/url:756:11,0x32bbd747fd40,~
code-source-info,0x3a1b5d339cf8,45,20182,20284,C0O20191C5O20196C11O20215C23O20221C28O20215C29O20254C33O20266C35O20265C39O20275C43O20280,,
code-creation,LazyCompile,10,44187,0x3a1b5d339fc8,323,loadESM node:internal/process/esm_loader:20:16,0x3a1b5d334e88,~
code-source-info,0x3a1b5d339fc8,391,475,1185,C10O475C18O492C28O506C33O506C40O502C49O568C57O568C62O618C68O625C80O658C87O658C91O669C95O658C97O684C104O715C109O690C122O684C151O862C156O872C161O872C165O904C167O919C170O910C182O904C220O957C227O961C232O1010C237O1018C245O1018C250O1048C259O1055C260O1070C268O1070C273O1095C283O1096C300O1184,,
code-creation,LazyCompile,10,44272,0x3a1b5d33a6c0,193,createModuleLoader node:internal/modules/esm/loader:517:28,0x3a1b5d3361c8,~
code-source-info,0x3a1b5d33a6c0,392,17653,19308,C10O17713C12O17721C22O17928C27O17965C32O17966C38O18014C46O18014C51O18079C57O18086C62O18099C75O18166C79O18166C81O18671C86O18679C101O18914C108O18946C111O18964C116O18946C125O18914C140O18786C147O18679C153O19159C159O19184C169O19206C174O19223C180O19266C187O19273C192O19306,,
code-creation,LazyCompile,10,44294,0x3a1b5d33bc38,5,isLoaderWorker node:internal/modules/esm/utils:205:24,0x1d7bd0ee92f8,~
code-source-info,0x3a1b5d33bc38,66,6892,6924,C0O6899C4O6922,,
code-creation,LazyCompile,10,44322,0x3a1b5d33be18,131,ModuleLoader node:internal/modules/esm/loader:133:14,0x3a1b5d336308,~
code-source-info,0x3a1b5d33be18,392,3594,4138,C5O3594C23O3617C33O3621C39O3679C49O3679C53O3733C65O3788C71O3788C78O3842C83O3867C88O3875C99O3875C105O4043C111O4077C119O4100C124O4100C130O4137,,
code-creation,LazyCompile,10,44347,0x3a1b5d33bfa8,21,getDefaultConditions node:internal/modules/esm/utils:41:30,0x1d7bd0ee8e90,~
code-source-info,0x3a1b5d33bfa8,66,955,1032,C0O962C7O969C10O987C12O962C16O1005C20O1030,,
code-creation,LazyCompile,10,44377,0x3a1b5d33c108,22,newResolveCache node:internal/modules/esm/loader:34:25,0x3a1b5d3360d8,~
code-source-info,0x3a1b5d33c108,392,914,1020,C0O946C6O946C11O929C16O999C21O1018,,
tick,0x103544e,44487,1,0xb795c0,3,0xdd1310,0x23f41f78fa9e,0x65c42db,0x3a1b5d33c10e,0x3a1b5d337546,0x3a1b5d33be28,0x3a1b5d33a77b,0x3a1b5d339fe9,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,Eval,10,44502,0x3a1b5d33c660,5, node:internal/modules/esm/module_map:1:1,0x3a1b5d33c398,~
script-source,393,node:internal/modules/esm/module_map,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypeSort\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  SafeMap\x2C\n} = primordials;\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n/**\n * Cache the results of the `resolve` step of the module resolution and loading process.\n * Future resolutions of the same input (specifier\x2C parent URL and import attributes)\n * must return the same result if the first attempt was successful\x2C per\n * https://tc39.es/ecma262/#sec-HostLoadImportedModule.\n * This cache is *not* used when custom loaders are registered.\n */\nclass ResolveCache extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n\n  /**\n   * Generates the internal serialized cache key and returns it along the actual cache object.\n   *\n   * It is exposed to allow more efficient read and overwrite a cache entry.\n   * @param {string} specifier\n   * @param {Record<string\x2Cstring>} importAttributes\n   * @returns {string}\n   */\n  serializeKey(specifier\x2C importAttributes) {\n    // To serialize the ModuleRequest (specifier + list of import attributes)\x2C\n    // we need to sort the attributes by key\x2C then stringifying\x2C\n    // so that different import statements with the same attributes are always treated\n    // as identical.\n    const keys = ObjectKeys(importAttributes);\n\n    if (keys.length === 0) {\n      return specifier + '::';\n    }\n\n    return specifier + '::' + ArrayPrototypeJoin(\n      ArrayPrototypeMap(\n        ArrayPrototypeSort(keys)\x2C\n        (key) => JSONStringify(key) + JSONStringify(importAttributes[key]))\x2C\n      '\x2C');\n  }\n\n  #getModuleCachedImports(parentURL) {\n    let internalCache = super.get(parentURL);\n    if (internalCache == null) {\n      super.set(parentURL\x2C internalCache = { __proto__: null });\n    }\n    return internalCache;\n  }\n\n  /**\n   * @param {string} serializedKey\n   * @param {string} parentURL\n   * @returns {import('./loader').ModuleExports | Promise<import('./loader').ModuleExports>}\n   */\n  get(serializedKey\x2C parentURL) {\n    return this.#getModuleCachedImports(parentURL)[serializedKey];\n  }\n\n  /**\n   * @param {string} serializedKey\n   * @param {string} parentURL\n   * @param {{ format: string\x2C url: URL['href'] }} result\n   */\n  set(serializedKey\x2C parentURL\x2C result) {\n    this.#getModuleCachedImports(parentURL)[serializedKey] = result;\n    return this;\n  }\n\n  has(serializedKey\x2C parentURL) {\n    return serializedKey in this.#getModuleCachedImports(parentURL);\n  }\n}\n\n/**\n * Cache the results of the `load` step of the module resolution and loading process.\n */\nclass LoadCache extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n\n    const ModuleJob = require('internal/modules/esm/module_job');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleLoadMap`);\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\n\nmodule.exports = {\n  LoadCache\x2C\n  ResolveCache\x2C\n};\n
code-source-info,0x3a1b5d33c660,393,0,3892,C0O0C4O3892,,
code-creation,Function,10,44617,0x3a1b5d33cec0,310, node:internal/modules/esm/module_map:1:1,0x3a1b5d33c5d8,~
code-source-info,0x3a1b5d33cec0,393,0,3892,C0O0C39O25C45O47C51O68C57O90C63O107C69O123C75O137C80O195C86O195C91O171C97O247C103O247C108O280C121O281C127O247C129O358C135O358C140O384C145O333C151O419C157O419C162O400C188O854C241O2848C285O3841C292O3862C298O3875C304O3856C309O3891,,
code-creation,Eval,10,44735,0x3a1b5d33d9d0,5, node:internal/modules/esm/assert:1:1,0x3a1b5d33d7c8,~
script-source,394,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n  ERR_IMPORT_ATTRIBUTE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\n/**\n * Define a map of module formats to import attributes types (the value of\n * `type` in `with { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an attribute type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' with { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import attributes.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAttributes Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAttributes(url\x2C format\x2C\n                            importAttributes = { __proto__: null }) {\n  const keys = ObjectKeys(importAttributes);\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i] !== 'type') {\n      throw new ERR_IMPORT_ATTRIBUTE_UNSUPPORTED(keys[i]\x2C importAttributes[keys[i]]);\n    }\n  }\n  const validType = formatTypeMap[format];\n\n  switch (validType) {\n    case undefined:\n      // Ignore attributes for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import attributes object.\n      if (!ObjectPrototypeHasOwnProperty(importAttributes\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAttributes.type);\n\n    case importAttributes.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAttributes.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAttributes\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      return handleInvalidType(url\x2C importAttributes.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAttributes\x2C\n};\n
code-source-info,0x3a1b5d33d9d0,394,0,3876,C0O0C4O3876,,
code-creation,Function,10,44847,0x3a1b5d33dcb0,210, node:internal/modules/esm/assert:1:1,0x3a1b5d33d948,~
code-source-info,0x3a1b5d33dcb0,394,0,3876,C0O0C49O25C54O49C60O75C66O89C71O105C77O180C80O180C85O161C91O375C94O375C99O401C104O223C110O259C116O296C122O337C128O502C130O502C132O692C139O728C145O763C151O814C157O845C163O692C165O1271C168O1295C178O1271C183O1271C185O3809C192O3830C198O3853C204O3824C209O3875,,
code-creation,LazyCompile,10,44905,0x3a1b5d33e308,9, node:internal/modules/esm/assert:44:3,0x3a1b5d33daa0,~
code-source-info,0x3a1b5d33e308,394,1326,1364,C0O1341C2O1345C4O1341C8O1364,,
code-creation,LazyCompile,10,44956,0x3a1b5d33e9e0,36,ResolveCache node:internal/modules/esm/module_map:27:14,0x3a1b5d33c730,~
code-source-info,0x3a1b5d33e9e0,393,877,894,C3O883C7O889C11O883C35O893,,
code-creation,LazyCompile,10,44984,0x3a1b5d33eed8,22,newLoadCache node:internal/modules/esm/loader:43:22,0x3a1b5d336128,~
code-source-info,0x3a1b5d33eed8,392,1197,1297,C0O1226C6O1226C11O1212C16O1279C21O1295,,
code-creation,LazyCompile,10,45004,0x3a1b5d33efb0,27,LoadCache node:internal/modules/esm/module_map:91:14,0x3a1b5d33c8c0,~
code-source-info,0x3a1b5d33efb0,393,2871,2888,C3O2877C7O2883C11O2877C26O2887,,
code-creation,LazyCompile,10,45026,0x3a1b5d33f0e0,17,getTranslators node:internal/modules/esm/loader:52:24,0x3a1b5d336178,~
code-source-info,0x3a1b5d33f0e0,392,1482,1581,C0O1513C6O1513C11O1497C16O1579,,
code-creation,Eval,10,45286,0x3a1b5d33fb20,5, node:internal/modules/esm/translators:1:1,0x3a1b5d33f6f8,~
script-source,395,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplaceAll\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\n/** @type {import('internal/util/types')} */\nlet _TYPES = null;\n/**\n * Lazily loads and returns the internal/util/types module.\n */\nfunction lazyTypes() {\n  if (_TYPES !== null) { return _TYPES; }\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadBuiltinModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\x2C\n} = require('internal/modules/cjs/loader');\nconst { fileURLToPath\x2C URL } = require('internal/url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\n\n/** @type {import('deps/cjs-module-lexer/lexer.js').parse} */\nlet cjsParse;\n/**\n * Initializes the CommonJS module lexer parser.\n * If WebAssembly is available\x2C it uses the optimized version from the dist folder.\n * Otherwise\x2C it falls back to the JavaScript version from the lexer folder.\n */\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    try {\n      await init();\n      cjsParse = parse;\n    } catch {\n      cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n    }\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\n/**\n * Asserts that the given body is a buffer source (either a string\x2C array buffer\x2C or typed array).\n * Throws an error if the body is not a buffer source.\n * @param {string | ArrayBufferView | ArrayBuffer} body - The body to check.\n * @param {boolean} allowString - Whether or not to allow a string as a valid buffer source.\n * @param {string} hookName - The name of the hook being called.\n * @throws {ERR_INVALID_RETURN_PROPERTY_VALUE} If the body is not a buffer source.\n */\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\x2C\n  );\n}\n\n/**\n * Converts a buffer or buffer-like object to a string.\n * @param {string | ArrayBuffer | ArrayBufferView} body - The buffer or buffer-like object to convert to a string.\n * @returns {string} The resulting string.\n */\nfunction stringify(body) {\n  if (typeof body === 'string') { return body; }\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  const { TextDecoder } = require('internal/encoding');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\n/**\n * Converts a URL to a file path if the URL protocol is 'file:'.\n * @param {string} url - The URL to convert.\n */\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\n/**\n * Dynamically imports a module using the ESM loader.\n * @param {string} specifier - The module specifier to import.\n * @param {object} options - An object containing options for the import.\n * @param {string} options.url - The URL of the module requesting the import.\n * @param {Record<string\x2C string>} [attributes] - An object containing attributes for the import.\n * @returns {Promise<import('internal/modules/esm/loader.js').ModuleExports>} The imported module.\n */\nasync function importModuleDynamically(specifier\x2C { url }\x2C attributes) {\n  return asyncESM.esmLoader.import(specifier\x2C url\x2C attributes);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  const { registerModule } = require('internal/modules/esm/utils');\n  registerModule(module\x2C {\n    __proto__: null\x2C\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * Provide a more informative error for CommonJS imports.\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\x2C\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  const filename = fileURLToPath(new URL(url));\n\n  if (!cjsParse) { await initCJSParse(); }\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default') {\n        continue;\n      }\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\n/**\n * Pre-parses a CommonJS module's exports and re-exports.\n * @param {string} filename - The filename of the module.\n */\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached) {\n      return { module\x2C exportNames: cached.exportNames };\n    }\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames) {\n        exportNames.add(name);\n      }\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadBuiltinModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  const shouldCheckAndPopulateCJSModuleCache =\n    // We want to involve the CJS loader cache only for `file:` URL with no search query and no hash.\n    pathname && !StringPrototypeIncludes(url\x2C '?') && !StringPrototypeIncludes(url\x2C '#');\n  let modulePath;\n  let module;\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    modulePath = isWindows ?\n      StringPrototypeReplaceAll(pathname\x2C '/'\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\x2C\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (shouldCheckAndPopulateCJSModuleCache) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  const createDynamicModule = require(\n    'internal/modules/esm/create_dynamic_module');\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports)) {\n      reflect.exports[expt].set(exports[expt]);\n    }\n  }).module;\n});\n
code-source-info,0x3a1b5d33fb20,395,0,12944,C0O0C4O12944,,
code-creation,Function,10,45685,0x2ffc485093d8,658, node:internal/modules/esm/translators:1:1,0x3a1b5d33fa98,~
code-source-info,0x2ffc485093d8,395,0,12944,C0O0C168O25C174O50C180O71C186O82C192O95C198O119C204O152C210O166C216O187C221O198C227O209C233O236C239O265C245O289C251O318C262O356C268O447C269O447C271O664C277O664C282O647C288O711C294O711C299O687C305O696C311O789C317O789C322O738C328O754C334O775C340O876C346O876C351O844C357O857C363O947C369O947C374O924C380O939C386O984C392O984C397O1017C410O1018C416O984C418O1098C424O1098C429O1070C435O1203C441O1203C446O1229C451O1134C457O1164C463O1269C469O1269C474O1245C480O1337C483O1337C488O1377C494O1421C500O1421C504O1421C506O1489C512O1489C517O1469C523O1593C524O1593C526O2241C528O2241C534O2256C536O2276C540O2291C542O2314C546O2347C547O2347C549O4703C562O4703C568O6087C575O6096C578O6079C580O6121C593O6121C599O9268C612O9268C618O9718C631O9718C637O11985C650O11985C657O12943,,
tick,0x7f6e64f83003,45735,1,0xb795c0,3,0xdd1310,0x23f41f78fa9e,0x65c42db,0x3a1b5d33f0e6,0x3a1b5d33755e,0x3a1b5d33be28,0x3a1b5d33a77b,0x3a1b5d339fe9,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,LazyCompile,10,45820,0x2ffc4850a7e8,30,setCustomizations node:internal/modules/esm/loader:198:20,0x3a1b5d336358,~
code-source-info,0x2ffc4850a7e8,392,5695,5922,C0O5718C5O5739C9O5761C13O5834C17O5817C23O5877C24O5905C29O5921,,
code-creation,LazyCompile,10,45846,0x2ffc4850a8e8,22,forceLoadHooks node:internal/modules/esm/loader:440:17,0x3a1b5d336718,~
code-source-info,0x2ffc4850a8e8,392,14615,14667,C0O14624C2O14629C8O14644C13O14646C21O14666,,
code-creation,LazyCompile,10,45866,0x2ffc4850a9e8,26, node:internal/modules/run_main:91:29,0x3a1b5d334950,~
code-source-info,0x2ffc4850a9e8,70,3216,3303,C0O3254C7O3261C12O3267C20O3260C25O3299,,
code-creation,LazyCompile,10,45912,0x2ffc4850ab68,159,import node:internal/modules/esm/loader:335:15,0x3a1b5d336498,~
code-source-info,0x2ffc4850ab68,392,10623,10836,C10O10623C18O10699C35O10699C48O10688C74O10792C79O10792C91O10776C114O10765C119O10817C124O10817C136O10832,,
code-creation,LazyCompile,10,45937,0x2ffc4850ad68,127,getModuleJob node:internal/modules/esm/loader:249:21,0x3a1b5d3363f8,~
code-source-info,0x2ffc4850ad68,392,7659,7876,C10O7659C18O7739C35O7739C48O7728C74O7804C91O7804C104O7872,,
code-creation,LazyCompile,10,45980,0x2ffc4850aee8,126,resolve node:internal/modules/esm/loader:364:10,0x3a1b5d336538,~
code-source-info,0x2ffc4850aee8,392,11891,12470,C0O11946C2O11955C7O11980C9O11992C13O12008C27O12008C32O12064C33O12094C35O12099C39O12113C44O12113C51O12189C53O12194C57O12208C62O12208C69O12240C72O12274C74O12294C75O12325C92O12325C98O12393C100O12398C104O12412C118O12412C123O12452C125O12466,,
code-creation,LazyCompile,10,46037,0x2ffc4850b138,96,serializeKey node:internal/modules/esm/module_map:37:15,0x3a1b5d33c780,~
code-source-info,0x2ffc4850b138,393,1252,1852,C0O1252C9O1553C19O1553C24O1597C30O1604C35O1619C37O1636C40O1643C41O1655C43O1672C51O1681C58O1707C65O1734C68O1734C78O1707C87O1681C92O1679C95O1848,,
code-creation,LazyCompile,10,46075,0x2ffc4850b2b0,26,get node:internal/modules/esm/module_map:68:6,0x3a1b5d33c7d0,~
code-source-info,0x2ffc4850b2b0,393,2250,2349,C0O2283C2O2295C14O2318C22O2329C25O2345,,
code-creation,LazyCompile,10,46097,0x2ffc4850b3b8,51,#getModuleCachedImports node:internal/modules/esm/module_map:55:26,0x3a1b5d33c6e0,~
code-source-info,0x2ffc4850b3b8,393,1879,2072,C0O1917C2O1923C13O1923C19O1943C22O1978C24O1984C29O1988C43O1984C48O2047C50O2068,,
code-creation,LazyCompile,10,46126,0x2ffc4850b5b0,82,defaultResolve node:internal/modules/esm/loader:394:17,0x3a1b5d3365d8,~
code-source-info,0x2ffc4850b5b0,392,13132,13458,C0O13187C18O13206C23O13245C32O13202C40O13283C47O13331C56O13357C62O13381C69O13404C76O13411C81O13454,,
tick,0xdb7dba,46621,1,0xb795c0,2,0xdd1310,0x23f41f78fa9e,0x65c42db,0x2ffc4850b5c2,0x2ffc4850af44,0x2ffc4850ad8b,0x2ffc4850ab8b,0x2ffc4850a9fc,0x3a1b5d33a072,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,Eval,10,47034,0x2ffc4850dc88,5, node:internal/modules/esm/resolve:1:1,0x2ffc4850c7c8,~
script-source,396,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONStringify\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst { realpathSync } = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve\x2C toNamespacedPath } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst inputTypeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath\x2C isURL\x2C toPathIfFileURL } = require('internal/url');\nconst { getCWDURL } = require('internal/util');\nconst { canParse: URLCanParse } = internalBinding('url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n} = require('internal/errors').codes;\n\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst { getPackageScopeConfig } = require('internal/modules/esm/package_config');\nconst { getConditionsSet } = require('internal/modules/esm/utils');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { internalModuleStat } = internalBinding('fs');\n\n/**\n * @typedef {import('internal/modules/esm/package_config.js').PackageConfig} PackageConfig\n */\n\n\nconst emittedPackageWarnings = new SafeSet();\n\n/**\n * Emits a deprecation warning for the use of a deprecated trailing slash pattern mapping in the "exports" field\n * module resolution of a package.\n * @param {string} match - The deprecated trailing slash pattern mapping.\n * @param {string} pjsonUrl - The URL of the package.json file.\n * @param {string} base - The URL of the module that imported the package.\n */\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) { return; }\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\x2C\n  );\n}\n\nconst doubleSlashRegEx = /[/\\\\][/\\\\]/;\n\n/**\n * Emits a deprecation warning for invalid segment in module resolution.\n * @param {string} target - The target module.\n * @param {string} request - The requested module.\n * @param {string} match - The matched module.\n * @param {string} pjsonUrl - The package.json URL.\n * @param {boolean} internal - Whether the module is in the "imports" or "exports" field.\n * @param {string} base - The base URL.\n * @param {boolean} isTarget - Whether the target is a module.\n */\nfunction emitInvalidSegmentDeprecation(target\x2C request\x2C match\x2C pjsonUrl\x2C internal\x2C base\x2C isTarget) {\n  if (!pendingDeprecation) { return; }\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  const double = RegExpPrototypeExec(doubleSlashRegEx\x2C isTarget ? target : request) !== null;\n  process.emitWarning(\n    `Use of deprecated ${double ? 'double slash' :\n      'leading or trailing slash matching'} resolving "${target}" for module ` +\n      `request "${request}" ${request !== match ? `matched to "${match}" ` : ''\n      }in the "${internal ? 'imports' : 'exports'}" field module resolution of the package at ${\n        pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0166'\x2C\n  );\n}\n\n/**\n * Emits a deprecation warning if the given URL is a module and\n * the package.json file does not define a "main" or "exports" field.\n * @param {URL} url - The URL of the module being resolved.\n * @param {URL} packageJSONUrl - The URL of the package.json file for the module.\n * @param {string | URL} [base] - The base URL for the module being resolved.\n * @param {string} [main] - The "main" field from the package.json file.\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormatWithoutErrors(url);\n  if (format !== 'module') { return; }\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (!main) {\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\x2C\n    );\n  } else if (resolve(pkgPath\x2C main) !== path) {\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to "${main}"\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\x2C\n    );\n  }\n}\n\nconst realpathCache = new SafeMap();\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return internalModuleStat(toNamespacedPath(toPathIfFileURL(url))) === 0;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C packageJSONUrl))) {\n      // Handled below.\n    } else {\n      guess = undefined;\n    }\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl))) {\n    // Handled below.\n  } else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl))) {\n    // Handled below.\n  } else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl))) {\n    // Handled below.\n  } else {\n    guess = undefined;\n  }\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) { return search; }\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) { return guess; }\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.exists) {\n      const { main } = pkgJson;\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * Finalizes the resolution of a module specifier by checking if the resolved pathname contains encoded "/" or "\\\\"\n * characters\x2C checking if the resolved pathname is a directory or file\x2C and resolving any symlinks if necessary.\n * @param {URL} resolved - The resolved URL object.\n * @param {string | URL | undefined} base - The base URL object.\n * @param {boolean} preserveSymlinks - Whether to preserve symlinks or not.\n * @returns {URL} - The finalized URL object.\n * @throws {ERR_INVALID_MODULE_SPECIFIER} - If the resolved pathname contains encoded "/" or "\\\\" characters.\n * @throws {ERR_UNSUPPORTED_DIR_IMPORT} - If the resolved pathname is a directory.\n * @throws {ERR_MODULE_NOT_FOUND} - If the resolved pathname is not a file.\n */\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved.pathname) !== null) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n  }\n\n  let path;\n  try {\n    path = fileURLToPath(resolved);\n  } catch (err) {\n    const { setOwnProperty } = require('internal/util');\n    setOwnProperty(err\x2C 'input'\x2C `${resolved}`);\n    setOwnProperty(err\x2C 'module'\x2C `${base}`);\n    throw err;\n  }\n\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n\n    // Directory\n    if (file === undefined) {\n      file = StringPrototypeEndsWith(path\x2C '/') ?\n        (resolveDirectoryEntry(resolved) || resolved) : resolveDirectoryEntry(new URL(`${resolved}/`));\n\n      if (file === resolved) { return file; }\n\n      if (file === undefined) {\n        throw new ERR_MODULE_NOT_FOUND(\n          resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n      }\n    }\n    // If `preserveSymlinks` is false\x2C `resolved` is returned and `path`\n    // is used only to check that the resolved path exists.\n    resolved = file;\n    path = fileURLToPath(resolved);\n  }\n\n  const stats = internalModuleStat(toNamespacedPath(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path));\n\n  // Check for stats.isDirectory()\n  if (stats === 1) {\n    throw new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base)\x2C String(resolved));\n  } else if (stats !== 0) {\n    // Check for !stats.isFile()\n    if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {\n      process.send({ 'watch:require': [path || resolved.pathname] });\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C resolved);\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(path\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\x2C\n    });\n    const { search\x2C hash } = resolved;\n    resolved =\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved;\n}\n\n/**\n * Returns an error object indicating that the specified import is not defined.\n * @param {string} specifier - The import specifier that is not defined.\n * @param {URL} packageJSONUrl - The URL of the package.json file\x2C or null if not available.\n * @param {string | URL | undefined} base - The base URL to use for resolving relative URLs.\n * @returns {ERR_PACKAGE_IMPORT_NOT_DEFINED} - The error object.\n */\nfunction importNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * Returns an error object indicating that the specified subpath was not exported by the package.\n * @param {string} subpath - The subpath that was not exported.\n * @param {URL} packageJSONUrl - The URL of the package.json file.\n * @param {string | URL | undefined} [base] - The base URL to use for resolving the subpath.\n * @returns {ERR_PACKAGE_PATH_NOT_EXPORTED} - The error object.\n */\nfunction exportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  return new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n * Throws an error indicating that the given request is not a valid subpath match for the specified pattern.\n * @param {string} request - The request that failed to match the pattern.\n * @param {string} match - The pattern that the request was compared against.\n * @param {URL} packageJSONUrl - The URL of the package.json file being resolved.\n * @param {boolean} internal - Whether the resolution is for an "imports" or "exports" field in package.json.\n * @param {string | URL | undefined} base - The base URL for the resolution.\n * @throws {ERR_INVALID_MODULE_SPECIFIER} When the request is not a valid match for the pattern.\n */\nfunction throwInvalidSubpath(request\x2C match\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid match in pattern "${match}" for the "${\n    internal ? 'imports' : 'exports'}" resolution of ${\n    fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(request\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\n/**\n * Creates an error object for an invalid package target.\n * @param {string} subpath - The subpath.\n * @param {import('internal/modules/esm/package_config.js').PackageTarget} target - The target.\n * @param {URL} packageJSONUrl - The URL of the package.json file.\n * @param {boolean} internal - Whether the package is internal.\n * @param {string | URL | undefined} base - The base URL.\n * @returns {ERR_INVALID_PACKAGE_TARGET} - The error object.\n */\nfunction invalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  return new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\\\|\\/|$)/i;\nconst deprecatedInvalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\n\n/**\n * Resolves the package target string to a URL object.\n * @param {string} target - The target string to resolve.\n * @param {string} subpath - The subpath to append to the resolved URL.\n * @param {RegExpMatchArray} match - The matched string array from the import statement.\n * @param {string} packageJSONUrl - The URL of the package.json file.\n * @param {string} base - The base URL to resolve the target against.\n * @param {RegExp} pattern - The pattern to replace in the target string.\n * @param {boolean} internal - Whether the target is internal to the package.\n * @param {boolean} isPathMap - Whether the target is a path map.\n * @param {string[]} conditions - The import conditions.\n * @returns {URL} - The resolved URL object.\n * @throws {ERR_INVALID_PACKAGE_TARGET} - If the target is invalid.\n * @throws {ERR_INVALID_SUBPATH} - If the subpath is invalid.\n */\nfunction resolvePackageTargetString(\n  target\x2C\n  subpath\x2C\n  match\x2C\n  packageJSONUrl\x2C\n  base\x2C\n  pattern\x2C\n  internal\x2C\n  isPathMap\x2C\n  conditions\x2C\n) {\n\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/') {\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      // No need to convert target to string\x2C since it's already presumed to be\n      if (!URLCanParse(target)) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(\n          exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)) !== null) {\n    if (RegExpPrototypeExec(deprecatedInvalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)) === null) {\n      if (!isPathMap) {\n        const request = pattern ?\n          StringPrototypeReplace(match\x2C '*'\x2C () => subpath) :\n          match + subpath;\n        const resolvedTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target;\n        emitInvalidSegmentDeprecation(resolvedTarget\x2C request\x2C match\x2C packageJSONUrl\x2C internal\x2C base\x2C true);\n      }\n    } else {\n      throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n    }\n  }\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath)) {\n    throw invalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (subpath === '') { return resolved; }\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C subpath) !== null) {\n    const request = pattern ? StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    if (RegExpPrototypeExec(deprecatedInvalidSegmentRegEx\x2C subpath) === null) {\n      if (!isPathMap) {\n        const resolvedTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target;\n        emitInvalidSegmentDeprecation(resolvedTarget\x2C request\x2C match\x2C packageJSONUrl\x2C internal\x2C base\x2C false);\n      }\n    } else {\n      throwInvalidSubpath(request\x2C match\x2C packageJSONUrl\x2C internal\x2C base);\n    }\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace(patternRegEx\x2C resolved.href\x2C () => subpath)\x2C\n    );\n  }\n\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * Checks if the given key is a valid array index.\n * @param {string} key - The key to check.\n * @returns {boolean} - Returns `true` if the key is a valid array index\x2C else `false`.\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) { return false; }\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\n/**\n * Resolves the target of a package based on the provided parameters.\n * @param {string} packageJSONUrl - The URL of the package.json file.\n * @param {import('internal/modules/esm/package_config.js').PackageTarget} target - The target to resolve.\n * @param {string} subpath - The subpath to resolve.\n * @param {string} packageSubpath - The subpath of the package to resolve.\n * @param {string} base - The base path to resolve.\n * @param {RegExp} pattern - The pattern to match.\n * @param {boolean} internal - Whether the package is internal.\n * @param {boolean} isPathMap - Whether the package is a path map.\n * @param {Set<string>} conditions - The conditions to match.\n * @returns {URL | null | undefined} - The resolved target\x2C or null if not found\x2C or undefined if not resolvable.\n */\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C isPathMap\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      isPathMap\x2C conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0) {\n      return null;\n    }\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C isPathMap\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET') {\n          continue;\n        }\n        throw e;\n      }\n      if (resolveResult === undefined) {\n        continue;\n      }\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === undefined || lastException === null) {\n      return lastException;\n    }\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C isPathMap\x2C conditions);\n        if (resolveResult === undefined) { continue; }\n        return resolveResult;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throw invalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                             base);\n}\n\n/**\n * Is the given exports object using the shorthand syntax?\n * @param {import('internal/modules/esm/package_config.js').PackageConfig['exports']} exports\n * @param {URL} packageJSONUrl The URL of the package.json file.\n * @param {string | URL | undefined} base The base URL.\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) { return true; }\n  if (typeof exports !== 'object' || exports === null) { return false; }\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * Resolves the exports of a package.\n * @param {URL} packageJSONUrl - The URL of the package.json file.\n * @param {string} packageSubpath - The subpath of the package to resolve.\n * @param {import('internal/modules/esm/package_config.js').PackageConfig} packageConfig - The package metadata.\n * @param {string | URL | undefined} base - The base path to resolve from.\n * @param {Set<string>} conditions - An array of conditions to match.\n * @returns {URL} - The resolved package target.\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base)) {\n    exports = { '.': exports };\n  }\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C false\x2C\n      conditions\x2C\n    );\n\n    if (resolveResult == null) {\n      throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n\n    return resolveResult;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      }\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C\n      target\x2C\n      bestMatchSubpath\x2C\n      bestMatch\x2C\n      base\x2C\n      true\x2C\n      false\x2C\n      StringPrototypeEndsWith(packageSubpath\x2C '/')\x2C\n      conditions);\n\n    if (resolveResult == null) {\n      throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n    return resolveResult;\n  }\n\n  throw exportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * Compares two strings that may contain a wildcard character ('*') and returns a value indicating their order.\n * @param {string} a - The first string to compare.\n * @param {string} b - The second string to compare.\n * @returns {number} - A negative number if `a` should come before `b`\x2C a positive number if `a` should come after `b`\x2C\n * or 0 if they are equal.\n */\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) { return -1; }\n  if (baseLenB > baseLenA) { return 1; }\n  if (aPatternIndex === -1) { return 1; }\n  if (bPatternIndex === -1) { return -1; }\n  if (a.length > b.length) { return -1; }\n  if (b.length > a.length) { return 1; }\n  return 0;\n}\n\n/**\n * Resolves the given import name for a package.\n * @param {string} name - The name of the import to resolve.\n * @param {string | URL | undefined} base - The base URL to resolve the import from.\n * @param {Set<string>} conditions - An object containing the import conditions.\n * @throws {ERR_INVALID_MODULE_SPECIFIER} If the import name is not valid.\n * @throws {ERR_PACKAGE_IMPORT_NOT_DEFINED} If the import name cannot be resolved.\n * @returns {URL} The resolved import URL.\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C false\x2C\n          conditions\x2C\n        );\n        if (resolveResult != null) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                     bestMatchSubpath\x2C\n                                                     bestMatch\x2C base\x2C true\x2C\n                                                     true\x2C false\x2C conditions);\n          if (resolveResult != null) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throw importNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * Returns the package type for a given URL.\n * @param {URL} url - The URL to get the package type for.\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * Parse a package name from a specifier.\n * @param {string} specifier - The import specifier.\n * @param {string | URL | undefined} base - The parent URL.\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null) {\n    validPackageName = false;\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * Resolves a package specifier to a URL.\n * @param {string} specifier - The package specifier to resolve.\n * @param {string | URL | undefined} base - The base URL to use for resolution.\n * @param {Set<string>} conditions - An object containing the conditions for resolution.\n * @returns {URL} - The resolved URL.\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  if (BuiltinModule.canBeRequiredWithoutScheme(specifier)) {\n    return new URL('node:' + specifier);\n  }\n\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.exports != null && packageConfig.name === packageName) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = internalModuleStat(toNamespacedPath(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                                          packageJSONPath.length - 13)));\n    // Check for !stat.isDirectory()\n    if (stat !== 1) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = packageJsonReader.read(packageJSONPath\x2C { __proto__: null\x2C specifier\x2C base\x2C isESM: true });\n    if (packageConfig.exports != null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n    if (packageSubpath === '.') {\n      return legacyMainResolve(\n        packageJSONUrl\x2C\n        packageConfig\x2C\n        base\x2C\n      );\n    }\n\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base)\x2C null);\n}\n\n/**\n * Checks if a specifier is a bare specifier.\n * @param {string} specifier - The specifier to check.\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\n/**\n * Determines whether a specifier is a relative path.\n * @param {string} specifier - The specifier to check.\n */\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') { return true; }\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') { return true; }\n    }\n  }\n  return false;\n}\n\n/**\n * Determines whether a specifier should be treated as a relative or absolute path.\n * @param {string} specifier - The specifier to check.\n */\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') { return false; }\n  if (specifier[0] === '/') { return true; }\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * Resolves a module specifier to a URL.\n * @param {string} specifier - The module specifier to resolve.\n * @param {string | URL | undefined} base - The base URL to resolve against.\n * @param {Set<string>} conditions - An object containing environment conditions.\n * @param {boolean} preserveSymlinks - Whether to preserve symlinks in the resolved URL.\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' ||\n    base.protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier\x2C base\x2C conditions);\n      }\n    }\n  }\n  if (resolved.protocol !== 'file:') {\n    return resolved;\n  }\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\n}\n\n/**\n * Try to resolve an import as a CommonJS module.\n * @param {string} specifier - The specifier to resolve.\n * @param {string} parentURL - The base URL.\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Throw an error if an import is not allowed.\n * TODO(@JakobJingleheimer): de-dupe `specifier` & `parsed`\n * @param {string} specifier - The import specifier.\n * @param {URL} parsed - The parsed URL of the import specifier.\n * @param {URL} parsedParentURL - The parsed URL of the parent module.\n * @throws {ERR_NETWORK_IMPORT_DISALLOWED} - If the import is disallowed.\n */\nfunction checkIfDisallowedImport(specifier\x2C parsed\x2C parsedParentURL) {\n  if (parsedParentURL) {\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const parentProtocol = parsedParentURL.protocol;\n    if (\n      parentProtocol === 'http:' ||\n      parentProtocol === 'https:'\n    ) {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // Avoid accessing the `protocol` property due to the lazy getters.\n        const parsedProtocol = parsed?.protocol;\n        // data: and blob: disallowed due to allowing file: access via\n        // indirection\n        if (parsedProtocol &&\n          parsedProtocol !== 'https:' &&\n          parsedProtocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier\x2C\n            parsedParentURL\x2C\n            'remote imports cannot import from a local location.'\x2C\n          );\n        }\n\n        return { url: parsed.href };\n      }\n      if (BuiltinModule.canBeRequiredWithoutScheme(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier\x2C\n          parsedParentURL\x2C\n          'remote imports cannot import from a local location.'\x2C\n        );\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier\x2C\n        parsedParentURL\x2C\n        'only relative and absolute specifiers are supported.'\x2C\n      );\n    }\n  }\n}\n\n/**\n * Validate user-input in `context` supplied by a custom loader.\n * @param {string | URL | undefined} parentURL - The parent URL.\n */\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === undefined) {\n    return; // Main entry point\x2C so no parent\n  }\n  if (typeof parentURL !== 'string' && !isURL(parentURL)) {\n    throw new ERR_INVALID_ARG_TYPE('parentURL'\x2C ['string'\x2C 'URL']\x2C parentURL);\n  }\n}\n\n/**\n * Resolves the given specifier using the provided context\x2C which includes the parent URL and conditions.\n * Throws an error if the parent URL is invalid or if the resolution is disallowed by the policy manifest.\n * Otherwise\x2C attempts to resolve the specifier and returns the resulting URL and format.\n * @param {string} specifier - The specifier to resolve.\n * @param {object} [context={}] - The context object containing the parent URL and conditions.\n * @param {string} [context.parentURL] - The URL of the parent module.\n * @param {string[]} [context.conditions] - The conditions for resolving the specifier.\n */\nfunction defaultResolve(specifier\x2C context = {}) {\n  let { parentURL\x2C conditions } = context;\n  throwIfInvalidParentURL(parentURL);\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        // Prevent network requests from firing if resolution would be banned.\n        // Network requests can extract data by doing things like putting\n        // secrets in query params\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\x2C\n        );\n      }\n    }\n  }\n\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  let parsed;\n  try {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      parsed = new URL(specifier\x2C parsedParentURL);\n    } else {\n      parsed = new URL(specifier);\n    }\n\n    // Avoid accessing the `protocol` property due to the lazy getters.\n    const protocol = parsed.protocol;\n    if (protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (\n          protocol === 'https:' ||\n          protocol === 'http:'\n        )\n      )\n    ) {\n      return { __proto__: null\x2C url: parsed.href };\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns\x2C DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier\x2C\n    parsed\x2C\n    parsedParentURL\x2C\n  );\n\n  if (maybeReturn) { return maybeReturn; }\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') { return { __proto__: null\x2C url: specifier }; }\n\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = getCWDURL().href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (inputTypeFlag) { throw new ERR_INPUT_TYPE_NOT_ALLOWED(); }\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(\n      specifier\x2C\n      parentURL\x2C\n      conditions\x2C\n      isMain ? preserveSymlinksMain : preserveSymlinks\x2C\n    );\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      decorateErrorWithCommonJSHints(error\x2C specifier\x2C parentURL);\n    }\n    throw error;\n  }\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems\x2C silencing them\n    url: url.href\x2C\n    format: defaultGetFormatWithoutErrors(url\x2C context)\x2C\n  };\n}\n\n/**\n * Decorates the given error with a hint for CommonJS modules.\n * @param {Error} error - The error to decorate.\n * @param {string} specifier - The specifier that was attempted to be imported.\n * @param {string} parentURL - The URL of the parent module.\n */\nfunction decorateErrorWithCommonJSHints(error\x2C specifier\x2C parentURL) {\n  const found = resolveAsCommonJS(specifier\x2C parentURL);\n  if (found) {\n    // Modify the stack and message string to include the hint\n    const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n    const hint = `Did you mean to import ${found}?`;\n    error.stack =\n      ArrayPrototypeShift(lines) + '\\n' +\n      hint + '\\n' +\n      ArrayPrototypeJoin(lines\x2C '\\n');\n    error.message += `\\n${hint}`;\n  }\n}\n\nmodule.exports = {\n  decorateErrorWithCommonJSHints\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n  throwIfInvalidParentURL\x2C\n};\n\n// cycle\nconst {\n  defaultGetFormatWithoutErrors\x2C\n} = require('internal/modules/esm/get_format');\n\nif (policy) {\n  const $defaultResolve = defaultResolve;\n  module.exports.defaultResolve = function defaultResolve(\n    specifier\x2C\n    context\x2C\n  ) {\n    const ret = $defaultResolve(specifier\x2C context);\n    // This is a preflight check to avoid data exfiltration by query params etc.\n    policy.manifest.mightAllow(ret.url\x2C () =>\n      new ERR_MANIFEST_DEPENDENCY_MISSING(\n        context.parentURL\x2C\n        specifier\x2C\n        context.conditions\x2C\n      )\x2C\n    );\n    return ret;\n  };\n}\n
code-source-info,0x2ffc4850dc88,396,0,46873,C0O0C4O46873,,
tick,0x7f6e64f83003,48353,1,0xb795c0,3,0xdd1310,0x23f41f78fa9e,0x65c42db,0x2ffc4850b5c2,0x2ffc4850af44,0x2ffc4850ad8b,0x2ffc4850ab8b,0x2ffc4850a9fc,0x3a1b5d33a072,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,Function,10,48416,0x2ffc4850ec08,1105, node:internal/modules/esm/resolve:1:1,0x2ffc4850dc00,~
code-source-info,0x2ffc4850ec08,396,0,46873,C0O0C401O25C407O41C413O63C419O86C425O103C431O132C437O165C443O175C449O198C455O230C460O241C466O252C472O262C478O289C484O316C490O342C496O372C502O398C508O422C514O446C520O509C526O509C530O509C532O565C538O565C543O547C549O627C555O627C560O610C566O669C572O669C577O650C583O725C589O725C593O725C595O832C601O832C613O876C620O832C622O974C628O974C633O929C639O934C645O944C651O953C657O1016C663O1016C667O1016C669O1084C675O1084C679O1084C681O1165C687O1165C691O1165C693O1237C699O1237C703O1237C705O1339C711O1339C716O1277C722O1282C728O1297C734O1312C740O1319C746O1386C752O1386C757O1372C763O1446C766O1446C771O1430C777O1817C783O1817C788O1843C793O1480C799O1510C805O1534C811O1566C817O1596C823O1626C829O1661C835O1685C841O1719C847O1752C853O1782C859O1882C865O1882C870O1868C876O1956C882O1956C887O1930C893O2033C899O2033C904O2012C910O2098C916O2098C920O2098C922O2178C925O2178C930O2155C936O2334C939O2334C944O2334C946O3332C950O3332C952O6146C954O6146C959O6146C961O8742C965O8742C967O9696C971O9696C973O15751C977O15751C979O15961C983O15961C985O16164C989O16164C991O16197C995O16197C997O46075C1004O46096C1010O46130C1016O46148C1022O46167C1028O46192C1034O46210C1040O46235C1046O46260C1052O46090C1056O46343C1062O46343C1067O46308C1073O46388C1084O46428C1086O46428C1088O46453C1097O46476C1104O46872,,
code-creation,Eval,10,48607,0x2ffc485120f0,5, node:internal/modules/esm/package_config:1:1,0x2ffc48511f68,~
script-source,397,node:internal/modules/esm/package_config,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst packageJsonReader = require('internal/modules/package_json_reader');\n\n/**\n * @typedef {object} PackageConfig\n * @property {string} pjsonPath - The path to the package.json file.\n * @property {boolean} exists - Whether the package.json file exists.\n * @property {'none' | 'commonjs' | 'module'} type - The type of the package.\n * @property {string} [name] - The name of the package.\n * @property {string} [main] - The main entry point of the package.\n * @property {PackageTarget} [exports] - The exports configuration of the package.\n * @property {Record<string\x2C string | Record<string\x2C string>>} [imports] - The imports configuration of the package.\n */\n/**\n * @typedef {string | string[] | Record<string\x2C string | Record<string\x2C string>>} PackageTarget\n */\n\n/**\n * Returns the package configuration for the given resolved URL.\n * @param {URL | string} resolved - The resolved URL.\n * @returns {PackageConfig} - The package configuration.\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json')) {\n      break;\n    }\n    const packageConfig = packageJsonReader.read(fileURLToPath(packageJSONUrl)\x2C {\n      __proto__: null\x2C\n      specifier: resolved\x2C\n      isESM: true\x2C\n    });\n    if (packageConfig.exists) {\n      return packageConfig;\n    }\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {\n      break;\n    }\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  return {\n    __proto__: null\x2C\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n}\n\n\nmodule.exports = {\n  getPackageScopeConfig\x2C\n};\n
code-source-info,0x2ffc485120f0,397,0,2215,C0O0C4O2215,,
code-creation,Function,10,48680,0x2ffc48512230,76, node:internal/modules/esm/package_config:1:1,0x2ffc48512068,~
code-source-info,0x2ffc48512230,397,0,2215,C0O0C22O25C28O98C31O98C36O75C42O80C48O149C51O149C55O149C57O2168C64O2189C70O2183C75O2214,,
tick,0x109a64a,48757,0,0x0,0,0x12e9d60,0x2ffc4850efe1,0x23f41f78fabf,0x65c42db,0x2ffc4850b5c2,0x2ffc4850af44,0x2ffc4850ad8b,0x2ffc4850ab8b,0x2ffc4850a9fc,0x3a1b5d33a072,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,Eval,10,48882,0x2ffc48512c28,5, node:internal/modules/esm/get_format:1:1,0x2ffc48512970,~
script-source,398,node:internal/modules/esm/get_format,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\nconst {\n  extensionFormatMap\x2C\n  getFormatOfExtensionlessFile\x2C\n  getLegacyExtensionFormat\x2C\n  mimeToFormat\x2C\n} = require('internal/modules/esm/formats');\n\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst defaultTypeFlag = getOptionValue('--experimental-default-type');\n// The next line is where we flip the default to ES modules someday.\nconst defaultType = defaultTypeFlag === 'module' ? 'module' : 'commonjs';\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst protocolHandlers = {\n  '__proto__': null\x2C\n  'data:': getDataProtocolModuleFormat\x2C\n  'file:': getFileProtocolModuleFormat\x2C\n  'http:': getHttpProtocolModuleFormat\x2C\n  'https:': getHttpProtocolModuleFormat\x2C\n  'node:'() { return 'builtin'; }\x2C\n};\n\n/**\n * @param {URL} parsed\n * @returns {string | null}\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = RegExpPrototypeExec(\n    /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    parsed.pathname\x2C\n  ) || [ null\x2C null\x2C null ];\n\n  return mimeToFormat(mime);\n}\n\nconst DOT_CODE = 46;\nconst SLASH_CODE = 47;\n\n/**\n * Returns the file extension from a URL. Should give similar result to\n * `require('node:path').extname(require('node:url').fileURLToPath(url))`\n * when used with a `file:` URL.\n * @param {URL} url\n * @returns {string}\n */\nfunction extname(url) {\n  const { pathname } = url;\n  for (let i = pathname.length - 1; i > 0; i--) {\n    switch (StringPrototypeCharCodeAt(pathname\x2C i)) {\n      case SLASH_CODE:\n        return '';\n\n      case DOT_CODE:\n        return StringPrototypeCharCodeAt(pathname\x2C i - 1) === SLASH_CODE ? '' : StringPrototypeSlice(pathname\x2C i);\n    }\n  }\n  return '';\n}\n\n/**\n * Determine whether the given file URL is under a `node_modules` folder.\n * This function assumes that the input has already been verified to be a `file:` URL\x2C\n * and is a file rather than a folder.\n * @param {URL} url\n */\nfunction underNodeModules(url) {\n  if (url.protocol !== 'file:') { return false; } // We determine module types for other protocols based on MIME header\n\n  return StringPrototypeIncludes(url.pathname\x2C '/node_modules/');\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @param {boolean} ignoreErrors\n * @returns {string}\n */\nfunction getFileProtocolModuleFormat(url\x2C context\x2C ignoreErrors) {\n  const ext = extname(url);\n\n  if (ext === '.js') {\n    const packageType = getPackageType(url);\n    if (packageType !== 'none') {\n      return packageType;\n    }\n    // The controlling `package.json` file has no `type` field.\n    if (defaultType === 'module') {\n      // An exception to the type flag making ESM the default everywhere is that package scopes under `node_modules`\n      // should retain the assumption that a lack of a `type` field means CommonJS.\n      return underNodeModules(url) ? 'commonjs' : 'module';\n    }\n    return 'commonjs';\n  }\n\n  if (ext === '') {\n    const packageType = getPackageType(url);\n    if (defaultType === 'commonjs') { // Legacy behavior\n      if (packageType === 'none' || packageType === 'commonjs') {\n        return 'commonjs';\n      } // Else packageType === 'module'\n      return getFormatOfExtensionlessFile(url);\n    } // Else defaultType === 'module'\n    if (underNodeModules(url)) { // Exception for package scopes under `node_modules`\n      return packageType === 'module' ? getFormatOfExtensionlessFile(url) : 'commonjs';\n    }\n    if (packageType === 'none' || packageType === 'module') {\n      return getFormatOfExtensionlessFile(url);\n    } // Else packageType === 'commonjs'\n    return 'commonjs';\n  }\n\n  const format = extensionFormatMap[ext];\n  if (format) { return format; }\n\n  if (experimentalSpecifierResolution !== 'node') {\n    // Explicit undefined return indicates load hook should rerun format check\n    if (ignoreErrors) { return undefined; }\n    const filepath = fileURLToPath(url);\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C filepath);\n  }\n\n  return getLegacyExtensionFormat(ext) ?? null;\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | undefined} only works when enabled\n */\nfunction getHttpProtocolModuleFormat(url\x2C context) {\n  if (experimentalNetworkImports) {\n    const { fetchModule } = require('internal/modules/esm/fetch_module');\n    return PromisePrototypeThen(\n      PromiseResolve(fetchModule(url\x2C context))\x2C\n      (entry) => {\n        return mimeToFormat(entry.headers['content-type']);\n      }\x2C\n    );\n  }\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\n  const protocol = url.protocol;\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C protocol)) {\n    return null;\n  }\n  return protocolHandlers[protocol](url\x2C context\x2C true);\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormat(url\x2C context) {\n  const protocol = url.protocol;\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C protocol)) {\n    return null;\n  }\n  return protocolHandlers[protocol](url\x2C context\x2C false);\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  defaultGetFormatWithoutErrors\x2C\n  extensionFormatMap\x2C\n  extname\x2C\n};\n
code-source-info,0x2ffc48512c28,398,0,5818,C0O0C4O5818,,
code-creation,Function,10,49047,0x2ffc48513150,382, node:internal/modules/esm/get_format:1:1,0x2ffc48512ba0,~
code-source-info,0x2ffc48513150,398,0,5818,C0O0C106O25C112O48C118O81C124O105C130O123C136O150C142O179C148O245C154O245C159O226C164O384C170O384C175O284C181O306C187O338C193O366C199O463C202O463C206O463C208O555C211O555C215O555C217O634C220O634C225O770C227O786C238O770C240O851C246O851C251O832C257O918C263O918C268O900C274O982C280O982C285O1008C290O951C296O1042C303O1076C309O1116C315O1156C321O1197C325O1228C335O1042C337O1559C339O1559C341O1582C343O1582C345O5710C352O5731C358O5751C364O5784C370O5806C376O5725C381O5817,,
code-creation,Eval,10,49158,0x2ffc48513e78,5, node:internal/modules/esm/formats:1:1,0x2ffc48513cc0,~
script-source,399,node:internal/modules/esm/formats,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  Uint8Array\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n\nconst { closeSync\x2C openSync\x2C readSync } = require('fs');\n\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.json': 'json'\x2C\n  '.mjs': 'module'\x2C\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\x2C\n};\n\nif (experimentalWasmModules) {\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n}\n\n/**\n * @param {string} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    RegExpPrototypeExec(\n      /^\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?$/i\x2C\n      mime\x2C\n    ) !== null\n  ) { return 'module'; }\n  if (mime === 'application/json') { return 'json'; }\n  if (experimentalWasmModules && mime === 'application/wasm') { return 'wasm'; }\n  return null;\n}\n\nfunction getLegacyExtensionFormat(ext) {\n  return legacyExtensionFormatMap[ext];\n}\n\n/**\n * For extensionless files in a `module` package scope\x2C or a default `module` scope enabled by the\n * `--experimental-default-type` flag\x2C we check the file contents to disambiguate between ES module JavaScript and Wasm.\n * We do this by taking advantage of the fact that all Wasm files start with the header `0x00 0x61 0x73 0x6d` (`_asm`).\n * @param {URL} url\n */\nfunction getFormatOfExtensionlessFile(url) {\n  if (!experimentalWasmModules) { return 'module'; }\n\n  const magic = new Uint8Array(4);\n  let fd;\n  try {\n    // TODO(@anonrig): Optimize the following by having a single C++ call\n    fd = openSync(url);\n    readSync(fd\x2C magic\x2C 0\x2C 4); // Only read the first four bytes\n    if (magic[0] === 0x00 && magic[1] === 0x61 && magic[2] === 0x73 && magic[3] === 0x6d) {\n      return 'wasm';\n    }\n  } finally {\n    if (fd !== undefined) { closeSync(fd); }\n  }\n\n  return 'module';\n}\n\nmodule.exports = {\n  extensionFormatMap\x2C\n  getFormatOfExtensionlessFile\x2C\n  getLegacyExtensionFormat\x2C\n  legacyExtensionFormatMap\x2C\n  mimeToFormat\x2C\n};\n
code-source-info,0x2ffc48513e78,399,0,2205,C0O0C4O2205,,
code-creation,Function,10,49231,0x2ffc485141c8,175, node:internal/modules/esm/formats:1:1,0x2ffc48513df0,~
code-source-info,0x2ffc485141c8,399,0,2205,C0O0C41O25C47O48C53O104C56O104C61O85C66O176C69O176C74O142C80O153C86O163C92O224C95O224C99O224C101O299C106O439C110O439C112O575C116O608C122O672C128O636C132O2057C139O2078C145O2100C151O2132C157O2160C163O2188C169O2072C174O2204,,
code-creation,LazyCompile,10,49430,0x2ffc48514a08,615,defaultResolve node:internal/modules/esm/resolve:1101:24,0x2ffc4850e618,~
code-source-info,0x2ffc48514a08,396,41773,45334,C7O41773C13O41809C18O41820C23O41846C27O41846C31O41884C37O41901C43O41907C52O41943C58O41950C64O41959C70O41959C76O41995C78O42026C83O42035C88O42085C90O42108C96O42104C103O42085C109O42150C111O42162C112O42178C117O42198C121O42228C125O42280C130O42294C138O42308C144O42315C145O42330C149O42541C151O42554C157O42639C163O42662C170O42639C185O42550C192O42541C196O42719C198O42738C205O42771C213O42789C222O42787C225O42866C230O42886C234O42890C240O42950C254O42959C262O43015C270O43024C276O43151C281O43165C283O43178C290O43200C296O43259C303O43294C308O43338C314O43376C324O43383C331O43665C344O43665C350O43746C352O43765C354O43784C355O43840C359O43861C367O43870C372O43885C380O43916C386O43928C387O43950C391O43977C393O43995C399O44007C404O44018C409O44430C415O44451C421O44457C426O44451C427O44500C433O44513C438O44549C443O44566C458O44645C462O44654C468O44677C472O44572C482O44570C493O44821C497O44831C505O44836C514O44880C522O44885C527O44927C539O44931C546O44990C554O45002C559O45042C575O45042C580O45113C582O45113C583O45133C589O45265C599O45283C603O45283C614O45332,,
code-creation,LazyCompile,10,49472,0x2ffc48517698,49,throwIfInvalidParentURL node:internal/modules/esm/resolve:1083:33,0x2ffc4850e5c8,~
code-source-info,0x2ffc48517698,396,40885,41126,C0O40901C4O40936C5O40943C6O40984C14O41022C17O41022C23O41046C41O41052C46O41046C48O41125,,
code-creation,LazyCompile,10,49493,0x2ffc485177c0,31,shouldBeTreatedAsRelativeOrAbsolutePath node:internal/modules/esm/resolve:945:49,0x2ffc4850e488,~
code-source-info,0x2ffc485177c0,396,36045,36188,C0O36061C2O36075C7O36085C8O36098C9O36103C10O36116C16O36120C21O36131C22O36143C23O36148C26O36155C30O36186,,
code-creation,LazyCompile,10,49515,0x2ffc485178d8,81,isRelativeSpecifier node:internal/modules/esm/resolve:931:29,0x2ffc4850e438,~
code-source-info,0x2ffc485178d8,396,35597,35848,C0O35613C1O35626C7O35630C12O35659C19O35666C26O35684C32O35688C37O35699C38O35711C39O35718C41O35731C47O35735C52O35766C59O35773C66O35791C72O35795C77O35806C78O35818C79O35833C80O35846,,
code-creation,LazyCompile,10,49552,0x2ffc48517a78,74,get protocol node:internal/url:806:15,0x32bbd747fe80,~
code-source-info,0x2ffc48517a78,45,21517,21672,C0O21526C5O21531C11O21550C23O21556C28O21550C29O21589C40O21622C42O21621C46O21631C57O21645C59O21644C63O21654C68O21596C73O21668,,
code-creation,LazyCompile,10,49592,0x2ffc48517cc8,164,checkIfDisallowedImport node:internal/modules/esm/resolve:1036:33,0x2ffc4850e578,~
code-source-info,0x2ffc48517cc8,396,39373,40713,C0O39414C4O39552C9O39566C11O39592C18O39628C23O39655C26O39659C32O39820C39O39826C47O39940C51O39987C58O40028C63O40062C79O40068C84O40062C85O40254C90O40275C100O40282C101O40297C106O40315C111O40315C118O40364C134O40370C139O40364C140O40544C156O40550C161O40544C163O40712,,
code-creation,LazyCompile,10,49658,0x2ffc48517ee0,121,getCWDURL node:internal/util:368:19,0x28d42e288738,~
script-source,21,node:internal/util,'use strict';\n\nconst {\n  ArrayBufferPrototypeGetByteLength\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectFreeze\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeGetDotAll\x2C\n  RegExpPrototypeGetGlobal\x2C\n  RegExpPrototypeGetHasIndices\x2C\n  RegExpPrototypeGetIgnoreCase\x2C\n  RegExpPrototypeGetMultiline\x2C\n  RegExpPrototypeGetSticky\x2C\n  RegExpPrototypeGetUnicode\x2C\n  RegExpPrototypeGetSource\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolReplace\x2C\n  SymbolSplit\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  isArrayBufferDetached: _isArrayBufferDetached\x2C\n  privateSymbols: {\n    arrow_message_private_symbol\x2C\n    decorated_private_symbol\x2C\n  }\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\nconst { getOptionValue } = require('internal/options');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\nfunction getDeprecationWarningEmitter(\n  code\x2C msg\x2C deprecated\x2C useEmitSync\x2C\n  shouldEmitWarning = () => true\x2C\n) {\n  let warned = false;\n  return function() {\n    if (!warned && shouldEmitWarning()) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          const emitWarning = useEmitSync ?\n            require('internal/process/warning').emitWarningSync :\n            process.emitWarning;\n          emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n  };\n}\n\nfunction isPendingDeprecation() {\n  return getOptionValue('--pending-deprecation') &&\n    !getOptionValue('--no-deprecation');\n}\n\n// Internal deprecator for pending --pending-deprecation. This can be invoked\n// at snapshot building time as the warning permission is only queried at\n// run time.\nfunction pendingDeprecate(fn\x2C msg\x2C code) {\n  const emitDeprecationWarning = getDeprecationWarningEmitter(\n    code\x2C msg\x2C deprecated\x2C false\x2C isPendingDeprecation\x2C\n  );\n  function deprecated(...args) {\n    emitDeprecationWarning();\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n  return deprecated;\n}\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code\x2C useEmitSync) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  const emitDeprecationWarning = getDeprecationWarningEmitter(\n    code\x2C msg\x2C deprecated\x2C useEmitSync\x2C\n  );\n\n  function deprecated(...args) {\n    emitDeprecationWarning();\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) || err[decorated_private_symbol])\n    return;\n\n  const arrow = err[arrow_message_private_symbol];\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    err[decorated_private_symbol] = true;\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature and might change at any time`;\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { __proto__: null\x2C value: type.name }\x2C\n    length: { __proto__: null\x2C value: type.length }\x2C\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nlet cachedURL;\nlet cachedCWD;\n\n/**\n * Get the current working directory while accounting for the possibility that it has been deleted.\n * `process.cwd()` can fail if the parent directory is deleted while the process runs.\n * @returns {URL} The current working directory or the volume root if it cannot be determined.\n */\nfunction getCWDURL() {\n  const { sep } = require('path');\n  const { pathToFileURL } = require('internal/url');\n\n  let cwd;\n\n  try {\n    // The implementation of `process.cwd()` already uses proper cache when it can.\n    // It's a relatively cheap call performance-wise for the most common use case.\n    cwd = process.cwd();\n  } catch {\n    cachedURL ??= pathToFileURL(sep);\n  }\n\n  if (cwd != null && cwd !== cachedCWD) {\n    cachedURL = pathToFileURL(cwd + sep);\n    cachedCWD = cwd;\n  }\n\n  return cachedURL;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      __proto__: null\x2C\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    __proto__: null\x2C\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x2C\n  });\n\n  const descriptors = ObjectGetOwnPropertyDescriptors(original);\n  const propertiesValues = ObjectValues(descriptors);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  return ObjectDefineProperties(fn\x2C descriptors);\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (RegExpPrototypeExec(/^\\/|\\\\/\x2C filename) === null)\n        continue;\n      return RegExpPrototypeExec(kNodeModulesRE\x2C filename) !== null;\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    return ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\x2C\n  });\n}\n\nfunction defineLazyProperties(target\x2C id\x2C keys\x2C enumerable = true) {\n  const descriptors = { __proto__: null };\n  let mod;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    let lazyLoadedValue;\n    function set(value) {\n      ObjectDefineProperty(target\x2C key\x2C {\n        __proto__: null\x2C\n        writable: true\x2C\n        value\x2C\n      });\n    }\n    ObjectDefineProperty(set\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `set ${key}`\x2C\n    });\n    function get() {\n      mod ??= require(id);\n      if (lazyLoadedValue === undefined) {\n        lazyLoadedValue = mod[key];\n        set(lazyLoadedValue);\n      }\n      return lazyLoadedValue;\n    }\n    ObjectDefineProperty(get\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `get ${key}`\x2C\n    });\n    descriptors[key] = {\n      __proto__: null\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      get\x2C\n      set\x2C\n    };\n  }\n  ObjectDefineProperties(target\x2C descriptors);\n}\n\nfunction defineReplaceableLazyAttribute(target\x2C id\x2C keys\x2C writable = true) {\n  let mod;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    let value;\n    let setterCalled = false;\n\n    function get() {\n      if (setterCalled) {\n        return value;\n      }\n      mod ??= require(id);\n      value ??= mod[key];\n      return value;\n    }\n\n    ObjectDefineProperty(get\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `get ${key}`\x2C\n    });\n\n    function set(val) {\n      setterCalled = true;\n      value = val;\n    }\n    ObjectDefineProperty(set\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: `set ${key}`\x2C\n    });\n\n    ObjectDefineProperty(target\x2C key\x2C {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      get\x2C\n      set: writable ? set : undefined\x2C\n    });\n  }\n}\n\nfunction exposeLazyInterfaces(target\x2C id\x2C keys) {\n  defineLazyProperties(target\x2C id\x2C keys\x2C false);\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nObjectFreeze(kEnumerableProperty);\n\nconst kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\nfunction filterOwnProperties(source\x2C keys) {\n  const filtered = ObjectCreate(null);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (ObjectPrototypeHasOwnProperty(source\x2C key)) {\n      filtered[key] = source[key];\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Mimics `obj[key] = value` but ignoring potential prototype inheritance.\n * @param {any} obj\n * @param {string} key\n * @param {any} value\n * @returns {any}\n */\nfunction setOwnProperty(obj\x2C key\x2C value) {\n  return ObjectDefineProperty(obj\x2C key\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value\x2C\n    writable: true\x2C\n  });\n}\n\nlet internalGlobal;\nfunction getInternalGlobal() {\n  if (internalGlobal == null) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    internalGlobal = runInNewContext('this'\x2C undefined\x2C { contextName: 'internal' });\n  }\n  return internalGlobal;\n}\n\nfunction SideEffectFreeRegExpPrototypeExec(regex\x2C string) {\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  return FunctionPrototypeCall(RegExpFromAnotherRealm.prototype.exec\x2C regex\x2C string);\n}\n\nconst crossRelmRegexes = new SafeWeakMap();\nfunction getCrossRelmRegex(regex) {\n  const cached = crossRelmRegexes.get(regex);\n  if (cached) return cached;\n\n  let flagString = '';\n  if (RegExpPrototypeGetHasIndices(regex)) flagString += 'd';\n  if (RegExpPrototypeGetGlobal(regex)) flagString += 'g';\n  if (RegExpPrototypeGetIgnoreCase(regex)) flagString += 'i';\n  if (RegExpPrototypeGetMultiline(regex)) flagString += 'm';\n  if (RegExpPrototypeGetDotAll(regex)) flagString += 's';\n  if (RegExpPrototypeGetUnicode(regex)) flagString += 'u';\n  if (RegExpPrototypeGetSticky(regex)) flagString += 'y';\n\n  const { RegExp: RegExpFromAnotherRealm } = getInternalGlobal();\n  const crossRelmRegex = new RegExpFromAnotherRealm(RegExpPrototypeGetSource(regex)\x2C flagString);\n  crossRelmRegexes.set(regex\x2C crossRelmRegex);\n  return crossRelmRegex;\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolReplace(regex\x2C string\x2C replacement) {\n  return getCrossRelmRegex(regex)[SymbolReplace](string\x2C replacement);\n}\n\nfunction SideEffectFreeRegExpPrototypeSymbolSplit(regex\x2C string\x2C limit = undefined) {\n  return getCrossRelmRegex(regex)[SymbolSplit](string\x2C limit);\n}\n\n\nfunction isArrayBufferDetached(value) {\n  if (ArrayBufferPrototypeGetByteLength(value) === 0) {\n    return _isArrayBufferDetached(value);\n  }\n\n  return false;\n}\n\n/**\n * Helper function to lazy-load an initialize-once value.\n * @template T Return value of initializer\n * @param {()=>T} initializer Initializer of the lazily loaded value.\n * @returns {()=>T}\n */\nfunction getLazy(initializer) {\n  let value;\n  let initialized = false;\n  return function() {\n    if (initialized === false) {\n      value = initializer();\n      initialized = true;\n    }\n    return value;\n  };\n}\n\n// Setup user-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage objects to a specified directory.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nmodule.exports = {\n  getLazy\x2C\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  defineOperation\x2C\n  defineLazyProperties\x2C\n  defineReplaceableLazyAttribute\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  exposeInterface\x2C\n  exposeLazyInterfaces\x2C\n  filterDuplicateStrings\x2C\n  filterOwnProperties\x2C\n  getConstructorOf\x2C\n  getCWDURL\x2C\n  getInternalGlobal\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isArrayBufferDetached\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  SideEffectFreeRegExpPrototypeExec\x2C\n  SideEffectFreeRegExpPrototypeSymbolReplace\x2C\n  SideEffectFreeRegExpPrototypeSymbolSplit\x2C\n  sleep\x2C\n  spliceOne\x2C\n  setupCoverageHooks\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n  setOwnProperty\x2C\n  pendingDeprecate\x2C\n};\n
code-source-info,0x2ffc48517ee0,21,10214,10706,C0O10237C6O10237C11O10229C16O10282C22O10282C27O10264C32O10314C37O10499C40O10513C45O10513C53O10503C54O10536C62O10550C69O10546C75O10577C82O10604C84O10600C89O10621C91O10651C95O10633C102O10631C108O10663C110O10673C116O10687C120O10704,,
tick,0x1362527,50330,0,0x0,3,0x12da7b0,0x2ffc48514b97,0x2ffc4850b5fc,0x2ffc4850af44,0x2ffc4850ad8b,0x2ffc4850ab8b,0x2ffc4850a9fc,0x3a1b5d33a072,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,LazyCompile,10,50370,0x2ffc48519b88,68,getConditionsSet node:internal/modules/esm/utils:78:26,0x1d7bd0ee9168,~
code-source-info,0x2ffc48519b88,66,1904,2238,C0O1921C7O1968C10O1964C15O1998C20O2003C26O2037C42O2043C47O2037C48O2165C55O2172C60O2196C61O2203C64O2210C67O2236,,
code-creation,LazyCompile,10,50393,0x2ffc48519cc8,21,getDefaultConditionsSet node:internal/modules/esm/utils:51:33,0x1d7bd0ee90c8,~
code-source-info,0x2ffc48519cc8,66,1194,1277,C0O1201C7O1208C10O1229C12O1201C16O1247C20O1275,,
code-creation,LazyCompile,10,50428,0x2ffc48519e00,166,moduleResolve node:internal/modules/esm/resolve:958:23,0x2ffc4850e4d8,~
code-source-info,0x2ffc48519e00,396,36573,37342,C0O36647C7O36656C12O36680C19O36689C23O36809C25O36821C28O36825C34O36883C47O36894C55O36929C60O36955C66O36959C71O36974C83O36985C94O37064C101O37075C110O37073C111O37115C115O37140C127O37151C133O37229C140O37238C145O37257C147O37273C148O37280C160O37287C165O37340,,
code-creation,LazyCompile,10,50522,0x2ffc4851a230,592,finalizeResolution node:internal/modules/esm/resolve:278:28,0x2ffc4850df38,~
code-source-info,0x2ffc4851a230,396,10481,12650,C0O10520C7O10544C10O10570C15O10524C22O10596C27O10651C37O10718C40O10718C47O10602C52O10596C53O10751C58O10769C63O10776C71O10774C81O10850C89O10850C94O10831C99O10880C107O10912C109O10880C114O10929C122O10962C124O10929C129O10975C131O10975C132O10993C140O10997C147O11051C152O11080C155O11080C160O11147C162O11179C170O11186C180O11232C195O11305C200O11312C210O11301C216O11279C221O11334C223O11343C228O11359C230O11371C231O11381C235O11415C240O11466C247O11476C250O11476C260O11421C265O11415C266O11659C269O11680C274O11687C279O11733C286O11752C291O11769C297O11769C306O11810C312O11810C322O11752C327O11733C332O11889C334O11899C339O11912C346O11955C349O11955C356O11976C359O11976C369O11918C374O11912C375O12004C376O12014C381O12060C384O12072C389O12076C398O12113C404O12127C407O12135C417O12159C426O12160C428O12177C442O12135C447O12201C454O12239C456O12256C463O12266C467O12274C470O12274C480O12207C485O12201C486O12313C490O12355C495O12368C502O12383C505O12394C513O12413C520O12355C526O12448C531O12456C536O12479C543O12520C548O12550C551O12520C567O12517C571O12498C577O12573C579O12589C583O12603C585O12617C589O12632C591O12648,,
code-creation,LazyCompile,10,50567,0x2ffc4851a710,91,get pathname node:internal/url:923:15,0x23f41f7bd698,~
code-source-info,0x2ffc4851a710,45,24652,24966,C0O24661C5O24666C11O24685C23O24691C28O24685C29O24736C33O24741C35O24740C39O24759C41O24779C47O24811C54O24844C60O24874C65O24896C72O24928C77O24938C85O24903C90O24962,,
code-creation,LazyCompile,10,50586,0x2ffc4851a898,20,get hasSearch node:internal/url:214:16,0x32bbd747f1e8,~
code-source-info,0x2ffc4851a898,45,4552,4614,C0O4573C7O4590C12O4601C15O4586C19O4610,,
code-creation,LazyCompile,10,50601,0x2ffc4851a9b0,20,get hasHash node:internal/url:218:14,0x32bbd747f258,~
code-source-info,0x2ffc4851a9b0,45,4629,4689,C0O4650C7O4665C12O4676C15O4661C19O4685,,
code-creation,LazyCompile,10,50664,0x2ffc4851aba8,106,fileURLToPath node:internal/url:1473:23,0x23f41f7bde48,~
code-source-info,0x2ffc4851aba8,45,40054,40371,C0O40065C6O40099C13O40106C22O40128C25O40133C31O40150C49O40156C54O40150C55O40226C62O40235C67O40252C77O40258C82O40252C83O40296C92O40315C101O40343C105O40369,,
code-creation,LazyCompile,10,50705,0x2ffc4851ae00,136,getPathFromURLPosix node:internal/url:1455:29,0x23f41f7bddf8,~
code-source-info,0x2ffc4851ae00,45,39537,40030,C0O39555C7O39564C12O39578C19O39614C24O39584C29O39578C30O39652C35O39677C37O39693C41O39682C46O39712C48O39724C54O39728C59O39759C66O39798C70O39759C75O39803C79O39817C81O39832C84O39829C90O39837C97O39854C102O39873C112O39879C117O39873C118O39702C123O39664C126O39992C131O39999C135O40028,,
code-creation,LazyCompile,10,50739,0x2ffc4851b030,93,get hostname node:internal/url:884:15,0x23f41f7bd4e8,~
code-source-info,0x2ffc4851b030,45,23665,23989,C0O23674C5O23679C11O23698C23O23704C28O23698C29O23749C33O23754C35O23753C39O23787C44O23869C51O23873C57O23884C62O23901C67O23923C74O23955C79O23975C87O23930C92O23985,,
tick,0xdb1240,50888,0,0x0,2,0x12da7b0,0x2ffc4851a43e,0x2ffc48519ea0,0x2ffc48514be0,0x2ffc4850b5fc,0x2ffc4850af44,0x2ffc4850ad8b,0x2ffc4850ab8b,0x2ffc4850a9fc,0x3a1b5d33a072,0x3a1b5d334a61,0x3a1b5d323f12,0x3a1b5d305600
code-creation,LazyCompile,10,50897,0x2ffc4851b3a8,113,get search node:internal/url:945:13,0x23f41f7bd778,~
code-source-info,0x2ffc4851b3a8,45,25220,25569,C0O25229C5O25234C11O25253C23O25259C28O25253C29O25304C33O25309C35O25308C39O25332C45O25345C47O25355C48O25379C53O25384C58O25404C64O25428C69O25463C73O25457C79O25476C84O25484C86O25494C87O25501C94O25533C99O25543C107O25508C112O25565,,
code-creation,LazyCompile,10,50933,0x2ffc4851b588,96,get hash node:internal/url:980:11,0x23f41f7bd8c8,~
code-source-info,0x2ffc4851b588,45,26183,26434,C0O26192C5O26197C11O26216C23O26222C28O26216C29O26267C33O26272C35O26271C39O26295C45O26311C50O26316C55O26329C59O26323C65O26340C70O26355C72O26365C73O26376C80O26408C85O26418C90O26383C95O26430,,
code-creation,LazyCompile,10,50989,0x2ffc4851b750,109,set search node:internal/url:956:13,0x23f41f7bd7e8,~
code-source-info,0x2ffc4851b750,45,25583,25813,C0O25597C5O25602C11O25621C23O25627C28O25621C29O25673C36O25684C45O25696C47O25695C51O25705C60O25711C63O25725C72O25734C75O25734C80O25684C86O25759C88O25777C90O25782C102O25796C108O25812,,
code-creation,LazyCompile,10,51016,0x2ffc4851b8d8,41,toUSVString node:internal/util:76:21,0x28d42e287048,~
code-source-info,0x2ffc4851b8d8,21,1774,2066,C0O1796C4O1947C11O1967C14O1947C20O1996C22O2012C24O2023C25O2026C30O2057C35O2033C40O2064,,
code-creation,LazyCompile,10,51060,0x2ffc4851ba40,101,set hash node:internal/url:990:11,0x23f41f7bd930,~
code-source-info,0x2ffc4851ba40,45,26446,26666,C0O26460C5O26465C11O26484C23O26490C28O26484C29O26536C36O26547C45O26559C47O26558C51O26568C60O26574C63O26588C70O26598C72O26547C78O26612C80O26630C82O26635C94O26649C100O26665,,
code-creation,LazyCompile,10,51106,0x2ffc4851bbb8,49,defaultGetFormatWithoutErrors node:internal/modules/esm/get_format:164:39,0x2ffc48512de8,~
code-source-info,0x2ffc4851bbb8,398,5143,5340,C0O5183C5O5195C12O5230C15O5200C22O5265C23O5277C24O5284C31O5307C43O5317C48O5338,,
code-creation,LazyCompile,10,51155,0x2ffc4851c348,257,getFileProtocolModuleFormat node:internal/modules/esm/get_format:95:37,0x2ffc48512d48,~
code-source-info,0x2ffc4851c348,398,2785,4479,C0O2830C3O2830C8O2847C10O2855C15O2892C20O2892C25O2917C27O2933C32O2953C34O2972C35O3047C42O3063C47O3286C50O3293C62O3339C63O3350C65O3368C66O3376C68O3384C73O3418C78O3418C83O3443C90O3459C95O3502C97O3518C104O3544C109O3570C111O3588C112O3636C117O3643C121O3677C122O3721C125O3725C131O3809C133O3828C140O3843C143O3843C151O3890C152O3901C154O3917C161O3943C166O3965C171O3972C175O4006C176O4052C178O4070C179O4093C186O4111C190O4120C192O4134C194O4148C195O4154C202O4190C207O4287C211O4307C212O4324C213O4348C218O4348C223O4372C236O4378C241O4372C242O4432C247O4439C256O4477,,
code-creation,LazyCompile,10,51192,0x2ffc4851c5f0,105,extname node:internal/modules/esm/get_format:63:17,0x2ffc48512ca8,~
code-source-info,0x2ffc4851c5f0,398,1831,2174,C0O1849C5O1891C9O1898C13O1905C14O1905C19O1921C24O1929C32O1982C41O2025C50O2002C52O2012C53O2043C60O2088C64O2050C72O2097C74O2093C85O2115C88O2115C93O2149C94O1911C99O1869C102O2162C104O2172,,
code-creation,LazyCompile,10,51216,0x2ffc4851c778,15,getPackageType node:internal/modules/esm/resolve:810:24,0x2ffc4850e2f8,~
code-source-info,0x2ffc4851c778,396,31520,31610,C0O31552C5O31552C10O31603C14O31608,,
code-creation,LazyCompile,10,51257,0x2ffc4851ca18,173,getPackageScopeConfig node:internal/modules/esm/package_config:28:31,0x2ffc48512120,~
code-source-info,0x2ffc4851ca18,397,1102,2165,C0O1138C13O1138C19O1235C24O1249C32O1253C39O1332C41O1371C46O1389C53O1394C56O1394C68O1467C72O1389C79O1526C85O1542C87O1563C88O1602C91O1622C104O1639C110O1844C115O1876C119O1853C124O1894C126O1177C129O1937C134O1937C139O1970C146O2015C151O2061C156O2082C161O2124C166O2148C172O2163,,
code-creation,LazyCompile,10,51289,0x2ffc4851ce60,44,toString node:internal/url:750:11,0x32bbd747fcf0,~
code-source-info,0x2ffc4851ce60,45,20068,20170,C0O20077C5O20082C11O20101C23O20107C28O20101C29O20140C33O20152C35O20151C39O20161C43O20166,,
code-creation,Function,11,51368,0x65c46c0,184,get hasSearch node:internal/url:214:16,0x32bbd747f1e8,^
code-source-info,0x65c46c0,45,4552,4614,,,
code-creation,Function,11,51393,0x65c4800,1324,resolve node:path:1091:10,0x32bbd746c180,^
code-source-info,0x65c4800,40,33819,34735,,,
code-creation,Function,11,51401,0x65c4dc0,40,toNamespacedPath node:path:1265:19,0x32bbd746c310,^
code-source-info,0x65c4dc0,40,38652,38712,,,
code-creation,Function,11,51416,0x65c4e80,1224,compileForInternalLoader node:internal/bootstrap/realm:375:27,0x23f41f78f9e8,^
code-source-info,0x65c4e80,15,12086,12884,,,
code-creation,Function,11,51425,0x65c5400,280,isURL node:internal/url:655:15,0x32bbd747fb48,^
code-source-info,0x65c5400,45,17733,17814,,,
code-creation,Function,11,51437,0x65c55c0,1104,getPathFromURLPosix node:internal/url:1455:29,0x23f41f7bddf8,^
code-source-info,0x65c55c0,45,39537,40030,,,
code-creation,Function,11,51444,0x65c5ac0,164,nextPart node:fs:2566:31,0x13800b178f80,^
code-source-info,0x65c5ac0,59,69362,69420,,,
code-creation,Function,11,51453,0x65c5c00,308,isFileType node:fs:209:20,0x13800b1771c8,^
code-source-info,0x65c5c00,59,5299,5540,,,
code-creation,LazyCompile,10,51498,0x2ffc4851d318,29,set node:internal/modules/esm/module_map:77:6,0x3a1b5d33c820,~
code-source-info,0x2ffc4851d318,393,2492,2618,C0O2533C2O2538C14O2561C22O2588C26O2602C28O2614,,
code-creation,LazyCompile,10,51537,0x2ffc4851d518,175,handleMainPromise node:internal/modules/run_main:100:33,0x1d7bd0ef5238,~
code-source-info,0x2ffc4851d518,70,3472,3714,C10O3472C18O3523C24O3523C29O3498C34O3578C37O3586C45O3586C54O3629C64O3636C101O3669C104O3677C112O3677C152O3713,,
code-creation,Eval,10,51579,0x2ffc4851d840,5, node:internal/modules/esm/handle_process_exit:1:1,0x2ffc4851d6e8,~
script-source,400,node:internal/modules/esm/handle_process_exit,'use strict';\n\n/**\n * Handle a Promise from running code that potentially does Top-Level Await.\n * In that case\x2C it makes sense to set the exit code to a specific non-zero value\n * if the main code never finishes running.\n */\nfunction handleProcessExit() {\n  process.exitCode ??= 13;\n}\n\nmodule.exports = {\n  handleProcessExit\x2C\n};\n
code-source-info,0x2ffc4851d840,400,0,330,C0O0C4O330,,
code-creation,Function,10,51599,0x2ffc4851d958,33, node:internal/modules/esm/handle_process_exit:1:1,0x2ffc4851d7b8,~
code-source-info,0x2ffc4851d958,400,0,330,C0O0C14O287C21O308C27O302C32O329,,
code-creation,LazyCompile,10,51668,0x2ffc4851dc28,110,getJobFromResolveResult node:internal/modules/esm/loader:254:26,0x3a1b5d336448,~
code-source-info,0x2ffc4851dc28,392,7903,8452,C0O7962C5O7967C10O8044C21O8101C26O8111C31O8145C36O8111C43O8217C47O8261C52O8271C59O8297C69O8271C74O8316C78O8347C80O8358C101O8374C107O8437C109O8448,,
code-creation,LazyCompile,10,51696,0x2ffc4851ddc8,78,get node:internal/modules/esm/module_map:92:6,0x3a1b5d33c910,~
code-source-info,0x2ffc4851ddc8,393,2940,3080,C11O2953C18O2980C28O2980C33O3012C43O3012C48O3046C50O3059C61O3059C71O3069C77O3076,,
code-creation,LazyCompile,10,51747,0x2ffc4851e090,183,#createModuleJob node:internal/modules/esm/loader:282:19,0x3a1b5d3362b8,~
code-source-info,0x2ffc4851e090,392,9106,10149,C0O9106C17O9178C22O9649C31O9690C37O9690C42O9734C47O9746C52O9750C63O9787C69O9801C74O9809C84O9832C93O9833C103O9809C108O9871C116O9871C121O9931C142O9931C148O10076C151O10081C156O10091C164O10117C175O10091C180O10134C182O10145,,
code-creation,Eval,10,51897,0x2ffc4851e998,5, node:internal/modules/esm/module_job:1:1,0x2ffc4851e6c0,~
script-source,401,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseResolve\x2C\n  PromisePrototypeThen\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafePromiseAllReturnArrayLike\x2C\n  SafePromiseAllReturnVoid\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack\x2C kEmptyObject } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\x2C\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C importAttributes = { __proto__: null }\x2C\n              moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.importAttributes = importAttributes;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier\x2C attributes) => {\n        const job = await this.loader.getModuleJob(specifier\x2C url\x2C attributes);\n        ArrayPrototypePush(dependencyJobs\x2C job);\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined) {\n        await SafePromiseAllReturnVoid(promises);\n      }\n\n      return SafePromiseAllReturnArrayLike(dependencyJobs);\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeThen(this.linked\x2C undefined\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return SafePromiseAllReturnVoid(dependencyJobs\x2C addJobsToDependencyGraph);\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = RegExpPrototypeSymbolReplace(\n          /:\\d+$/\x2C\n          splitStack[0]\x2C\n          ''\x2C\n        );\n        const { 1: childSpecifier\x2C 2: name } = RegExpPrototypeExec(\n          /module '(.*)' does not provide an export named '(.+)'/\x2C\n          e.message);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C\n          parentFileUrl\x2C\n          kEmptyObject\x2C\n        );\n        let format;\n        try {\n          // This might throw for non-CommonJS modules because we aren't passing\n          // in the import attributes and some formats require them; but we only\n          // care about CommonJS for the purposes of this error message.\n          ({ format } =\n            await this.loader.load(childFileURL));\n        } catch {\n          // Continue regardless of error.\n        }\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = RegExpPrototypeExec(/{.*}/\x2C importStatement);\n          const destructuringAssignment = oneLineNamedImports &&\n            RegExpPrototypeSymbolReplace(/\\s+as\\s+/g\x2C oneLineNamedImports\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeExec(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) !== null &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { __proto__: null\x2C module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x2ffc4851e998,401,0,8162,C0O0C4O8162,,
code-creation,Function,10,52175,0x2ffc4851ee80,325, node:internal/modules/esm/module_job:1:1,0x2ffc4851e910,~
code-source-info,0x2ffc4851ee80,401,0,8162,C0O0C82O25C88O47C94O69C100O91C105O112C110O136C115O154C121O178C127O194C133O217C139O249C145O282C151O310C157O321C163O348C169O372C175O440C181O440C186O425C192O518C198O518C203O481C209O501C215O580C221O580C226O554C232O644C238O644C242O644C244O696C247O696C249O728C251O728C253O769C254O769C256O799C260O799C262O917C266O917C305O8116C312O8085C317O8134C319O8149C324O8161,,
tick,0x106de31,52221,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x2ffc4851e104,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,LazyCompile,10,52314,0x2ffc4851fa90,189,ModuleJob node:internal/modules/esm/module_job:53:14,0x2ffc4851ea18,~
code-source-info,0x2ffc4851fa90,401,1297,3063,C0O1297C41O1407C46O1419C50O1433C55O1455C59O1479C64O1491C68O1505C73O1521C77O1540C81O1552C85O1687C92O1708C95O1737C104O1746C113O1751C126O1708C131O1706C135O1855C140O2737C143O2751C146O2749C150O2858C160O2884C171O2903C174O2858C179O3029C183O3047C188O3062,,
code-creation,LazyCompile,10,52372,0x2ffc485204e0,196,moduleProvider node:internal/modules/esm/loader:283:28,0x2ffc4851df30,~
code-source-info,0x2ffc485204e0,392,9178,9623,C10O9178C18O9293C21O9304C26O9309C33O9324C39O9340C43O9304C57O9293C80O9233C85O9254C90O9275C95O9394C100O9394C104O9410C109O9411C115O9436C117O9463C132O9469C137O9463C138O9541C160O9548C173O9617,,
code-creation,LazyCompile,10,52416,0x2ffc48520778,228,load node:internal/modules/esm/loader:413:13,0x3a1b5d336628,~
code-source-info,0x2ffc48520778,392,13752,14046,C10O13752C18O13773C36O13789C41O13825C50O13785C58O13858C60O13863C67O13898C71O13914C76O13914C90O13887C121O13947C124O13947C137O13941C163O13983C181O14013C189O13983C195O14028C205O14042,,
code-creation,Eval,10,52530,0x2ffc48520e10,5, node:internal/modules/esm/load:1:1,0x2ffc48520ba8,~
script-source,402,node:internal/modules/esm/load,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { kEmptyObject } = require('internal/util');\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { validateAttributes\x2C emitImportAssertionWarning } = require('internal/modules/esm/assert');\nconst { getOptionValue } = require('internal/options');\n\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\n\nconst { Buffer: { from: BufferFrom } } = require('buffer');\n\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\n/**\n * @param {URL} url URL to the module\n * @param {ESModuleContext} context used to decorate error messages\n * @returns {{ responseURL: string\x2C source: string | BufferView }}\n */\nasync function getSource(url\x2C context) {\n  const { protocol\x2C href } = url;\n  let responseURL = href;\n  let source;\n  if (protocol === 'file:') {\n    const { readFile: readFileAsync } = require('internal/fs/promises').exports;\n    source = await readFileAsync(url);\n  } else if (protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C url.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(responseURL);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = BufferFrom(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else if (experimentalNetworkImports && (\n    protocol === 'https:' ||\n    protocol === 'http:'\n  )) {\n    const { fetchModule } = require('internal/modules/esm/fetch_module');\n    const res = await fetchModule(url\x2C context);\n    source = await res.body;\n    responseURL = res.resolvedHREF;\n  } else {\n    const supportedSchemes = ['file'\x2C 'data'];\n    if (experimentalNetworkImports) {\n      ArrayPrototypePush(supportedSchemes\x2C 'http'\x2C 'https');\n    }\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url\x2C supportedSchemes);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(href\x2C source);\n  }\n  return { __proto__: null\x2C responseURL\x2C source };\n}\n\n\n/**\n * Node.js default load hook.\n * @param {string} url\n * @param {object} context\n * @returns {object}\n */\nasync function defaultLoad(url\x2C context = kEmptyObject) {\n  let responseURL = url;\n  let {\n    importAttributes\x2C\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (importAttributes == null && !('importAttributes' in context) && 'importAssertions' in context) {\n    emitImportAssertionWarning();\n    importAttributes = context.importAssertions;\n    // Alias `importAssertions` to `importAttributes`\n    context = {\n      ...context\x2C\n      importAttributes\x2C\n    };\n  }\n\n  const urlInstance = new URL(url);\n\n  throwIfUnsupportedURLScheme(urlInstance\x2C experimentalNetworkImports);\n\n  format ??= await defaultGetFormat(urlInstance\x2C context);\n\n  validateAttributes(url\x2C format\x2C importAttributes);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    ({ responseURL\x2C source } = await getSource(urlInstance\x2C context));\n  }\n\n  return {\n    __proto__: null\x2C\n    format\x2C\n    responseURL\x2C\n    source\x2C\n  };\n}\n\n\n/**\n * throws an error if the protocol is not one of the protocols\n * that can be loaded in the default loader\n * @param {URL} parsed\n * @param {boolean} experimentalNetworkImports\n */\nfunction throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports) {\n  // Avoid accessing the `protocol` property due to the lazy getters.\n  const protocol = parsed?.protocol;\n  if (\n    protocol &&\n    protocol !== 'file:' &&\n    protocol !== 'data:' &&\n    protocol !== 'node:' &&\n    (\n      !experimentalNetworkImports ||\n      (\n        protocol !== 'https:' &&\n        protocol !== 'http:'\n      )\n    )\n  ) {\n    const schemes = ['file'\x2C 'data'\x2C 'node'];\n    if (experimentalNetworkImports) {\n      ArrayPrototypePush(schemes\x2C 'https'\x2C 'http');\n    }\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C schemes);\n  }\n}\n\n/**\n * For a falsy `format` returned from `load`\x2C throw an error.\n * This could happen from either a custom user loader _or_ from the default loader\x2C because the default loader tries to\n * determine formats for data URLs.\n * @param {string} url The resolved URL of the module\n * @param {null | undefined | false | 0 | -0 | 0n | ''} format Falsy format returned from `load`\n */\nfunction throwUnknownModuleFormat(url\x2C format) {\n  const dataUrl = RegExpPrototypeExec(\n    /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    url\x2C\n  );\n\n  throw new ERR_UNKNOWN_MODULE_FORMAT(\n    dataUrl ? dataUrl[1] : format\x2C\n    url);\n}\n\n\nmodule.exports = {\n  defaultLoad\x2C\n  throwUnknownModuleFormat\x2C\n};\n
code-source-info,0x2ffc48520e10,402,0,4921,C0O0C4O4921,,
code-creation,Function,10,52714,0x2ffc48521118,304, node:internal/modules/esm/load:1:1,0x2ffc48520d88,~
code-source-info,0x2ffc48521118,402,0,4921,C0O0C76O25C82O47C88O70C94O132C100O132C105O115C111O188C117O188C122O167C128O291C134O291C139O240C145O260C151O358C157O358C162O339C167O454C170O454C182O498C189O454C191O580C194O580C198O580C200O672C206O672C211O672C216O655C222O708C228O708C233O700C239O827C245O827C250O853C255O743C261O762C267O791C273O887C277O887C279O4856C286O4877C292O4892C298O4871C303O4920,,
code-creation,LazyCompile,10,52843,0x2ffc48521ce8,358,defaultLoad node:internal/modules/esm/load:79:27,0x2ffc48520e90,~
code-source-info,0x2ffc48521ce8,402,2483,3416,C10O2483C27O2499C61O2535C64O2552C69O2574C74O2586C79O2612C89O2665C99O2699C104O2717C109O2717C112O2778C117O2854C124O2890C133O2942C140O2942C146O2959C151O3000C154O2959C159O3032C167O3049C170O3049C183O3043C211O3092C225O3092C230O3146C232O3162C239O3190C244O3215C248O3239C253O3265C256O3298C269O3292C292O3268C297O3281C302O3339C309O3373C315O3385C321O3402C335O3414,,
code-creation,LazyCompile,10,52895,0x2ffc485225b8,105,throwIfUnsupportedURLScheme node:internal/modules/esm/load:129:37,0x2ffc48520ee0,~
code-source-info,0x2ffc485225b8,402,3640,4236,C0O3768C7O3774C15O3788C19O3822C26O3850C33O3878C40O3906C44O3961C51O3994C56O4046C61O4076C65O4116C79O4116C84O4172C97O4178C102O4172C104O4235,,
code-creation,LazyCompile,10,52945,0x2ffc48522760,212,validateAttributes node:internal/modules/esm/assert:56:28,0x3a1b5d33da00,~
code-source-info,0x2ffc48522760,394,1812,3160,C10O1812C19O1911C24O1911C29O1956C31O1968C35O1961C40O1987C42O1995C48O1999C53O2019C60O2066C66O2092C69O2087C75O2025C80O2019C81O1977C86O1943C89O2129C96O2142C100O2155C101O2185C111O2336C118O2678C129O2313C130O2325C131O2498C139O2503C146O2570C147O2582C148O2597C151O2644C156O2604C161O2650C162O2752C163O2764C164O2911C172O2916C179O3026C192O3032C197O3026C198O3101C201O3148C206O3108C211O3154,,
tick,0x10478a6,53023,0,0x0,3,0x12da7b0,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,LazyCompile,10,53041,0x2ffc48522bf8,449,getSource node:internal/modules/esm/load:37:25,0x2ffc48520e40,~
code-source-info,0x2ffc48522bf8,402,1142,2345,C10O1142C18O1169C23O1179C28O1213C29O1225C31O1235C33O1248C38O1303C44O1303C49O1334C54O1285C59O1363C71O1357C101O1392C103O1405C108O1438C115O1458C118O1480C123O1438C129O1495C131O1515C138O1521C143O1515C144O1576C151O1587C158O1607C165O1627C168O1627C175O1653C184O1616C192O1691C200O1740C207O1769C212O1816C218O1816C223O1800C228O1884C241O1878C267O1934C279O1924C305O1962C312O2016C317O2038C323O2078C338O2078C343O2143C356O2149C361O2143C362O2214C369O2224C378O2242C383O2249C388O2258C393O2258C399O2295C406O2321C412O2334C426O2343,,
code-creation,Eval,10,53574,0x2ffc48524ff8,5, node:internal/fs/promises:1:1,0x2ffc48523ac8,~
script-source,403,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypePop\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  SymbolAsyncDispose\x2C\n  Uint8Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n} = constants;\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatFsFromBinding\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst {\n  kEmptyObject\x2C\n  lazyDOMException\x2C\n  promisify\x2C\n} = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { StringDecoder } = require('string_decoder');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst { Interface } = require('internal/readline/interface');\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\x2C\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  readLines(options = undefined) {\n    return new Interface({\n      input: this.createReadStream(options)\x2C\n      crlfDelay: Infinity\x2C\n    });\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\x2C\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\x2C\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  };\n\n  async [SymbolAsyncDispose]() {\n    return this.close();\n  }\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @param {{\n   *   type?: string;\n   *   }} [options]\n   * @returns {ReadableStream}\n   */\n  readableWebStream(options = kEmptyObject) {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    if (options.type !== undefined) {\n      validateString(options.type\x2C 'options.type');\n    }\n\n    let readable;\n\n    if (options.type !== 'bytes') {\n      const {\n        newReadableStreamFromStreamBase\x2C\n      } = require('internal/webstreams/adapters');\n      readable = newReadableStreamFromStreamBase(\n        this[kHandle]\x2C\n        undefined\x2C\n        { ondone: () => this[kUnref]() });\n    } else {\n      const {\n        ReadableStream\x2C\n      } = require('internal/webstreams/readablestream');\n\n      const readFn = FunctionPrototypeBind(this.read\x2C this);\n      const ondone = FunctionPrototypeBind(this[kUnref]\x2C this);\n\n      readable = new ReadableStream({\n        type: 'bytes'\x2C\n        autoAllocateChunkSize: 16384\x2C\n\n        async pull(controller) {\n          const view = controller.byobRequest.view;\n          const { bytesRead } = await readFn(view\x2C view.byteOffset\x2C view.byteLength);\n\n          if (bytesRead === 0) {\n            ondone();\n            controller.close();\n          }\n\n          controller.byobRequest.respond(bytesRead);\n        }\x2C\n\n        cancel() {\n          ondone();\n        }\x2C\n      });\n    }\n\n    const {\n      readableStreamCancel\x2C\n    } = require('internal/webstreams/readablestream');\n    this[kRef]();\n    this.once('close'\x2C () => {\n      readableStreamCancel(readable);\n    });\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\x2C\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\x2C\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\x2C\n      )\x2C\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\x2C\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n  const encoding = options?.encoding;\n  const decoder = encoding && new StringDecoder(encoding);\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size = 0;\n  let length = 0;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n    length = encoding ? MathMin(size\x2C kReadFileBufferLength) : size;\n  }\n  if (length === 0) {\n    length = kReadFileUnknownBufferLength;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let totalRead = 0;\n  let buffer = Buffer.allocUnsafeSlow(length);\n  let result = '';\n  let offset = 0;\n  let buffers;\n  const chunkedRead = length > kReadFileBufferLength;\n\n  while (true) {\n    checkAborted(signal);\n\n    if (chunkedRead) {\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) ?? 0;\n    totalRead += bytesRead;\n\n    if (bytesRead === 0 ||\n        totalRead === size ||\n        (bytesRead !== buffer.length && !chunkedRead)) {\n      const singleRead = bytesRead === totalRead;\n\n      const bytesToCheck = chunkedRead ? totalRead : bytesRead;\n\n      if (bytesToCheck !== buffer.length) {\n        buffer = buffer.subarray(0\x2C bytesToCheck);\n      }\n\n      if (!encoding) {\n        if (size === 0 && !singleRead) {\n          ArrayPrototypePush(buffers\x2C buffer);\n          return Buffer.concat(buffers\x2C totalRead);\n        }\n        return buffer;\n      }\n\n      if (singleRead) {\n        return buffer.toString(encoding);\n      }\n      result += decoder.end(buffer);\n      return result;\n    }\n\n    if (encoding) {\n      result += decoder.write(buffer);\n    } else if (size !== 0) {\n      offset = totalRead;\n    } else {\n      buffers ??= [];\n      // Unknown file size requires chunks.\n      ArrayPrototypePush(buffers\x2C buffer);\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n    }\n  }\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrParams\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrParams;\n  if (!isArrayBufferView(buffer)) {\n    // This is fh.read(params)\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = bufferOrParams ?? kEmptyObject);\n\n    validateBuffer(buffer);\n  }\n\n  if (offset !== null && typeof offset === 'object') {\n    // This is fh.read(buffer\x2C options)\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = offset);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  if (buffers.length === 0) {\n    return { bytesWritten: 0\x2C buffers };\n  }\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\x2C\n  } = options || kEmptyObject;\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdirRecursive(originalPath\x2C options) {\n  const result = [];\n  const queue = [\n    [\n      originalPath\x2C\n      await binding.readdir(\n        pathModule.toNamespacedPath(originalPath)\x2C\n        options.encoding\x2C\n        !!options.withFileTypes\x2C\n        kUsePromises\x2C\n      )\x2C\n    ]\x2C\n  ];\n\n\n  if (options.withFileTypes) {\n    while (queue.length > 0) {\n      // If we want to implement BFS make this a `shift` call instead of `pop`\n      const { 0: path\x2C 1: readdir } = ArrayPrototypePop(queue);\n      for (const dirent of getDirents(path\x2C readdir)) {\n        ArrayPrototypePush(result\x2C dirent);\n        if (dirent.isDirectory()) {\n          const direntPath = pathModule.join(path\x2C dirent.name);\n          ArrayPrototypePush(queue\x2C [\n            direntPath\x2C\n            await binding.readdir(\n              direntPath\x2C\n              options.encoding\x2C\n              true\x2C\n              kUsePromises\x2C\n            )\x2C\n          ]);\n        }\n      }\n    }\n  } else {\n    while (queue.length > 0) {\n      const { 0: path\x2C 1: readdir } = ArrayPrototypePop(queue);\n      for (const ent of readdir) {\n        const direntPath = pathModule.join(path\x2C ent);\n        const stat = binding.internalModuleStat(direntPath);\n        ArrayPrototypePush(\n          result\x2C\n          pathModule.relative(originalPath\x2C direntPath)\x2C\n        );\n        if (stat === 1) {\n          ArrayPrototypePush(queue\x2C [\n            direntPath\x2C\n            await binding.readdir(\n              pathModule.toNamespacedPath(direntPath)\x2C\n              options.encoding\x2C\n              false\x2C\n              kUsePromises\x2C\n            )\x2C\n          ]);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  if (options.recursive) {\n    return readdirRecursive(path\x2C options);\n  }\n  const result = await binding.readdir(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n    !!options.withFileTypes\x2C\n    kUsePromises\x2C\n  );\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function statfs(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.statfs(pathModule.toNamespacedPath(path)\x2C\n                                      options.bigint\x2C kUsePromises);\n  return getStatFsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options);\n\n  prefix = getValidatedPath(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n\n  let path;\n  if (typeof prefix === 'string') {\n    path = `${prefix}XXXXXX`;\n  } else {\n    path = Buffer.concat([prefix\x2C Buffer.from('XXXXXX')]);\n  }\n\n  return binding.mkdtemp(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validatePrimitiveStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    statfs\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n    constants\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x2ffc48524ff8,403,0,28510,C0O0C4O28510,,
tick,0x7f6e64f82f76,54390,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,Function,10,54451,0x2ffc48527ac8,1893, node:internal/fs/promises:1:1,0x2ffc48524f70,~
code-source-info,0x2ffc48527ac8,403,0,28510,C0O0C539O25C545O47C551O68C557O77C563O88C569O99C575O122C581O133C587O157C593O175C599O192C605O213C611O244C616O254C621O276C627O290C633O357C637O357C643O343C648O397C654O405C660O418C666O430C672O440C678O481C682O481C686O481C688O523C696O523C702O512C708O716C716O716C722O716C728O566C734O593C740O620C746O643C752O678C758O692C764O774C772O774C778O752C784O833C792O833C798O814C804O1486C812O1486C818O1486C824O891C830O909C836O925C842O952C848O986C854O1017C860O1031C866O1060C872O1074C878O1088C884O1112C890O1135C896O1155C902O1171C908O1203C914O1220C920O1243C926O1262C932O1285C938O1306C944O1334C950O1363C955O1384C961O1408C967O1455C973O1536C981O1536C987O1524C992O1710C1000O1710C1006O1574C1012O1591C1018O1614C1024O1633C1030O1651C1036O1671C1042O1690C1048O1761C1056O1761C1060O1761C1062O1839C1070O1839C1076O1788C1082O1804C1088O1824C1093O1895C1101O1895C1107O1873C1112O1955C1120O1955C1126O1937C1132O2000C1140O2000C1146O1990C1151O2056C1159O2056C1165O2041C1171O2106C1179O2106C1183O2106C1185O2151C1189O2151C1193O2151C1195O2182C1199O2182C1203O2182C1205O2211C1209O2211C1213O2211C1215O2250C1219O2250C1223O2250C1225O2297C1229O2297C1233O2297C1235O2343C1239O2343C1243O2343C1245O2380C1249O2380C1253O2380C1255O2411C1259O2411C1263O2411C1265O2445C1269O2445C1273O2445C1275O2490C1279O2473C1285O2521C1293O2521C1299O2507C1305O2631C1313O2631C1319O2571C1324O2587C1329O2601C1334O2612C1339O2711C1343O2711C1347O2711C1349O2767C1353O2767C1355O2802C1356O2802C1358O2957C1359O2957C1361O3078C1477O5519C1505O8309C1515O8713C1525O8770C1537O8861C1547O8898C1579O3053C1581O28040C1587O28070C1595O28076C1601O28088C1607O28102C1613O28110C1617O28129C1627O28153C1633O28165C1639O28179C1645O28187C1651O28198C1657O28209C1663O28222C1669O28236C1675O28249C1681O28260C1687O28270C1693O28282C1703O28292C1713O28304C1723O28315C1733O28327C1743O28339C1753O28350C1763O28362C1773O28375C1783O28389C1793O28402C1803O28417C1813O28433C1823O28447C1833O28458C1853O28477C1863O28491C1873O28499C1883O28055C1892O28509,,
code-creation,Function,10,54489,0x2ffc48528598,19,<instance_members_initializer> node:internal/fs/promises:127:1,0x2ffc485267e8,~
code-source-info,0x2ffc48528598,403,3053,9116,C0O3053C9O4715C18O9116,,
code-creation,Eval,10,54771,0x2ffc4852b868,5, node:internal/fs/rimraf:1:1,0x2ffc4852b500,~
script-source,404,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\x2C\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x2ffc4852b868,404,0,7454,C0O0C4O7454,,
code-creation,Function,10,54981,0x2ffc4852be68,409, node:internal/fs/rimraf:1:1,0x2ffc4852b7e0,~
code-source-info,0x2ffc4852be68,404,0,7454,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O643C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O663C257O663C262O655C267O703C270O703C275O688C281O740C284O740C289O730C295O793C302O793C307O793C309O864C316O864C321O864C323O959C330O968C333O951C335O1002C345O1002C347O1061C357O1061C359O1127C361O1127C363O1155C366O1162C371O1162C376O1155C378O7397C385O7416C391O7424C397O7440C403O7412C408O7453,,
tick,0x1258123,55157,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48527e9d,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,Eval,10,55259,0x2ffc4852d3b8,5, node:internal/fs/dir:1:1,0x2ffc4852d0b0,~
script-source,405,node:internal/fs/dir,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  FunctionPrototypeBind\x2C\n  ObjectDefineProperty\x2C\n  PromiseReject\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\n\nconst pathModule = require('path');\nconst binding = internalBinding('fs');\nconst dirBinding = internalBinding('fs_dir');\nconst {\n  codes: {\n    ERR_DIR_CLOSED\x2C\n    ERR_DIR_CONCURRENT_OPERATION\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst internalUtil = require('internal/util');\nconst {\n  getDirent\x2C\n  getOptions\x2C\n  getValidatedPath\x2C\n  handleErrorFromBinding\x2C\n} = require('internal/fs/utils');\nconst {\n  validateFunction\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst kDirHandle = Symbol('kDirHandle');\nconst kDirPath = Symbol('kDirPath');\nconst kDirBufferedEntries = Symbol('kDirBufferedEntries');\nconst kDirClosed = Symbol('kDirClosed');\nconst kDirOptions = Symbol('kDirOptions');\nconst kDirReadImpl = Symbol('kDirReadImpl');\nconst kDirReadPromisified = Symbol('kDirReadPromisified');\nconst kDirClosePromisified = Symbol('kDirClosePromisified');\nconst kDirOperationQueue = Symbol('kDirOperationQueue');\n\nclass Dir {\n  constructor(handle\x2C path\x2C options) {\n    if (handle == null) throw new ERR_MISSING_ARGS('handle');\n    this[kDirHandle] = handle;\n    this[kDirBufferedEntries] = [];\n    this[kDirPath] = path;\n    this[kDirClosed] = false;\n\n    // Either `null` or an Array of pending operations (= functions to be called\n    // once the current operation is done).\n    this[kDirOperationQueue] = null;\n\n    this[kDirOptions] = {\n      bufferSize: 32\x2C\n      ...getOptions(options\x2C {\n        encoding: 'utf8'\x2C\n      })\x2C\n    };\n\n    validateUint32(this[kDirOptions].bufferSize\x2C 'options.bufferSize'\x2C true);\n\n    this[kDirReadPromisified] = FunctionPrototypeBind(\n      internalUtil.promisify(this[kDirReadImpl])\x2C this\x2C false);\n    this[kDirClosePromisified] = FunctionPrototypeBind(\n      internalUtil.promisify(this.close)\x2C this);\n  }\n\n  get path() {\n    return this[kDirPath];\n  }\n\n  read(callback) {\n    return this[kDirReadImpl](true\x2C callback);\n  }\n\n  [kDirReadImpl](maybeSync\x2C callback) {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (callback === undefined) {\n      return this[kDirReadPromisified]();\n    }\n\n    validateFunction(callback\x2C 'callback');\n\n    if (this[kDirOperationQueue] !== null) {\n      ArrayPrototypePush(this[kDirOperationQueue]\x2C () => {\n        this[kDirReadImpl](maybeSync\x2C callback);\n      });\n      return;\n    }\n\n    if (this[kDirBufferedEntries].length > 0) {\n      try {\n        const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);\n\n        if (this[kDirOptions].recursive && dirent.isDirectory()) {\n          this.readSyncRecursive(dirent);\n        }\n\n        if (maybeSync)\n          process.nextTick(callback\x2C null\x2C dirent);\n        else\n          callback(null\x2C dirent);\n        return;\n      } catch (error) {\n        return callback(error);\n      }\n    }\n\n    const req = new FSReqCallback();\n    req.oncomplete = (err\x2C result) => {\n      process.nextTick(() => {\n        const queue = this[kDirOperationQueue];\n        this[kDirOperationQueue] = null;\n        for (const op of queue) op();\n      });\n\n      if (err || result === null) {\n        return callback(err\x2C result);\n      }\n\n      try {\n        this.processReadResult(this[kDirPath]\x2C result);\n        const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);\n        if (this[kDirOptions].recursive && dirent.isDirectory()) {\n          this.readSyncRecursive(dirent);\n        }\n        callback(null\x2C dirent);\n      } catch (error) {\n        callback(error);\n      }\n    };\n\n    this[kDirOperationQueue] = [];\n    this[kDirHandle].read(\n      this[kDirOptions].encoding\x2C\n      this[kDirOptions].bufferSize\x2C\n      req\x2C\n    );\n  }\n\n  processReadResult(path\x2C result) {\n    for (let i = 0; i < result.length; i += 2) {\n      ArrayPrototypePush(\n        this[kDirBufferedEntries]\x2C\n        getDirent(\n          path\x2C\n          result[i]\x2C\n          result[i + 1]\x2C\n          true\x2C // Quirk to not introduce a breaking change.\n        )\x2C\n      );\n    }\n  }\n\n  readSyncRecursive(dirent) {\n    const ctx = { path: dirent.path };\n    const handle = dirBinding.opendir(\n      pathModule.toNamespacedPath(dirent.path)\x2C\n      this[kDirOptions].encoding\x2C\n      undefined\x2C\n      ctx\x2C\n    );\n    handleErrorFromBinding(ctx);\n    const result = handle.read(\n      this[kDirOptions].encoding\x2C\n      this[kDirOptions].bufferSize\x2C\n      undefined\x2C\n      ctx\x2C\n    );\n\n    if (result) {\n      this.processReadResult(dirent.path\x2C result);\n    }\n\n    handle.close(undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n  }\n\n  readSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n\n    if (this[kDirBufferedEntries].length > 0) {\n      const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);\n      if (this[kDirOptions].recursive && dirent.isDirectory()) {\n        this.readSyncRecursive(dirent);\n      }\n      return dirent;\n    }\n\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].read(\n      this[kDirOptions].encoding\x2C\n      this[kDirOptions].bufferSize\x2C\n      undefined\x2C\n      ctx\x2C\n    );\n    handleErrorFromBinding(ctx);\n\n    if (result === null) {\n      return result;\n    }\n\n    this.processReadResult(this[kDirPath]\x2C result);\n\n    const dirent = ArrayPrototypeShift(this[kDirBufferedEntries]);\n    if (this[kDirOptions].recursive && dirent.isDirectory()) {\n      this.readSyncRecursive(dirent);\n    }\n    return dirent;\n  }\n\n  close(callback) {\n    // Promise\n    if (callback === undefined) {\n      if (this[kDirClosed] === true) {\n        return PromiseReject(new ERR_DIR_CLOSED());\n      }\n      return this[kDirClosePromisified]();\n    }\n\n    // callback\n    validateFunction(callback\x2C 'callback');\n\n    if (this[kDirClosed] === true) {\n      process.nextTick(callback\x2C new ERR_DIR_CLOSED());\n      return;\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      ArrayPrototypePush(this[kDirOperationQueue]\x2C () => {\n        this.close(callback);\n      });\n      return;\n    }\n\n    this[kDirClosed] = true;\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    this[kDirHandle].close(req);\n  }\n\n  closeSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n\n    this[kDirClosed] = true;\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].close(undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    return result;\n  }\n\n  async* entries() {\n    try {\n      while (true) {\n        const result = await this[kDirReadPromisified]();\n        if (result === null) {\n          break;\n        }\n        yield result;\n      }\n    } finally {\n      await this[kDirClosePromisified]();\n    }\n  }\n}\n\nObjectDefineProperty(Dir.prototype\x2C SymbolAsyncIterator\x2C {\n  __proto__: null\x2C\n  value: Dir.prototype.entries\x2C\n  enumerable: false\x2C\n  writable: true\x2C\n  configurable: true\x2C\n});\n\nfunction opendir(path\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : callback;\n  validateFunction(callback\x2C 'callback');\n\n  path = getValidatedPath(path);\n  options = getOptions(options\x2C {\n    encoding: 'utf8'\x2C\n  });\n\n  function opendirCallback(error\x2C handle) {\n    if (error) {\n      callback(error);\n    } else {\n      callback(null\x2C new Dir(handle\x2C path\x2C options));\n    }\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = opendirCallback;\n\n  dirBinding.opendir(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n    req\x2C\n  );\n}\n\nfunction opendirSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = getOptions(options\x2C {\n    encoding: 'utf8'\x2C\n  });\n\n  const ctx = { path };\n  const handle = dirBinding.opendir(\n    pathModule.toNamespacedPath(path)\x2C\n    options.encoding\x2C\n    undefined\x2C\n    ctx\x2C\n  );\n  handleErrorFromBinding(ctx);\n\n  return new Dir(handle\x2C path\x2C options);\n}\n\nmodule.exports = {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\x2C\n};\n
code-source-info,0x2ffc4852d3b8,405,0,8203,C0O0C4O8203,,
code-creation,Function,10,55488,0x2ffc4852de18,489, node:internal/fs/dir:1:1,0x2ffc4852d330,~
code-source-info,0x2ffc4852de18,405,0,8203,C0O0C100O25C106O47C112O70C118O95C123O119C129O136C134O146C139O204C142O204C146O204C148O237C151O237C156O279C159O279C163O279C165O410C168O410C173O410C178O329C184O349C190O383C196O447C202O495C205O495C209O495C211O606C214O606C219O531C225O544C231O558C237O578C243O686C246O686C251O646C257O666C263O738C266O738C270O738C272O777C275O777C279O777C281O825C284O825C288O825C290O875C293O875C297O875C299O917C302O917C306O917C308O961C311O961C315O961C317O1013C320O1013C324O1013C326O1073C329O1073C333O1073C335O1132C338O1132C342O1132C364O2116C419O1163C421O7029C424O7054C429O7065C437O7120C442O7130C453O7029C458O8148C465O8169C471O8176C477O8187C483O8163C488O8202,,
code-creation,Eval,10,55694,0x2ffc4852f9d8,5, node:string_decoder:1:1,0x2ffc4852f760,~
script-source,406,node:string_decoder,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  kIncompleteCharactersStart\x2C\n  kIncompleteCharactersEnd\x2C\n  kMissingBytes\x2C\n  kBufferedBytes\x2C\n  kEncodingField\x2C\n  kSize\x2C\n  decode\x2C\n  flush\x2C\n  encodings\x2C\n} = internalBinding('string_decoder');\nconst internalUtil = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_UNKNOWN_ENCODING\x2C\n} = require('internal/errors').codes;\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n\nconst kNativeDecoder = Symbol('kNativeDecoder');\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n/**\n * Normalize encoding notation\n * @param {string} enc\n * @returns {"utf8" | "utf16le" | "hex" | "ascii"\n *           | "base64" | "latin1" | "base64url"}\n * @throws {TypeError} Throws an error when encoding is invalid\n */\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (nenc === undefined) {\n    if (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc))\n      throw new ERR_UNKNOWN_ENCODING(enc);\n    return enc;\n  }\n  return nenc;\n}\n\nconst encodingsMap = {};\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\n/**\n * StringDecoder provides an interface for efficiently splitting a series of\n * buffers into a series of JS strings without breaking apart multi-byte\n * characters.\n * @param {string} [encoding=utf-8]\n */\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  this[kNativeDecoder] = Buffer.alloc(kSize);\n  this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n}\n\n/**\n * Returns a decoded string\x2C omitting any incomplete multi-bytes\n * characters at the end of the Buffer\x2C or TypedArray\x2C or DataView\n * @param {string | Buffer | TypedArray | DataView} buf\n * @returns {string}\n * @throws {TypeError} Throws when buf is not in one of supported types\n */\nStringDecoder.prototype.write = function write(buf) {\n  if (typeof buf === 'string')\n    return buf;\n  if (!ArrayBufferIsView(buf))\n    throw new ERR_INVALID_ARG_TYPE('buf'\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buf);\n  if (!this[kNativeDecoder]) {\n    throw new ERR_INVALID_THIS('StringDecoder');\n  }\n  return decode(this[kNativeDecoder]\x2C buf);\n};\n\n/**\n * Returns any remaining input stored in the internal buffer as a string.\n * After end() is called\x2C the stringDecoder object can be reused for new\n * input.\n * @param {string | Buffer | TypedArray | DataView} [buf]\n * @returns {string}\n */\nStringDecoder.prototype.end = function end(buf) {\n  let ret = '';\n  if (buf !== undefined)\n    ret = this.write(buf);\n  if (this[kNativeDecoder][kBufferedBytes] > 0)\n    ret += flush(this[kNativeDecoder]);\n  return ret;\n};\n\n/* Everything below this line is undocumented legacy stuff. */\n/**\n *\n * @param {string | Buffer | TypedArray | DataView} buf\n * @param {number} offset\n * @returns {string}\n */\nStringDecoder.prototype.text = function text(buf\x2C offset) {\n  this[kNativeDecoder][kMissingBytes] = 0;\n  this[kNativeDecoder][kBufferedBytes] = 0;\n  return this.write(buf.slice(offset));\n};\n\nObjectDefineProperties(StringDecoder.prototype\x2C {\n  lastChar: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return TypedArrayPrototypeSubarray(this[kNativeDecoder]\x2C\n                                         kIncompleteCharactersStart\x2C\n                                         kIncompleteCharactersEnd);\n    }\x2C\n  }\x2C\n  lastNeed: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n  lastTotal: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kBufferedBytes] +\n             this[kNativeDecoder][kMissingBytes];\n    }\x2C\n  }\x2C\n});\n\nexports.StringDecoder = StringDecoder;\n
code-source-info,0x2ffc4852f9d8,406,0,5213,C0O0C4O5213,,
code-creation,Function,10,55842,0x2ffc4852ff68,387, node:string_decoder:1:1,0x2ffc4852f950,~
code-source-info,0x2ffc4852ff68,406,0,5213,C0O0C70O1159C76O1180C81O1206C86O1216C92O1282C95O1282C100O1271C106O1465C109O1465C114O1311C120O1341C126O1369C132O1386C138O1404C144O1422C150O1431C156O1441C162O1450C167O1521C170O1521C174O1521C176O1627C179O1627C184O1653C189O1557C195O1581C201O1601C207O1680C213O1700C217O1686C220O1680C222O1744C225O1744C229O1744C231O2414C232O2414C234O2431C236O2448C240O2436C245O2463C250O2485C256O2490C260O2458C265O2418C268O3209C277O3225C281O3873C290O3887C294O4274C303O4289C307O4488C317O4513C322O4586C336O4818C341O4891C355O4974C360O5047C374O4451C379O5174C381O5196C386O5212,,
tick,0xd9a9c0,56448,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48527f3c,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,Eval,10,56635,0x2ffc48531130,5, node:internal/fs/watchers:1:1,0x2ffc48530de8,~
script-source,407,node:internal/fs/watchers,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  AbortError\x2C\n  uvException\x2C\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  createDeferredPromise\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\n\nconst {\n  kFsStatsFieldsNumber\x2C\n  StatWatcher: _StatWatcher\x2C\n} = internalBinding('fs');\n\nconst { FSEvent } = internalBinding('fs_event_wrap');\nconst { UV_ENOSPC } = internalBinding('uv');\nconst { EventEmitter } = require('events');\n\nconst {\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n} = require('internal/fs/utils');\n\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { owner_symbol }\x2C\n} = require('internal/async_hooks');\n\nconst { toNamespacedPath } = require('path');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  Buffer: {\n    isEncoding\x2C\n  }\x2C\n} = require('buffer');\n\nconst assert = require('internal/assert');\n\nconst kOldStatus = Symbol('kOldStatus');\nconst kUseBigint = Symbol('kUseBigint');\n\nconst kFSWatchStart = Symbol('kFSWatchStart');\nconst kFSStatWatcherStart = Symbol('kFSStatWatcherStart');\nconst KFSStatWatcherRefCount = Symbol('KFSStatWatcherRefCount');\nconst KFSStatWatcherMaxRefCount = Symbol('KFSStatWatcherMaxRefCount');\nconst kFSStatWatcherAddOrCleanRef = Symbol('kFSStatWatcherAddOrCleanRef');\n\nfunction emitStop(self) {\n  self.emit('stop');\n}\n\nfunction StatWatcher(bigint) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._handle = null;\n  this[kOldStatus] = -1;\n  this[kUseBigint] = bigint;\n  this[KFSStatWatcherRefCount] = 1;\n  this[KFSStatWatcherMaxRefCount] = 1;\n}\nObjectSetPrototypeOf(StatWatcher.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(StatWatcher\x2C EventEmitter);\n\nfunction onchange(newStatus\x2C stats) {\n  const self = this[owner_symbol];\n  if (self[kOldStatus] === -1 &&\n      newStatus === -1 &&\n      stats[2/* new nlink */] === stats[16/* old nlink */]) {\n    return;\n  }\n\n  self[kOldStatus] = newStatus;\n  self.emit('change'\x2C getStatsFromBinding(stats)\x2C\n            getStatsFromBinding(stats\x2C kFsStatsFieldsNumber));\n}\n\n// At the moment if filename is undefined\x2C we\n// 1. Throw an Error if it's the first\n//    time Symbol('kFSStatWatcherStart') is called\n// 2. Return silently if Symbol('kFSStatWatcherStart') has already been called\n//    on a valid filename and the wrap has been initialized\n// This method is a noop if the watcher has already been started.\nStatWatcher.prototype[kFSStatWatcherStart] = function(filename\x2C\n                                                      persistent\x2C\n                                                      interval) {\n  if (this._handle !== null)\n    return;\n\n  this._handle = new _StatWatcher(this[kUseBigint]);\n  this._handle[owner_symbol] = this;\n  this._handle.onchange = onchange;\n  if (!persistent)\n    this.unref();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility.\n  this[kOldStatus] = -1;\n\n  filename = getValidatedPath(filename\x2C 'filename');\n  validateUint32(interval\x2C 'interval');\n  const err = this._handle.start(toNamespacedPath(filename)\x2C interval);\n  if (err) {\n    const error = uvException({\n      errno: err\x2C\n      syscall: 'watch'\x2C\n      path: filename\x2C\n    });\n    error.filename = filename;\n    throw error;\n  }\n};\n\n// To maximize backward-compatibility for the end user\x2C\n// a no-op stub method has been added instead of\n// totally removing StatWatcher.prototype.start.\n// This should not be documented.\nStatWatcher.prototype.start = () => {};\n\n// FIXME(joyeecheung): this method is not documented while there is\n// another documented fs.unwatchFile(). The counterpart in\n// FSWatcher is .close()\n// This method is a noop if the watcher has not been started.\nStatWatcher.prototype.stop = function() {\n  if (this._handle === null)\n    return;\n\n  defaultTriggerAsyncIdScope(this._handle.getAsyncId()\x2C\n                             process.nextTick\x2C\n                             emitStop\x2C\n                             this);\n  this._handle.close();\n  this._handle = null;\n};\n\n// Clean up or add ref counters.\nStatWatcher.prototype[kFSStatWatcherAddOrCleanRef] = function(operate) {\n  if (operate === 'add') {\n    // Add a Ref\n    this[KFSStatWatcherRefCount]++;\n    this[KFSStatWatcherMaxRefCount]++;\n  } else if (operate === 'clean') {\n    // Clean up a single\n    this[KFSStatWatcherMaxRefCount]--;\n    this.unref();\n  } else if (operate === 'cleanAll') {\n    // Clean up all\n    this[KFSStatWatcherMaxRefCount] = 0;\n    this[KFSStatWatcherRefCount] = 0;\n    this._handle?.unref();\n  }\n};\n\nStatWatcher.prototype.ref = function() {\n  // Avoid refCount calling ref multiple times causing unref to have no effect.\n  if (this[KFSStatWatcherRefCount] === this[KFSStatWatcherMaxRefCount])\n    return this;\n  if (this._handle && this[KFSStatWatcherRefCount]++ === 0)\n    this._handle.ref();\n  return this;\n};\n\nStatWatcher.prototype.unref = function() {\n  // Avoid refCount calling unref multiple times causing ref to have no effect.\n  if (this[KFSStatWatcherRefCount] === 0) return this;\n  if (this._handle && --this[KFSStatWatcherRefCount] === 0)\n    this._handle.unref();\n  return this;\n};\n\n\nfunction FSWatcher() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._handle = new FSEvent();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onchange = (status\x2C eventType\x2C filename) => {\n    // TODO(joyeecheung): we may check self._handle.initialized here\n    // and return if that is false. This allows us to avoid firing the event\n    // after the handle is closed\x2C and to fire both UV_RENAME and UV_CHANGE\n    // if they are set by libuv at the same time.\n    if (status < 0) {\n      if (this._handle !== null) {\n        // We don't use this.close() here to avoid firing the close event.\n        this._handle.close();\n        this._handle = null;  // Make the handle garbage collectable.\n      }\n      const error = uvException({\n        errno: status\x2C\n        syscall: 'watch'\x2C\n        path: filename\x2C\n      });\n      error.filename = filename;\n      this.emit('error'\x2C error);\n    } else {\n      this.emit('change'\x2C eventType\x2C filename);\n    }\n  };\n}\nObjectSetPrototypeOf(FSWatcher.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(FSWatcher\x2C EventEmitter);\n\n// At the moment if filename is undefined\x2C we\n// 1. Throw an Error if it's the first time Symbol('kFSWatchStart') is called\n// 2. Return silently if Symbol('kFSWatchStart') has already been called\n//    on a valid filename and the wrap has been initialized\n// 3. Return silently if the watcher has already been closed\n// This method is a noop if the watcher has already been started.\nFSWatcher.prototype[kFSWatchStart] = function(filename\x2C\n                                              persistent\x2C\n                                              recursive\x2C\n                                              encoding) {\n  if (this._handle === null) {  // closed\n    return;\n  }\n  assert(this._handle instanceof FSEvent\x2C 'handle must be a FSEvent');\n  if (this._handle.initialized) {  // already started\n    return;\n  }\n\n  filename = getValidatedPath(filename\x2C 'filename');\n\n  const err = this._handle.start(toNamespacedPath(filename)\x2C\n                                 persistent\x2C\n                                 recursive\x2C\n                                 encoding);\n  if (err) {\n    const error = uvException({\n      errno: err\x2C\n      syscall: 'watch'\x2C\n      path: filename\x2C\n      message: err === UV_ENOSPC ?\n        'System limit for number of file watchers reached' : ''\x2C\n    });\n    error.filename = filename;\n    throw error;\n  }\n};\n\n// To maximize backward-compatibility for the end user\x2C\n// a no-op stub method has been added instead of\n// totally removing FSWatcher.prototype.start.\n// This should not be documented.\nFSWatcher.prototype.start = () => {};\n\n// This method is a noop if the watcher has not been started or\n// has already been closed.\nFSWatcher.prototype.close = function() {\n  if (this._handle === null) {  // closed\n    return;\n  }\n  assert(this._handle instanceof FSEvent\x2C 'handle must be a FSEvent');\n  if (!this._handle.initialized) {  // not started\n    return;\n  }\n  this._handle.close();\n  this._handle = null;  // Make the handle garbage collectable.\n  process.nextTick(emitCloseNT\x2C this);\n};\n\nFSWatcher.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n  return this;\n};\n\nFSWatcher.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n  return this;\n};\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(FSEvent.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\x2C\n});\n\nlet kResistStopPropagation;\n\nasync function* watch(filename\x2C options = kEmptyObject) {\n  const path = toNamespacedPath(getValidatedPath(filename));\n  validateObject(options\x2C 'options');\n\n  const {\n    persistent = true\x2C\n    recursive = false\x2C\n    encoding = 'utf8'\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(persistent\x2C 'options.persistent');\n  validateBoolean(recursive\x2C 'options.recursive');\n  validateAbortSignal(signal\x2C 'options.signal');\n\n  if (encoding && !isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const handle = new FSEvent();\n  let { promise\x2C resolve\x2C reject } = createDeferredPromise();\n  const oncancel = () => {\n    handle.close();\n    reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n  };\n\n  try {\n    if (signal) {\n      kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n      signal.addEventListener('abort'\x2C oncancel\x2C { __proto__: null\x2C once: true\x2C [kResistStopPropagation]: true });\n    }\n    handle.onchange = (status\x2C eventType\x2C filename) => {\n      if (status < 0) {\n        const error = uvException({\n          errno: status\x2C\n          syscall: 'watch'\x2C\n          path: filename\x2C\n        });\n        error.filename = filename;\n        handle.close();\n        reject(error);\n        return;\n      }\n\n      resolve({ eventType\x2C filename });\n    };\n\n    const err = handle.start(path\x2C persistent\x2C recursive\x2C encoding);\n    if (err) {\n      const error = uvException({\n        errno: err\x2C\n        syscall: 'watch'\x2C\n        path: filename\x2C\n        message: err === UV_ENOSPC ?\n          'System limit for number of file watchers reached' : ''\x2C\n      });\n      error.filename = filename;\n      handle.close();\n      throw error;\n    }\n\n    while (!signal?.aborted) {\n      yield await promise;\n      ({ promise\x2C resolve\x2C reject } = createDeferredPromise());\n    }\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  } finally {\n    handle.close();\n    signal?.removeEventListener('abort'\x2C oncancel);\n  }\n}\n\nmodule.exports = {\n  FSWatcher\x2C\n  StatWatcher\x2C\n  kFSWatchStart\x2C\n  kFSStatWatcherStart\x2C\n  kFSStatWatcherAddOrCleanRef\x2C\n  watch\x2C\n};\n
code-source-info,0x2ffc48531130,407,0,11242,C0O0C4O11242,,
code-creation,Function,10,56942,0x2ffc48531d48,751, node:internal/fs/watchers:1:1,0x2ffc485310a8,~
code-source-info,0x2ffc48531d48,407,0,11242,C0O0C127O25C133O50C138O74C143O98C148O208C154O208C159O134C165O148C176O176C182O289C188O289C193O246C199O271C205O381C208O381C213O326C219O363C225O425C228O425C233O413C239O481C242O481C247O467C253O529C259O529C264O512C270O604C276O604C281O559C287O582C293O706C299O706C304O645C315O686C321O769C327O769C332O748C338O877C344O877C349O797C355O820C361O839C367O857C373O955C379O955C384O955C389O934C395O990C401O990C405O990C407O1038C410O1038C414O1038C416O1079C419O1079C423O1079C425O1124C428O1124C433O1177C436O1177C441O1239C444O1239C448O1239C450O1307C453O1307C457O1307C459O1380C462O1380C467O1734C475O1758C480O1701C485O1770C488O1770C493O2532C498O2542C502O2563C506O3602C515O3618C519O3857C528O3872C532O4203C537O4213C541O4242C545O4686C554O4700C558O4999C567O5015C571O6271C579O6295C584O6240C589O6307C592O6307C597O6749C602O6759C606O6774C610O7885C619O7901C623O8016C632O8032C636O8384C645O8398C649O8482C658O8498C662O8778C665O8807C678O8850C686O8890C694O8778C699O8942C700O8942C702O11112C709O11133C715O11146C721O11161C727O11178C733O11201C739O11232C745O11127C750O11241,,
tick,0x7f6e6509cd60,57331,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48527f4f,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,Eval,10,57380,0x2ffc48534da0,5, node:internal/streams/utils:1:1,0x2ffc48534b18,~
script-source,408,node:internal/streams/utils,'use strict';\n\nconst {\n  SymbolAsyncIterator\x2C\n  SymbolIterator\x2C\n  SymbolFor\x2C\n} = primordials;\n\n// We need to use SymbolFor to make these globally available\n// for interopt with readable-stream\x2C i.e. readable-stream\n// and node core needs to be able to read/write private state\n// from each other for proper interoperability.\nconst kIsDestroyed = SymbolFor('nodejs.stream.destroyed');\nconst kIsErrored = SymbolFor('nodejs.stream.errored');\nconst kIsReadable = SymbolFor('nodejs.stream.readable');\nconst kIsWritable = SymbolFor('nodejs.stream.writable');\nconst kIsDisturbed = SymbolFor('nodejs.stream.disturbed');\n\nconst kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise');\nconst kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction');\n\nfunction isReadableNodeStream(obj\x2C strict = false) {\n  return !!(\n    obj &&\n    typeof obj.pipe === 'function' &&\n    typeof obj.on === 'function' &&\n    (\n      !strict ||\n      (typeof obj.pause === 'function' && typeof obj.resume === 'function')\n    ) &&\n    (!obj._writableState || obj._readableState?.readable !== false) && // Duplex\n    (!obj._writableState || obj._readableState) // Writable has .pipe.\n  );\n}\n\nfunction isWritableNodeStream(obj) {\n  return !!(\n    obj &&\n    typeof obj.write === 'function' &&\n    typeof obj.on === 'function' &&\n    (!obj._readableState || obj._writableState?.writable !== false) // Duplex\n  );\n}\n\nfunction isDuplexNodeStream(obj) {\n  return !!(\n    obj &&\n    (typeof obj.pipe === 'function' && obj._readableState) &&\n    typeof obj.on === 'function' &&\n    typeof obj.write === 'function'\n  );\n}\n\nfunction isNodeStream(obj) {\n  return (\n    obj &&\n    (\n      obj._readableState ||\n      obj._writableState ||\n      (typeof obj.write === 'function' && typeof obj.on === 'function') ||\n      (typeof obj.pipe === 'function' && typeof obj.on === 'function')\n    )\n  );\n}\n\nfunction isReadableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.pipeThrough === 'function' &&\n    typeof obj.getReader === 'function' &&\n    typeof obj.cancel === 'function'\n  );\n}\n\nfunction isWritableStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.getWriter === 'function' &&\n    typeof obj.abort === 'function'\n  );\n}\n\nfunction isTransformStream(obj) {\n  return !!(\n    obj &&\n    !isNodeStream(obj) &&\n    typeof obj.readable === 'object' &&\n    typeof obj.writable === 'object'\n  );\n}\n\nfunction isWebStream(obj) {\n  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);\n}\n\nfunction isIterable(obj\x2C isAsync) {\n  if (obj == null) return false;\n  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function';\n  if (isAsync === false) return typeof obj[SymbolIterator] === 'function';\n  return typeof obj[SymbolAsyncIterator] === 'function' ||\n    typeof obj[SymbolIterator] === 'function';\n}\n\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream)) return null;\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n  return !!(stream.destroyed || stream[kIsDestroyed] || state?.destroyed);\n}\n\n// Have been end():d.\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream)) return null;\n  if (stream.writableEnded === true) return true;\n  const wState = stream._writableState;\n  if (wState?.errored) return false;\n  if (typeof wState?.ended !== 'boolean') return null;\n  return wState.ended;\n}\n\n// Have emitted 'finish'.\nfunction isWritableFinished(stream\x2C strict) {\n  if (!isWritableNodeStream(stream)) return null;\n  if (stream.writableFinished === true) return true;\n  const wState = stream._writableState;\n  if (wState?.errored) return false;\n  if (typeof wState?.finished !== 'boolean') return null;\n  return !!(\n    wState.finished ||\n    (strict === false && wState.ended === true && wState.length === 0)\n  );\n}\n\n// Have been push(null):d.\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream)) return null;\n  if (stream.readableEnded === true) return true;\n  const rState = stream._readableState;\n  if (!rState || rState.errored) return false;\n  if (typeof rState?.ended !== 'boolean') return null;\n  return rState.ended;\n}\n\n// Have emitted 'end'.\nfunction isReadableFinished(stream\x2C strict) {\n  if (!isReadableNodeStream(stream)) return null;\n  const rState = stream._readableState;\n  if (rState?.errored) return false;\n  if (typeof rState?.endEmitted !== 'boolean') return null;\n  return !!(\n    rState.endEmitted ||\n    (strict === false && rState.ended === true && rState.length === 0)\n  );\n}\n\nfunction isReadable(stream) {\n  if (stream && stream[kIsReadable] != null) return stream[kIsReadable];\n  if (typeof stream?.readable !== 'boolean') return null;\n  if (isDestroyed(stream)) return false;\n  return isReadableNodeStream(stream) &&\n    stream.readable &&\n    !isReadableFinished(stream);\n}\n\nfunction isWritable(stream) {\n  if (stream && stream[kIsWritable] != null) return stream[kIsWritable];\n  if (typeof stream?.writable !== 'boolean') return null;\n  if (isDestroyed(stream)) return false;\n  return isWritableNodeStream(stream) &&\n    stream.writable &&\n    !isWritableEnded(stream);\n}\n\nfunction isFinished(stream\x2C opts) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (isDestroyed(stream)) {\n    return true;\n  }\n\n  if (opts?.readable !== false && isReadable(stream)) {\n    return false;\n  }\n\n  if (opts?.writable !== false && isWritable(stream)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isWritableErrored(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (stream.writableErrored) {\n    return stream.writableErrored;\n  }\n\n  return stream._writableState?.errored ?? null;\n}\n\nfunction isReadableErrored(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (stream.readableErrored) {\n    return stream.readableErrored;\n  }\n\n  return stream._readableState?.errored ?? null;\n}\n\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n\n  if (typeof stream.closed === 'boolean') {\n    return stream.closed;\n  }\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n\n  if (\n    typeof wState?.closed === 'boolean' ||\n    typeof rState?.closed === 'boolean'\n  ) {\n    return wState?.closed || rState?.closed;\n  }\n\n  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {\n    return stream._closed;\n  }\n\n  return null;\n}\n\nfunction isOutgoingMessage(stream) {\n  return (\n    typeof stream._closed === 'boolean' &&\n    typeof stream._defaultKeepAlive === 'boolean' &&\n    typeof stream._removedConnection === 'boolean' &&\n    typeof stream._removedContLen === 'boolean'\n  );\n}\n\nfunction isServerResponse(stream) {\n  return (\n    typeof stream._sent100 === 'boolean' &&\n    isOutgoingMessage(stream)\n  );\n}\n\nfunction isServerRequest(stream) {\n  return (\n    typeof stream._consuming === 'boolean' &&\n    typeof stream._dumped === 'boolean' &&\n    stream.req?.upgradeOrConnect === undefined\n  );\n}\n\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream)) return null;\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n\n  return (!state && isServerResponse(stream)) || !!(\n    state &&\n    state.autoDestroy &&\n    state.emitClose &&\n    state.closed === false\n  );\n}\n\nfunction isDisturbed(stream) {\n  return !!(stream && (\n    stream[kIsDisturbed] ??\n    (stream.readableDidRead || stream.readableAborted)\n  ));\n}\n\nfunction isErrored(stream) {\n  return !!(stream && (\n    stream[kIsErrored] ??\n    stream.readableErrored ??\n    stream.writableErrored ??\n    stream._readableState?.errorEmitted ??\n    stream._writableState?.errorEmitted ??\n    stream._readableState?.errored ??\n    stream._writableState?.errored\n  ));\n}\n\nmodule.exports = {\n  isDestroyed\x2C\n  kIsDestroyed\x2C\n  isDisturbed\x2C\n  kIsDisturbed\x2C\n  isErrored\x2C\n  kIsErrored\x2C\n  isReadable\x2C\n  kIsReadable\x2C\n  kIsClosedPromise\x2C\n  kControllerErrorFunction\x2C\n  kIsWritable\x2C\n  isClosed\x2C\n  isDuplexNodeStream\x2C\n  isFinished\x2C\n  isIterable\x2C\n  isReadableNodeStream\x2C\n  isReadableStream\x2C\n  isReadableEnded\x2C\n  isReadableFinished\x2C\n  isReadableErrored\x2C\n  isNodeStream\x2C\n  isWebStream\x2C\n  isWritable\x2C\n  isWritableNodeStream\x2C\n  isWritableStream\x2C\n  isWritableEnded\x2C\n  isWritableFinished\x2C\n  isWritableErrored\x2C\n  isServerRequest\x2C\n  isServerResponse\x2C\n  willEmitClose\x2C\n  isTransformStream\x2C\n};\n
code-source-info,0x2ffc48534da0,408,0,8416,C0O0C4O8416,,
code-creation,Function,10,57633,0x2ffc48535a88,460, node:internal/streams/utils:1:1,0x2ffc48534d18,~
code-source-info,0x2ffc48535a88,408,0,8416,C0O0C169O25C175O48C181O66C186O346C190O346C194O346C196O403C200O403C204O403C206O459C210O459C214O459C216O516C220O516C224O516C226O574C230O574C234O574C236O638C240O638C245O718C249O718C254O7817C262O7838C268O7853C274O7869C280O7884C286O7900C292O7913C298O7927C304O7941C310O7956C316O7976C322O8004C328O8019C334O8031C340O8053C346O8067C352O8081C358O8105C364O8125C370O8144C376O8166C382O8187C388O8203C394O8218C400O8232C406O8256C412O8276C418O8295C424O8317C430O8338C436O8357C442O8377C448O8394C454O7832C459O8415,,
code-creation,Eval,10,58367,0x2ffc48539a38,5, node:internal/readline/interface:1:1,0x2ffc48538590,~
script-source,409,node:internal/readline/interface,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReverse\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeUnshift\x2C\n  DateNow\x2C\n  FunctionPrototypeCall\x2C\n  MathCeil\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMaxApply\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeTrim\x2C\n  Symbol\x2C\n  SymbolDispose\x2C\n  SymbolAsyncIterator\x2C\n  SafeStringIterator\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_USE_AFTER_CLOSE\x2C\n} = codes;\nconst {\n  validateAbortSignal\x2C\n  validateArray\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst { kEmptyObject } = require('internal/util');\nconst {\n  inspect\x2C\n  getStringWidth\x2C\n  stripVTControlCharacters\x2C\n} = require('internal/util/inspect');\nconst EventEmitter = require('events');\nconst {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  kSubstringSearch\x2C\n} = require('internal/readline/utils');\nlet emitKeypressEvents;\nconst {\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n} = require('internal/readline/callbacks');\n\nconst { StringDecoder } = require('string_decoder');\n\n// Lazy load Readable for startup performance.\nlet Readable;\n\nconst kHistorySize = 30;\nconst kMaxUndoRedoStackSize = 2048;\nconst kMincrlfDelay = 100;\n// \\r\\n\x2C \\n\x2C or \\r followed by something other than \\n\nconst lineEnding = /\\r?\\n|\\r(?!\\n)/g;\n\nconst kLineObjectStream = Symbol('line object stream');\nconst kQuestionCancel = Symbol('kQuestionCancel');\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nconst ESCAPE_CODE_TIMEOUT = 500;\n\n// Max length of the kill ring\nconst kMaxLengthOfKillRing = 32;\n\nconst kAddHistory = Symbol('_addHistory');\nconst kBeforeEdit = Symbol('_beforeEdit');\nconst kDecoder = Symbol('_decoder');\nconst kDeleteLeft = Symbol('_deleteLeft');\nconst kDeleteLineLeft = Symbol('_deleteLineLeft');\nconst kDeleteLineRight = Symbol('_deleteLineRight');\nconst kDeleteRight = Symbol('_deleteRight');\nconst kDeleteWordLeft = Symbol('_deleteWordLeft');\nconst kDeleteWordRight = Symbol('_deleteWordRight');\nconst kGetDisplayPos = Symbol('_getDisplayPos');\nconst kHistoryNext = Symbol('_historyNext');\nconst kHistoryPrev = Symbol('_historyPrev');\nconst kInsertString = Symbol('_insertString');\nconst kLine = Symbol('_line');\nconst kLine_buffer = Symbol('_line_buffer');\nconst kKillRing = Symbol('_killRing');\nconst kKillRingCursor = Symbol('_killRingCursor');\nconst kMoveCursor = Symbol('_moveCursor');\nconst kNormalWrite = Symbol('_normalWrite');\nconst kOldPrompt = Symbol('_oldPrompt');\nconst kOnLine = Symbol('_onLine');\nconst kPreviousKey = Symbol('_previousKey');\nconst kPrompt = Symbol('_prompt');\nconst kPushToKillRing = Symbol('_pushToKillRing');\nconst kPushToUndoStack = Symbol('_pushToUndoStack');\nconst kQuestionCallback = Symbol('_questionCallback');\nconst kRedo = Symbol('_redo');\nconst kRedoStack = Symbol('_redoStack');\nconst kRefreshLine = Symbol('_refreshLine');\nconst kSawKeyPress = Symbol('_sawKeyPress');\nconst kSawReturnAt = Symbol('_sawReturnAt');\nconst kSetRawMode = Symbol('_setRawMode');\nconst kTabComplete = Symbol('_tabComplete');\nconst kTabCompleter = Symbol('_tabCompleter');\nconst kTtyWrite = Symbol('_ttyWrite');\nconst kUndo = Symbol('_undo');\nconst kUndoStack = Symbol('_undoStack');\nconst kWordLeft = Symbol('_wordLeft');\nconst kWordRight = Symbol('_wordRight');\nconst kWriteToOutput = Symbol('_writeToOutput');\nconst kYank = Symbol('_yank');\nconst kYanking = Symbol('_yanking');\nconst kYankPop = Symbol('_yankPop');\n\nfunction InterfaceConstructor(input\x2C output\x2C completer\x2C terminal) {\n  this[kSawReturnAt] = 0;\n  // TODO(BridgeAR): Document this property. The name is not ideal\x2C so we\n  // might want to expose an alias and document that instead.\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  let history;\n  let historySize;\n  let removeHistoryDuplicates = false;\n  let crlfDelay;\n  let prompt = '> ';\n  let signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n    if (input.tabSize !== undefined) {\n      validateUint32(input.tabSize\x2C 'tabSize'\x2C true);\n      this.tabSize = input.tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    if (input.prompt !== undefined) {\n      prompt = input.prompt;\n    }\n    if (input.escapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(input.escapeCodeTimeout)) {\n        this.escapeCodeTimeout = input.escapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\n          'input.escapeCodeTimeout'\x2C\n          this.escapeCodeTimeout\x2C\n        );\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal\x2C 'options.signal');\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== 'function') {\n    throw new ERR_INVALID_ARG_VALUE('completer'\x2C completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history\x2C 'history');\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (\n    typeof historySize !== 'number' ||\n      NumberIsNaN(historySize) ||\n      historySize < 0\n  ) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('historySize'\x2C historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  const self = this;\n\n  this.line = '';\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing\x2C the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring\x2C users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts\x2C quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ?\n    MathMax(kMincrlfDelay\x2C crlfDelay) :\n    kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n\n  function onerror(err) {\n    self.emit('error'\x2C err);\n  }\n\n  function ondata(data) {\n    self[kNormalWrite](data);\n  }\n\n  function onend() {\n    if (\n      typeof self[kLine_buffer] === 'string' &&\n        self[kLine_buffer].length > 0\n    ) {\n      self.emit('line'\x2C self[kLine_buffer]);\n    }\n    self.close();\n  }\n\n  function ontermend() {\n    if (typeof self.line === 'string' && self.line.length > 0) {\n      self.emit('line'\x2C self.line);\n    }\n    self.close();\n  }\n\n  function onkeypress(s\x2C key) {\n    self[kTtyWrite](s\x2C key);\n    if (key && key.sequence) {\n      // If the key.sequence is half of a surrogate pair\n      // (>= 0xd800 and <= 0xdfff)\x2C refresh the line so\n      // the character is displayed appropriately.\n      const ch = StringPrototypeCodePointAt(key.sequence\x2C 0);\n      if (ch >= 0xd800 && ch <= 0xdfff) self[kRefreshLine]();\n    }\n  }\n\n  function onresize() {\n    self[kRefreshLine]();\n  }\n\n  this[kLineObjectStream] = undefined;\n\n  input.on('error'\x2C onerror);\n\n  if (!this.terminal) {\n    function onSelfCloseWithoutTerminal() {\n      input.removeListener('data'\x2C ondata);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C onend);\n    }\n\n    input.on('data'\x2C ondata);\n    input.on('end'\x2C onend);\n    self.once('close'\x2C onSelfCloseWithoutTerminal);\n    this[kDecoder] = new StringDecoder('utf8');\n  } else {\n    function onSelfCloseWithTerminal() {\n      input.removeListener('keypress'\x2C onkeypress);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C ontermend);\n      if (output !== null && output !== undefined) {\n        output.removeListener('resize'\x2C onresize);\n      }\n    }\n\n    emitKeypressEvents ??= require('internal/readline/emitKeypressEvents');\n    emitKeypressEvents(input\x2C this);\n\n    // `input` usually refers to stdin\n    input.on('keypress'\x2C onkeypress);\n    input.on('end'\x2C ontermend);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined)\n      output.on('resize'\x2C onresize);\n\n    self.once('close'\x2C onSelfCloseWithTerminal);\n  }\n\n  if (signal) {\n    const onAborted = () => self.close();\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      const disposable = EventEmitter.addAbortListener(signal\x2C onAborted);\n      self.once('close'\x2C disposable[SymbolDispose]);\n    }\n  }\n\n  // Current line\n  this.line = '';\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor\x2C EventEmitter);\n\nclass Interface extends InterfaceConstructor {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input\x2C output\x2C completer\x2C terminal) {\n    super(input\x2C output\x2C completer\x2C terminal);\n  }\n  get columns() {\n    if (this.output && this.output.columns) return this.output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    const wasInRawMode = this.input.isRaw;\n\n    if (typeof this.input.setRawMode === 'function') {\n      this.input.setRawMode(mode);\n    }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== 'dumb') {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  question(query\x2C cb) {\n    if (this.closed) {\n      throw new ERR_USE_AFTER_CLOSE('readline');\n    }\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      const cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit('line'\x2C line);\n    }\n  }\n\n  [kBeforeEdit](oldText\x2C oldCursor) {\n    this[kPushToUndoStack](oldText\x2C oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite\x2C 'stringToWrite');\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return '';\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        const dupIndex = ArrayPrototypeIndexOf(this.history\x2C this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice(this.history\x2C dupIndex\x2C 1);\n      }\n\n      ArrayPrototypeUnshift(this.history\x2C this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize)\n        ArrayPrototypePop(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object\x2C possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history\x2C like a password\n    const line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit('history'\x2C this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    const line = this[kPrompt] + this.line;\n    const dispPos = this[kGetDisplayPos](line);\n    const lineCols = dispPos.cols;\n    const lineRows = dispPos.rows;\n\n    // cursor position\n    const cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line\x2C based on cursor pos\n    const prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output\x2C 0\x2C -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output\x2C 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](' ');\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output\x2C cursorPos.cols);\n\n    const diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output\x2C 0\x2C -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit('close');\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit('pause');\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit('resume');\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d\x2C key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d\x2C key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    let string = this[kDecoder].write(b);\n    if (\n      this[kSawReturnAt] &&\n      DateNow() - this[kSawReturnAt] <= this.crlfDelay\n    ) {\n      if (StringPrototypeCodePointAt(string) === 10) string = StringPrototypeSlice(string\x2C 1);\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk\x2C not on the entire line buffer.\n    let newPartContainsEnding = RegExpPrototypeExec(lineEnding\x2C string);\n    if (newPartContainsEnding !== null) {\n      if (this[kLine_buffer]) {\n        string = this[kLine_buffer] + string;\n        this[kLine_buffer] = null;\n        lineEnding.lastIndex = 0; // Start the search from the beginning of the string.\n        newPartContainsEnding = RegExpPrototypeExec(lineEnding\x2C string);\n      }\n      this[kSawReturnAt] = StringPrototypeEndsWith(string\x2C '\\r') ?\n        DateNow() :\n        0;\n\n      const indexes = [0\x2C newPartContainsEnding.index\x2C lineEnding.lastIndex];\n      let nextMatch;\n      while ((nextMatch = RegExpPrototypeExec(lineEnding\x2C string)) !== null) {\n        ArrayPrototypePush(indexes\x2C nextMatch.index\x2C lineEnding.lastIndex);\n      }\n      const lastIndex = indexes.length - 1;\n      // Either '' or (conceivably) the unfinished portion of the next line\n      this[kLine_buffer] = StringPrototypeSlice(string\x2C indexes[lastIndex]);\n      for (let i = 1; i < lastIndex; i += 2) {\n        this[kOnLine](StringPrototypeSlice(string\x2C indexes[i - 1]\x2C indexes[i]));\n      }\n    } else if (string) {\n      // No newlines this time\x2C save what we have for next time\n      if (this[kLine_buffer]) {\n        this[kLine_buffer] += string;\n      } else {\n        this[kLine_buffer] = string;\n      }\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    if (this.cursor < this.line.length) {\n      const beg = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const end = StringPrototypeSlice(\n        this.line\x2C\n        this.cursor\x2C\n        this.line.length\x2C\n      );\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      const oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      const newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    const string = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    let value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab\x2C value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab\x2C { 0: completions\x2C 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches\x2C then apply that portion.\n    const prefix = commonPrefix(\n      ArrayPrototypeFilter(completions\x2C (e) => e !== '')\x2C\n    );\n    if (StringPrototypeStartsWith(prefix\x2C completeOn) &&\n        prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice(prefix\x2C completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith(completeOn\x2C prefix)) {\n      this.line = StringPrototypeSlice(this.line\x2C\n                                       0\x2C\n                                       this.cursor - completeOn.length) +\n                  prefix +\n                  StringPrototypeSlice(this.line\x2C\n                                       this.cursor\x2C\n                                       this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line\x2C this.cursor);\n\n    // Apply/show completions.\n    const completionsWidth = ArrayPrototypeMap(completions\x2C (e) =>\n      getStringWidth(e)\x2C\n    );\n    const width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    let maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    let output = '\\r\\n';\n    let lineIndex = 0;\n    let whitespace = 0;\n    for (let i = 0; i < completions.length; i++) {\n      const completion = completions[i];\n      if (completion === '' || lineIndex === maxColumns) {\n        output += '\\r\\n';\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat(' '\x2C whitespace);\n      }\n      if (completion !== '') {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += '\\r\\n';\n      }\n    }\n    if (lineIndex !== 0) {\n      output += '\\r\\n\\r\\n';\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      const leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\x2C\n      );\n      const match = RegExpPrototypeExec(/^\\s*(?:[^\\w\\s]+|\\w+)?/\x2C reversed);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = RegExpPrototypeExec(/^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/\x2C trailing);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthLeft(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - charSize) +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthAt(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(\n          this.line\x2C\n          this.cursor + charSize\x2C\n          this.line.length\x2C\n        );\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      let leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\x2C\n      );\n      const match = RegExpPrototypeExec(/^\\s*(?:[^\\w\\s]+|\\w+)?/\x2C reversed);\n      leading = StringPrototypeSlice(\n        leading\x2C\n        0\x2C\n        leading.length - match[0].length\x2C\n      );\n      this.line =\n        leading +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = RegExpPrototypeExec(/^(?:\\s+|\\W+|\\w+)\\s*/\x2C trailing);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(trailing\x2C match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift(this[kKillRing]\x2C del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      const lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      const currentYank = this[kKillRing][this[kKillRingCursor]];\n      const head =\n            StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - lastYank.length);\n      const tail =\n            StringPrototypeSlice(this.line\x2C this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput]('\\r\\n');\n    this.line = '';\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    const line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text\x2C cursor) {\n    if (ArrayPrototypePush(this[kUndoStack]\x2C { text\x2C cursor }) >\n        kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kRedoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kUndoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  // TODO(BridgeAR): Add underscores to the search part and a red background in\n  // case no match is found. This should only be the visual part and not the\n  // actual line content!\n  // TODO(BridgeAR): In case the substring based search is active and the end is\n  // reached\x2C show a comment how to search the history as before. E.g.\x2C using\n  // <ctrl> + N. Only show this after two/three UPs or DOWNs\x2C not on the first\n  // one.\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    let offset = 0;\n    const col = this.columns;\n    let rows = 0;\n    str = stripVTControlCharacters(str);\n    for (const char of new SafeStringIterator(str)) {\n      if (char === '\\n') {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === '\\t') {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      const width = getStringWidth(char\x2C false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    const cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols\x2C rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   *   }}\n   */\n  getCursorPos() {\n    const strBeforeCursor =\n      this[kPrompt] + StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    const oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    const newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      const diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output\x2C diffWidth\x2C 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s\x2C key) {\n    const previousKey = this[kPreviousKey];\n    key = key || kEmptyObject;\n    this[kPreviousKey] = key;\n\n    if (!key.meta || key.name !== 'y') {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if (\n      (key.name === 'up' || key.name === 'down') &&\n      !key.ctrl &&\n      !key.meta &&\n      !key.shift\n    ) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice(\n          this.line\x2C\n          0\x2C\n          this.cursor\x2C\n        );\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof key.sequence === 'string') {\n      switch (StringPrototypeCodePointAt(key.sequence\x2C 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key\x2C fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (key.name === 'escape') return;\n\n    if (key.ctrl && key.shift) {\n      /* Control and shift pressed */\n      switch (key.name) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case 'backspace':\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (key.ctrl) {\n      /* Control key pressed */\n\n      switch (key.name) {\n        case 'c':\n          if (this.listenerCount('SIGINT') > 0) {\n            this.emit('SIGINT');\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case 'h': // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case 'd': // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case 'u': // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'k': // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case 'a': // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'e': // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'b': // back one character\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'f': // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'l': // Clear the whole screen\n          cursorTo(this.output\x2C 0\x2C 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case 'n': // next history item\n          this[kHistoryNext]();\n          break;\n\n        case 'p': // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case 'y': // Yank killed string\n          this[kYank]();\n          break;\n\n        case 'z':\n          if (process.platform === 'win32') break;\n          if (this.listenerCount('SIGTSTP') > 0) {\n            this.emit('SIGTSTP');\n          } else {\n            process.once('SIGCONT'\x2C () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT\x2C SIGTSTP\x2C and EOF.\n                this.pause();\n                this.emit('SIGCONT');\n              }\n              // Explicitly re-enable "raw mode" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid\x2C 'SIGTSTP');\n          }\n          break;\n\n        case 'w': // Delete backwards to a word boundary\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        // Falls through\n        case 'backspace':\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'delete': // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case 'left':\n          this[kWordLeft]();\n          break;\n\n        case 'right':\n          this[kWordRight]();\n          break;\n      }\n    } else if (key.meta) {\n      /* Meta key pressed */\n\n      switch (key.name) {\n        case 'b': // backward word\n          this[kWordLeft]();\n          break;\n\n        case 'f': // forward word\n          this[kWordRight]();\n          break;\n\n        case 'd': // delete forward word\n        case 'delete':\n          this[kDeleteWordRight]();\n          break;\n\n        case 'backspace': // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'y': // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && key.name !== 'enter') this[kSawReturnAt] = 0;\n\n      switch (key.name) {\n        case 'return': // Carriage return\x2C i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case 'enter':\n          // When key interval > crlfDelay\n          if (\n            this[kSawReturnAt] === 0 ||\n            DateNow() - this[kSawReturnAt] > this.crlfDelay\n          ) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case 'backspace':\n          this[kDeleteLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteRight]();\n          break;\n\n        case 'left':\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'right':\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'home':\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'end':\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'up':\n          this[kHistoryPrev]();\n          break;\n\n        case 'down':\n          this[kHistoryNext]();\n          break;\n\n        case 'tab':\n          // If tab completion enabled\x2C do that...\n          if (\n            typeof this.completer === 'function' &&\n            this.isCompletionEnabled\n          ) {\n            const lastKeypressWasTab =\n              previousKey && previousKey.name === 'tab';\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === 'string' && s) {\n            // Erase state of previous searches.\n            lineEnding.lastIndex = 0;\n            let nextMatch;\n            // Keep track of the end of the last match.\n            let lastIndex = 0;\n            while ((nextMatch = RegExpPrototypeExec(lineEnding\x2C s)) !== null) {\n              this[kInsertString](StringPrototypeSlice(s\x2C lastIndex\x2C nextMatch.index));\n              ({ lastIndex } = lineEnding);\n              this[kLine]();\n              // Restore lastIndex as the call to kLine could have mutated it.\n              lineEnding.lastIndex = lastIndex;\n            }\n            // This ensures that the last line is written if it doesn't end in a newline.\n            // Note that the last line may be the first line\x2C in which case this still works.\n            this[kInsertString](StringPrototypeSlice(s\x2C lastIndex));\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator\x2C\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      if (Readable === undefined) {\n        Readable = require('stream').Readable;\n      }\n      const readable = new Readable({\n        objectMode: true\x2C\n        read: () => {\n          this.resume();\n        }\x2C\n        destroy: (err\x2C cb) => {\n          this.off('line'\x2C lineListener);\n          this.off('close'\x2C closeListener);\n          this.close();\n          cb(err);\n        }\x2C\n      });\n      const lineListener = (input) => {\n        if (!readable.push(input)) {\n          // TODO(rexagod): drain to resume flow\n          this.pause();\n        }\n      };\n      const closeListener = () => {\n        readable.push(null);\n      };\n      const errorListener = (err) => {\n        readable.destroy(err);\n      };\n      this.on('error'\x2C errorListener);\n      this.on('line'\x2C lineListener);\n      this.on('close'\x2C closeListener);\n      this[kLineObjectStream] = readable;\n    }\n\n    return this[kLineObjectStream][SymbolAsyncIterator]();\n  }\n}\n\nmodule.exports = {\n  Interface\x2C\n  InterfaceConstructor\x2C\n  kAddHistory\x2C\n  kDecoder\x2C\n  kDeleteLeft\x2C\n  kDeleteLineLeft\x2C\n  kDeleteLineRight\x2C\n  kDeleteRight\x2C\n  kDeleteWordLeft\x2C\n  kDeleteWordRight\x2C\n  kGetDisplayPos\x2C\n  kHistoryNext\x2C\n  kHistoryPrev\x2C\n  kInsertString\x2C\n  kLine\x2C\n  kLine_buffer\x2C\n  kMoveCursor\x2C\n  kNormalWrite\x2C\n  kOldPrompt\x2C\n  kOnLine\x2C\n  kPreviousKey\x2C\n  kPrompt\x2C\n  kQuestionCallback\x2C\n  kQuestionCancel\x2C\n  kRefreshLine\x2C\n  kSawKeyPress\x2C\n  kSawReturnAt\x2C\n  kSetRawMode\x2C\n  kTabComplete\x2C\n  kTabCompleter\x2C\n  kTtyWrite\x2C\n  kWordLeft\x2C\n  kWordRight\x2C\n  kWriteToOutput\x2C\n};\n
code-source-info,0x2ffc48539a38,409,0,39788,C0O0C4O39788,,
code-creation,Function,10,59490,0x2ffc4853c5e8,1852, node:internal/readline/interface:1:1,0x2ffc485399b0,~
code-source-info,0x2ffc4853c5e8,409,0,39788,C0O0C318O25C324O38C330O62C336O87C342O109C348O130C354O151C360O173C366O198C372O222C378O245C384O270C390O281C396O306C402O318C408O331C414O342C420O358C426O376C432O391C437O415C443O438C449O468C455O495C461O520C467O544C473O573C479O596C484O606C490O623C496O646C502O702C508O702C513O692C518O741C524O766C530O886C536O886C541O808C547O831C553O848C559O866C565O943C571O943C576O926C582O1038C588O1038C593O979C599O990C605O1008C611O1093C617O1093C621O1093C623O1194C629O1194C634O1122C640O1138C646O1156C652O1172C658O1234C659O1234C661O1311C667O1311C672O1264C678O1283C684O1295C690O1378C696O1378C701O1360C707O1457C708O1457C710O1489C712O1489C714O1523C718O1523C720O1551C722O1551C724O1630C728O1630C730O1676C733O1676C737O1676C739O1730C742O1730C747O1846C751O1846C753O1912C755O1912C757O1937C760O1937C764O1937C766O1980C769O1980C773O1980C775O2020C778O2020C782O2020C784O2060C787O2060C791O2060C793O2107C796O2107C800O2107C802O2159C805O2159C809O2159C811O2208C814O2208C818O2208C820O2256C823O2256C827O2256C829O2308C832O2308C836O2308C838O2359C841O2359C845O2359C847O2406C850O2406C854O2406C856O2451C859O2451C863O2451C865O2497C868O2497C872O2497C874O2536C877O2536C881O2536C883O2574C886O2574C890O2574C892O2616C895O2616C899O2616C901O2661C904O2661C908O2661C910O2708C913O2708C917O2708C919O2752C922O2752C926O2752C928O2795C931O2795C935O2795C937O2833C940O2833C944O2833C946O2873C949O2873C953O2873C955O2913C958O2913C962O2913C964O2956C967O2956C971O2956C973O3008C976O3008C980O3008C982O3062C985O3062C989O3062C991O3105C994O3105C998O3105C1000O3141C1003O3141C1007O3141C1009O3184C1012O3184C1016O3184C1018O3229C1021O3229C1025O3229C1027O3274C1030O3274C1034O3274C1036O3318C1039O3318C1043O3318C1045O3362C1048O3362C1052O3362C1054O3408C1057O3408C1061O3408C1063O3451C1066O3451C1070O3451C1072O3486C1075O3486C1079O3486C1081O3522C1084O3522C1088O3522C1090O3562C1093O3562C1097O3562C1099O3602C1102O3602C1106O3602C1108O3647C1111O3647C1115O3647C1117O3687C1120O3687C1124O3687C1126O3721C1129O3721C1133O3721C1135O3758C1138O3758C1142O3758C1144O9467C1152O9491C1157O9425C1162O9503C1165O9503C1170O9586C1193O10181C1214O11077C1224O11323C1232O11414C1244O11586C1254O11787C1264O12969C1298O15103C1308O16841C1318O17520C1328O17917C1338O20129C1348O20594C1358O20856C1368O21342C1378O21827C1388O22591C1398O23022C1408O23304C1418O23566C1428O23830C1438O23989C1454O24821C1464O24979C1474O25170C1484O25482C1494O26225C1504O26863C1514O27646C1530O29051C1540O29645C1550O38203C1575O39224C1582O39245C1588O39258C1594O39282C1600O39297C1606O39309C1612O39324C1618O39343C1624O39363C1630O39379C1636O39398C1642O39418C1648O39436C1654O39452C1660O39468C1666O39485C1672O39494C1678O39510C1684O39525C1690O39541C1696O39555C1702O39566C1712O39582C1722O39593C1732O39614C1742O39633C1752O39649C1762O39665C1772O39681C1782O39696C1792O39712C1802O39729C1812O39742C1822O39755C1832O39769C1842O39239C1851O39787,,
tick,0x7f6e650178bf,59568,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48527fd5,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
tick,0x7f6e64f8e610,59576,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x2ffc48527fd5,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
new,MemoryChunk,0x287bc380000,262144
code-creation,Eval,10,59850,0x287bc3817a8,5, node:internal/readline/utils:1:1,0x287bc3815b0,~
script-source,410,node:internal/readline/utils,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  RegExpPrototypeExec\x2C\n  StringFromCharCode\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nconst kEscape = '\\x1b';\nconst kSubstringSearch = Symbol('kSubstringSearch');\n\nfunction CSI(strings\x2C ...args) {\n  let ret = `${kEscape}[`;\n  for (let n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length)\n      ret += args[n];\n  }\n  return ret;\n}\n\nCSI.kEscape = kEscape;\nCSI.kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = CSI`0K`;\nCSI.kClearLine = CSI`2K`;\nCSI.kClearScreenDown = CSI`0J`;\n\n// TODO(BridgeAR): Treat combined characters as single character\x2C i.e\x2C\n// 'a\\u0301' and '\\u0301a' (both have the same visual output).\n// Check Canonical_Combining_Class in\n// http://userguide.icu-project.org/strings/properties\nfunction charLengthLeft(str\x2C i) {\n  if (i <= 0)\n    return 0;\n  if ((i > 1 &&\n      StringPrototypeCodePointAt(str\x2C i - 2) >= kUTF16SurrogateThreshold) ||\n      StringPrototypeCodePointAt(str\x2C i - 1) >= kUTF16SurrogateThreshold) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str\x2C i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt(str\x2C i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes\x2C derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    let ch = yield;\n    let s = ch;\n    let escaped = false;\n    const key = {\n      sequence: null\x2C\n      name: undefined\x2C\n      ctrl: false\x2C\n      meta: false\x2C\n      shift: false\x2C\n    };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += (ch = yield);\n\n      if (ch === kEscape) {\n        s += (ch = yield);\n      }\n    }\n\n    if (escaped && (ch === 'O' || ch === '[')) {\n      // ANSI escape sequence\n      let code = ch;\n      let modifier = 0;\n\n      if (ch === 'O') {\n        // ESC O letter\n        // ESC O modifier letter\n        s += (ch = yield);\n\n        if (ch >= '0' && ch <= '9') {\n          modifier = (ch >> 0) - 1;\n          s += (ch = yield);\n        }\n\n        code += ch;\n      } else if (ch === '[') {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += (ch = yield);\n\n        if (ch === '[') {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += (ch = yield);\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional\x2C e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *  - there is also special case when there can be 3 digits\n         *    but without modifier. They are the case of paste bracket mode\n         *\n         * So the generic regexp is like /^(?:\\d\\d?(;\\d)?[~^$]|\\d{3}~)$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional\x2C e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional\x2C e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        const cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= '0' && ch <= '9') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += (ch = yield);\n\n            if (ch >= '0' && ch <= '9') {\n              s += (ch = yield);\n            }\n          }\n        }\n\n        // skip modifier\n        if (ch === ';') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data\x2C now trying to extract code\n         * and modifier from it\n         */\n        const cmd = StringPrototypeSlice(s\x2C cmdStart);\n        let match;\n\n        if ((match = RegExpPrototypeExec(/^(?:(\\d\\d?)(?:;(\\d))?([~^$])|(\\d{3}~))$/\x2C cmd))) {\n          if (match[4]) {\n            code += match[4];\n          } else {\n            code += match[1] + match[3];\n            modifier = (match[2] || 1) - 1;\n          }\n        } else if (\n          (match = RegExpPrototypeExec(/^((\\d;)?(\\d))?([A-Za-z])$/\x2C cmd))\n        ) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case '[P': key.name = 'f1'; break;\n        case '[Q': key.name = 'f2'; break;\n        case '[R': key.name = 'f3'; break;\n        case '[S': key.name = 'f4'; break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case 'OP': key.name = 'f1'; break;\n        case 'OQ': key.name = 'f2'; break;\n        case 'OR': key.name = 'f3'; break;\n        case 'OS': key.name = 'f4'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[11~': key.name = 'f1'; break;\n        case '[12~': key.name = 'f2'; break;\n        case '[13~': key.name = 'f3'; break;\n        case '[14~': key.name = 'f4'; break;\n\n        /* paste bracket mode */\n        case '[200~': key.name = 'paste-start'; break;\n        case '[201~': key.name = 'paste-end'; break;\n\n        /* from Cygwin and used in libuv */\n        case '[[A': key.name = 'f1'; break;\n        case '[[B': key.name = 'f2'; break;\n        case '[[C': key.name = 'f3'; break;\n        case '[[D': key.name = 'f4'; break;\n        case '[[E': key.name = 'f5'; break;\n\n        /* common */\n        case '[15~': key.name = 'f5'; break;\n        case '[17~': key.name = 'f6'; break;\n        case '[18~': key.name = 'f7'; break;\n        case '[19~': key.name = 'f8'; break;\n        case '[20~': key.name = 'f9'; break;\n        case '[21~': key.name = 'f10'; break;\n        case '[23~': key.name = 'f11'; break;\n        case '[24~': key.name = 'f12'; break;\n\n        /* xterm ESC [ letter */\n        case '[A': key.name = 'up'; break;\n        case '[B': key.name = 'down'; break;\n        case '[C': key.name = 'right'; break;\n        case '[D': key.name = 'left'; break;\n        case '[E': key.name = 'clear'; break;\n        case '[F': key.name = 'end'; break;\n        case '[H': key.name = 'home'; break;\n\n        /* xterm/gnome ESC O letter */\n        case 'OA': key.name = 'up'; break;\n        case 'OB': key.name = 'down'; break;\n        case 'OC': key.name = 'right'; break;\n        case 'OD': key.name = 'left'; break;\n        case 'OE': key.name = 'clear'; break;\n        case 'OF': key.name = 'end'; break;\n        case 'OH': key.name = 'home'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[1~': key.name = 'home'; break;\n        case '[2~': key.name = 'insert'; break;\n        case '[3~': key.name = 'delete'; break;\n        case '[4~': key.name = 'end'; break;\n        case '[5~': key.name = 'pageup'; break;\n        case '[6~': key.name = 'pagedown'; break;\n\n        /* putty */\n        case '[[5~': key.name = 'pageup'; break;\n        case '[[6~': key.name = 'pagedown'; break;\n\n        /* rxvt */\n        case '[7~': key.name = 'home'; break;\n        case '[8~': key.name = 'end'; break;\n\n        /* rxvt keys with modifiers */\n        case '[a': key.name = 'up'; key.shift = true; break;\n        case '[b': key.name = 'down'; key.shift = true; break;\n        case '[c': key.name = 'right'; key.shift = true; break;\n        case '[d': key.name = 'left'; key.shift = true; break;\n        case '[e': key.name = 'clear'; key.shift = true; break;\n\n        case '[2$': key.name = 'insert'; key.shift = true; break;\n        case '[3$': key.name = 'delete'; key.shift = true; break;\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\n        case '[7$': key.name = 'home'; key.shift = true; break;\n        case '[8$': key.name = 'end'; key.shift = true; break;\n\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n        /* misc. */\n        case '[Z': key.name = 'tab'; key.shift = true; break;\n        default: key.name = 'undefined'; break;\n      }\n    } else if (ch === '\\r') {\n      // carriage return\n      key.name = 'return';\n      key.meta = escaped;\n    } else if (ch === '\\n') {\n      // Enter\x2C should have been called linefeed\n      key.name = 'enter';\n      key.meta = escaped;\n    } else if (ch === '\\t') {\n      // tab\n      key.name = 'tab';\n      key.meta = escaped;\n    } else if (ch === '\\b' || ch === '\\x7f') {\n      // backspace or ctrl+h\n      key.name = 'backspace';\n      key.meta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      key.name = 'escape';\n      key.meta = escaped;\n    } else if (ch === ' ') {\n      key.name = 'space';\n      key.meta = escaped;\n    } else if (!escaped && ch <= '\\x1a') {\n      // ctrl+letter\n      key.name = StringFromCharCode(\n        StringPrototypeCharCodeAt(ch) + StringPrototypeCharCodeAt('a') - 1\x2C\n      );\n      key.ctrl = true;\n    } else if (RegExpPrototypeExec(/^[0-9A-Za-z]$/\x2C ch) !== null) {\n      // Letter\x2C number\x2C shift+letter\n      key.name = StringPrototypeToLowerCase(ch);\n      key.shift = RegExpPrototypeExec(/^[A-Z]$/\x2C ch) !== null;\n      key.meta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      key.name = ch.length ? undefined : 'escape';\n      key.meta = true;\n    }\n\n    key.sequence = s;\n\n    if (s.length !== 0 && (key.name !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit('keypress'\x2C escaped ? undefined : s\x2C key);\n    } else if (charLengthAt(s\x2C 0) === s.length) {\n      /* Single unnamed character\x2C e.g. "." */\n      stream.emit('keypress'\x2C s\x2C key);\n    }\n    /* Unrecognized or broken escape sequence\x2C don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(strings));\n  const min = sorted[0];\n  const max = sorted[sorted.length - 1];\n  for (let i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice(min\x2C 0\x2C i);\n    }\n  }\n  return min;\n}\n\nmodule.exports = {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  emitKeys\x2C\n  kSubstringSearch\x2C\n  CSI\x2C\n};\n
code-source-info,0x287bc3817a8,410,0,12396,C0O0C4O12396,,
code-creation,Function,10,60198,0x287bc381bf0,237, node:internal/readline/utils:1:1,0x287bc381720,~
code-source-info,0x287bc381bf0,410,0,12396,C0O0C61O25C67O48C73O70C79O93C85O115C91O144C97O174C103O198C109O228C114O287C120O287C122O323C124O323C126O356C129O356C134O581C136O593C140O635C144O635C148O630C152O666C156O666C160O661C164O692C168O692C172O687C176O724C180O724C184O719C188O12285C195O12306C201O12322C207O12340C213O12356C219O12368C225O12388C231O12300C236O12395,,
code-creation,LazyCompile,10,60293,0x287bc382db8,75,CSI node:internal/readline/utils:19:13,0x287bc3817d8,~
code-source-info,0x287bc382db8,410,397,579,C0O397C8O430C20O460C22O475C26O465C31O494C33O508C43O530C47O523C52O544C54O555C64O484C69O447C72O566C74O577,,
code-creation,Eval,10,60403,0x287bc384010,5, node:internal/readline/callbacks:1:1,0x287bc383e28,~
script-source,411,node:internal/readline/callbacks,'use strict';\n\nconst {\n  NumberIsNaN\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_CURSOR_POS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  CSI\x2C\n} = require('internal/readline/utils');\n\nconst {\n  kClearLine\x2C\n  kClearScreenDown\x2C\n  kClearToLineBeginning\x2C\n  kClearToLineEnd\x2C\n} = CSI;\n\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream\x2C x\x2C y\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (typeof y === 'function') {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE('x'\x2C x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE('y'\x2C y);\n\n  if (stream == null || (typeof x !== 'number' && typeof y !== 'number')) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  if (typeof x !== 'number') throw new ERR_INVALID_CURSOR_POS();\n\n  const data = typeof y !== 'number' ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data\x2C callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream\x2C dx\x2C dy\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  let data = '';\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data\x2C callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream\x2C dir\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  const type =\n    dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type\x2C callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream\x2C callback) {\n  if (callback !== undefined) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown\x2C callback);\n}\n\nmodule.exports = {\n  clearLine\x2C\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n};\n
code-source-info,0x287bc384010,411,0,2754,C0O0C4O2754,,
code-creation,Function,10,60491,0x287bc3842e0,179, node:internal/readline/callbacks:1:1,0x287bc383f88,~
code-source-info,0x287bc3842e0,411,0,2754,C0O0C56O25C62O139C65O139C70O139C75O79C81O106C87O200C90O200C95O178C101O251C104O251C109O242C115O378C118O298C124O312C130O332C136O357C142O2674C149O2695C155O2708C161O2727C167O2739C173O2689C178O2753,,
tick,0x133d766,60534,1,0xb795c0,6,0xdd1310,0x65c50a3,0x65c42db,0x2ffc4853c883,0x65c5168,0x65c42db,0x2ffc48527fd5,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,LazyCompile,10,60677,0x287bc3850c8,302,promisify node:internal/util:404:19,0x28d42e288828,~
code-source-info,0x287bc3850c8,21,11090,12933,C0O11090C17O11152C25O11192C33O11216C38O11195C55O11252C68O11252C73O11295C80O11308C82O11307C87O11352C94O11361C96O11360C100O11393C110O11393C115O11445C126O11477C136O11541C143O11452C148O11608C149O11771C156O11780C158O11779C161O11771C163O12335C174O12360C180O12360C185O12335C190O12396C201O12421C211O12481C218O12396C223O12570C233O12570C238O12640C245O12640C250O12682C252O12706C256O12687C261O12829C270O12866C276O12829C281O12715C286O12669C289O12884C296O12891C301O12931,,
code-creation,LazyCompile,10,60805,0x287bc385608,112,EventEmitterMixin node:internal/event_target:1113:27,0x13800b155568,~
script-source,52,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst {\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('util');\nconst webidl = require('internal/webidl');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('kHandlers');\nconst kWeakHandler = Symbol('kWeak');\nconst kResistStopPropagation = Symbol('kResistStopPropagation');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kRemoveWeakListenerHelper = Symbol('nodejs.internal.removeWeakListenerHelper');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\nconst kType = Symbol('type');\nconst kDetail = Symbol('detail');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\x2C\n}\x2C 'isTrusted').get;\n\nconst isTrustedDescriptor = {\n  __proto__: null\x2C\n  configurable: false\x2C\n  enumerable: true\x2C\n  get: isTrusted\x2C\n};\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  #cancelable = false;\n  #bubbles = false;\n  #composed = false;\n  #defaultPrevented = false;\n  #timestamp = now();\n  #propagationStopped = false;\n\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options');\n    const { bubbles\x2C cancelable\x2C composed } = options;\n    this.#cancelable = !!cancelable;\n    this.#bubbles = !!bubbles;\n    this.#composed = !!composed;\n\n    this[kType] = `${type}`;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this.#defaultPrevented\x2C\n      cancelable: this.#cancelable\x2C\n      timeStamp: this.#timestamp\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#defaultPrevented = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable && this.#defaultPrevented;\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#timestamp;\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.#cancelable || !this.#defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#bubbles;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#composed;\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#propagationStopped;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#propagationStopped = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n    // Don't conform to the spec with isTrusted. The spec defines it as\n    // LegacyUnforgeable but defining it in the constructor has a big\n    // performance impact and the property doesn't seem to be useful outside of\n    // browsers.\n    isTrusted: isTrustedDescriptor\x2C\n  });\n\nfunction isCustomEvent(value) {\n  return isEvent(value) && (value?.[kDetail] !== undefined);\n}\n\nclass CustomEvent extends Event {\n  /**\n   * @constructor\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   *   detail?: any\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    super(type\x2C options);\n    this[kDetail] = options?.detail ?? null;\n  }\n\n  /**\n   * @type {any}\n   */\n  get detail() {\n    if (!isCustomEvent(this))\n      throw new ERR_INVALID_THIS('CustomEvent');\n    return this[kDetail];\n  }\n}\n\nObjectDefineProperties(CustomEvent.prototype\x2C {\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'CustomEvent'\x2C\n  }\x2C\n  detail: kEnumerableProperty\x2C\n});\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    ({ eventTarget\x2C listener\x2C eventType }) => eventTarget.deref()?.[kRemoveWeakListenerHelper](eventType\x2C listener)\x2C\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\nconst kFlagOnce = 1 << 0;\nconst kFlagCapture = 1 << 1;\nconst kFlagPassive = 1 << 2;\nconst kFlagNodeStyle = 1 << 3;\nconst kFlagWeak = 1 << 4;\nconst kFlagRemoved = 1 << 5;\nconst kFlagResistStopPropagation = 1 << 6;\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(eventTarget\x2C eventType\x2C previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak\x2C resistStopPropagation) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n\n    let flags = 0b0;\n    if (once)\n      flags |= kFlagOnce;\n    if (capture)\n      flags |= kFlagCapture;\n    if (passive)\n      flags |= kFlagPassive;\n    if (isNodeStyleListener)\n      flags |= kFlagNodeStyle;\n    if (weak)\n      flags |= kFlagWeak;\n    if (resistStopPropagation)\n      flags |= kFlagResistStopPropagation;\n    this.flags = flags;\n\n    this.removed = false;\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C {\n        __proto__: null\x2C\n        // Weak ref so the listener won't hold the eventTarget alive\n        eventTarget: new SafeWeakRef(eventTarget)\x2C\n        listener: this\x2C\n        eventType\x2C\n      }\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = async (...args) => {\n        if (listener.handleEvent)\n          await ReflectApply(listener.handleEvent\x2C listener\x2C args);\n      };\n      this.listener = listener;\n    }\n  }\n\n  get once() {\n    return Boolean(this.flags & kFlagOnce);\n  }\n  get capture() {\n    return Boolean(this.flags & kFlagCapture);\n  }\n  get passive() {\n    return Boolean(this.flags & kFlagPassive);\n  }\n  get isNodeStyleListener() {\n    return Boolean(this.flags & kFlagNodeStyle);\n  }\n  get weak() {\n    return Boolean(this.flags & kFlagWeak);\n  }\n  get resistStopPropagation() {\n    return Boolean(this.flags & kFlagResistStopPropagation);\n  }\n  get removed() {\n    return Boolean(this.flags & kFlagRemoved);\n  }\n  set removed(value) {\n    if (value)\n      this.flags |= kFlagRemoved;\n    else\n      this.flags &= ~kFlagRemoved;\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the validateListener check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n      resistStopPropagation\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!validateEventListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = webidl.converters.DOMString(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { __proto__: null\x2C once: true\x2C [kWeakHandler]: this\x2C [kResistStopPropagation]: true });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined\x2C resistStopPropagation: Boolean(resistStopPropagation) };\n      // This is the first handler in our linked list.\n      new Listener(this\x2C type\x2C root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak\x2C resistStopPropagation);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(this\x2C type\x2C previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak\x2C resistStopPropagation);\n    root.size++;\n    root.resistStopPropagation ||= Boolean(resistStopPropagation);\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n    if (!validateEventListener(listener))\n      return;\n\n    type = webidl.converters.DOMString(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  [kRemoveWeakListenerHelper](type\x2C listener) {\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    const capture = listener.capture === true;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler === listener) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        // Undefined is passed as the listener as the listener was GCed\n        this[kRemoveListener](root.size\x2C type\x2C undefined\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 1)\n      throw new ERR_MISSING_ARGS('event');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    const iterationCondition = () => {\n      if (handler === undefined) {\n        return false;\n      }\n      return root.resistStopPropagation || handler.passive || event?.[kStop] !== true;\n    };\n    while (iterationCondition()) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed || (event?.[kStop] === true && !handler.resistStopPropagation)) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        // And the case of event.stopImmediatePropagation() being called\n        // For events not flagged as resistStopPropagation\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x2C\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\x2C\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} type\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction validateEventListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  if (typeof listener === 'object') {\n    // Require `handleEvent` lazily.\n    return true;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return kEmptyObject;\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    resistStopPropagation: options[kResistStopPropagation] ?? false\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\x2C\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    __proto__: null\x2C\n    get() {\n      return this[kHandlers]?.get(name)?.handler ?? null;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  const propertiesValues = ObjectValues(protoProps);\n  for (let i = 0; i < propertiesValues.length; i++) {\n    // We want to use null-prototype objects to not rely on globally mutable\n    // %Object.prototype%.\n    ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n  }\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  CustomEvent\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  kResistStopPropagation\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x287bc385608,52,29717,30407,C0O29769C23O29953C30O29985C33O29998C38O29953C43O30012C47O30070C52O30070C57O30111C59O30135C63O30116C68O30258C75O30295C81O30258C86O30144C91O30098C94O30313C99O30354C104O30313C109O30380C111O30405,,
tick,0x7f6e64f8e672,61670,0,0x0,3,0x12da7b0,0x2ffc48528019,0x65c5168,0x65c42db,0x2ffc48522c24,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,LazyCompile,10,61861,0x287bc388070,188,readFile node:internal/fs/promises:1018:24,0x2ffc48525ed8,~
code-source-info,0x287bc388070,403,27717,28038,C10O27717C18O27737C23O27758C28O27747C35O27806C44O27822C46O27842C48O27831C53O27858C56O27865C69O27895C70O27899C73O27920C78O27899C82O27943C96O27949C109O27943C135O27976C141O27997C147O28029C152O27983C165O28036,,
code-creation,LazyCompile,10,61897,0x287bc38a400,56,checkAborted node:internal/fs/promises:430:22,0x2ffc48525168,~
code-source-info,0x287bc38a400,403,9974,10073,C0O9987C7O9997C16O10012C23O10033C35O10059C48O10018C53O10012C55O10072,,
code-creation,LazyCompile,10,61929,0x287bc38a5c8,178,open node:internal/fs/promises:580:20,0x2ffc48525348,~
code-source-info,0x287bc38a5c8,403,14502,14808,C10O14502C18O14526C23O14533C29O14579C34O14579C39O14603C55O14610C62O14648C69O14681C72O14689C79O14704C82O14715C87O14715C95O14791C104O14689C117O14675C142O14655C155O14806,,
code-creation,LazyCompile,10,61954,0x287bc38a790,37, node:internal/fs/utils:712:42,0x1d7bd0eca1c0,~
code-source-info,0x287bc38a790,60,19527,19662,C14O19582C19O19582C24O19616C29O19616C34O19648C36O19660,,
code-creation,LazyCompile,10,62015,0x287bc38ab80,515,stringToFlags node:internal/fs/utils:587:23,0x1d7bd0ec9fe0,~
code-source-info,0x287bc38ab80,60,16116,17350,C14O16144C20O16181C25O16181C30O16213C32O16226C33O16234C38O16259C42O16275C43O16283C202O16315C206O16331C207O16381C214O16399C216O16397C219O16406C220O16423C224O16437C225O16489C232O16505C234O16503C237O16512C238O16529C245O16546C247O16544C253O16556C255O16554C258O16565C259O16615C266O16632C268O16630C274O16642C276O16640C282O16653C284O16651C287O16660C288O16678C295O16695C297O16693C303O16705C305O16703C308O16712C309O16762C316O16779C318O16777C324O16789C326O16787C332O16798C334O16796C337O16805C338O16822C345O16840C347O16838C353O16850C355O16848C358O16859C359O16909C366O16927C368O16925C374O16937C376O16935C382O16948C384O16946C387O16955C388O17005C395O17023C397O17021C403O17033C405O17031C411O17044C413O17042C416O17051C417O17069C424O17087C426O17085C432O17097C434O17095C437O17104C438O17154C445O17172C447O17170C453O17182C455O17180C461O17191C463O17189C466O17198C467O17248C474O17266C476O17264C482O17276C484O17274C490O17285C492O17283C495O17292C496O17300C509O17306C514O17300,,
code-creation,LazyCompile,10,62057,0x287bc38af58,86,parseFileMode node:internal/validators:69:23,0x23f41f7bbd90,~
code-source-info,0x287bc38af58,20,1651,1940,C0O1674C11O1691C17O1728C24O1752C27O1732C34O1787C41O1832C52O1793C57O1787C58O1853C66O1861C73O1894C78O1894C83O1925C85O1938,,
code-creation,LazyCompile,10,62096,0x287bc38b150,148, node:internal/validators:137:40,0x23f41f7bbe80,~
code-source-info,0x287bc38b150,20,3512,3944,C16O3551C22O3588C38O3594C43O3588C44O3649C49O3654C55O3684C71O3690C76O3684C77O3757C87O3817C90O3834C92O3844C99O3859C104O3872C114O3911C127O3924C140O3878C145O3872C147O3943,,
tick,0x7f6e64f94117,62731,1,0xba6860,6,0xdd1310,0x287bc38a630,0x287bc3880d0,0x2ffc48522c33,0x2ffc48521de8,0x2ffc485207f4,0x2ffc4852050b,0x2ffc4851fb0e,0x2ffc4851e11e,0x2ffc4851dc8d,0x2ffc4850adc3,0x16c843f
code-creation,LazyCompile,10,62793,0x287bc38b4f0,229,link node:internal/modules/esm/module_job:66:18,0x2ffc4851f910,~
code-source-info,0x287bc38b4f0,401,1855,2680,C4O1855C26O1875C36O1900C48O1889C73O1887C77O1921C89O1933C98O1951C100O1940C104O1921C108O2267C110O2267C112O2294C117O2299C122O2306C132O2306C138O2526C140O2564C147O2570C159O2564C184O2621C194O2628C206O2674,,
code-creation,LazyCompile,10,62854,0x287bc38b800,225,set node:internal/modules/esm/module_map:97:6,0x3a1b5d33c960,~
code-source-info,0x287bc38b800,393,3086,3677,C11O3099C21O3131C31O3131C36O3163C46O3163C51O3216C59O3216C64O3264C66O3272C71O3293C82O3348C100O3354C105O3348C106O3415C118O3432C133O3456C135O3452C146O3496C157O3415C161O3557C163O3563C174O3563C187O3575C192O3575C197O3599C199O3622C203O3633C205O3646C219O3646C224O3673,,
code-creation,LazyCompile,10,62890,0x287bc38ba18,89,logger node:internal/util/debuglog:101:18,0x28d42e2a70d8,~
code-source-info,0x287bc38ba18,28,2980,3175,C0O2980C3O3012C24O3036C30O3053C34O3043C38O3058C39O3073C45O3090C51O3099C55O3080C60O3104C61O3120C65O3127C72O3140C77O3136C83O3127C88O3165,,
code-creation,LazyCompile,10,62921,0x287bc38bb88,140,debug node:internal/util/debuglog:82:15,0x28d42e2a7038,~
code-source-info,0x287bc38bb88,28,2468,2862,C0O2468C3O2487C6O2487C9O2595C16O2616C22O2603C30O2601C36O2635C42O2671C47O2674C50O2671C54O2699C75O2723C81O2740C85O2730C89O2745C90O2760C96O2777C102O2786C106O2767C111O2791C112O2807C116O2814C123O2827C128O2823C134O2814C139O2852,,
code-creation,LazyCompile,10,62942,0x287bc38bd38,41,init node:internal/util/debuglog:78:16,0x28d42e2a6fe8,~
code-source-info,0x287bc38bd38,28,2370,2453,C0O2379C10O2385C14O2383C16O2422C26O2432C33O2430C40O2452,,
code-creation,LazyCompile,10,62957,0x287bc38be30,2,testEnabled node:internal/util/debuglog:32:19,0x3a1b5d315968,~
code-source-info,0x287bc38be30,28,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,62986,0x287bc38bfb0,116,debuglogImpl node:internal/util/debuglog:55:22,0x28d42e2a6d98,~
code-source-info,0x287bc38bfb0,28,1569,2106,C0O1569C9O1588C18O1602C23O1629C34O1662C39O1670C43O1662C45O1681C55O1681C59O1713C71O1724C75O1729C83O2045C97O2063C99O2061C103O2081C112O2098C115O2104,,
code-creation,LazyCompile,10,63008,0x287bc38c168,10, node:internal/modules/esm/module_map:13:63,0x3a1b5d33c690,~
code-source-info,0x287bc38c168,393,297,322,C0O309C2O315C9O321,,
code-creation,LazyCompile,10,63020,0x287bc38c220,2,noop node:internal/util/debuglog:47:14,0x28d42e2a6cf8,~
code-source-info,0x287bc38c220,28,1419,1427,C1O1426,,
code-creation,LazyCompile,10,63079,0x287bc38c628,431,run node:internal/modules/esm/module_job:190:12,0x2ffc4851eb08,~
code-source-info,0x287bc38c628,401,6883,8082,C10O6883C18O6903C23O6903C35O6892C58O6938C61O6968C66O7002C71O7009C76O7009C90O6991C128O7067C133O7072C143O7079C152O7113C158O7151C163O7113C169O7171C182O7181C186O7216C196O7248C204O7220C211O7282C224O7292C228O7378C235O7409C240O7416C248O7378C259O7447C267O7497C272O7504C277O7447C283O7509C294O7533C299O7587C304O7615C309O7622C314O7588C320O7654C327O7659C332O7685C346O7832C360O7775C366O7855C372O7934C378O7695C382O8011C384O8011C385O8030C390O8069C408O8078,,
code-creation,LazyCompile,10,63111,0x287bc38c958,24,instantiate node:internal/modules/esm/module_job:98:14,0x2ffc4851ea68,~
code-source-info,0x287bc38c958,401,3078,3212,C0O3096C6O3157C11O3157C15O3150C19O3195C23O3208,,
code-creation,LazyCompile,10,63212,0x287bc38cfd0,942,_instantiate node:internal/modules/esm/module_job:105:21,0x2ffc4851eab8,~
code-source-info,0x287bc38cfd0,401,3234,6870,C4O3234C29O3263C37O3263C42O3263C44O3315C48O3315C50O3581C54O3587C67O3581C97O3636C105O3664C111O3686C118O3701C126O3737C136O3737C142O3765C147O3812C153O3819C159O3837C165O3795C172O3874C178O3881C184O3881C203O3928C215O3928C219O4268C227O4273C236O4309C244O4335C254O4309C261O4445C273O4468C283O4445C289O4512C304O4581C313O4512C319O4658C337O4758C343O4658C350O4630C358O4649C366O4817C372O4824C382O4894C392O4824C406O4806C431O4789C436O4931C441O5235C447O5242C453O5242C467O5224C492O5201C503O5343C505O5354C510O5406C512O5416C516O5736C530O5736C536O5824C542O5859C559O5859C565O5939C575O5968C594O6027C605O6008C612O6089C619O6166C630O6282C645O6318C653O6369C672O6244C675O5949C679O6439C691O6462C701O6439C707O6486C719O6518C727O6498C731O6539C739O6549C747O6549C752O6547C756O6609C758O6609C759O6657C791O6640C822O6640C825O6815C829O6844C831O6842C835O6629C916O6869,,
code-creation,LazyCompile,10,63255,0x287bc38d640,146,addJobsToDependencyGraph node:internal/modules/esm/module_job:107:38,0x287bc38cd08,~
code-source-info,0x287bc38d640,401,3315,3575,C10O3315C18O3344C23O3360C28O3360C35O3386C44O3393C45O3408C50O3420C55O3420C60O3481C72O3465C98O3495C107O3543C110O3502C123O3569,,
code-creation,LazyCompile,10,63310,0x287bc38d7f0,112,FileHandle node:internal/fs/promises:131:14,0x2ffc48525f28,~
code-source-info,0x287bc38d7f0,403,3205,3371,C3O3224C11O3224C40O3237C45O3242C50O3251C54O3269C59O3274C67O3281C69O3305C77O3279C81O3319C86O3324C91O3331C95O3340C100O3345C104O3360C111O3370,,
code-creation,LazyCompile,10,63334,0x287bc38d968,63,MixedEventEmitter node:internal/event_target:1115:16,0x287bc3853e8,~
code-source-info,0x287bc38d968,52,29797,29927,C0O29797C8O29815C15O29822C21O29857C25O29866C29O29857C41O29879C48O29901C54O29879C62O29926,,
code-creation,LazyCompile,10,63358,0x287bc38dac0,3, node:internal/per_context/primordials:338:21,0x23f41f787f18,~
code-source-info,0x287bc38dac0,12,9645,9674,C0O9656C2O9668,,
code-creation,LazyCompile,10,63505,0x287bc38dd98,707,readFileHandle node:internal/fs/promises:470:30,0x2ffc48525208,~
code-source-info,0x287bc38dd98,403,11248,13358,C10O11248C18O11289C25O11296C33O11325C40O11332C48O11362C52O11378C58O11374C64O11406C68O11406C72O11450C78O11464C84O11481C95O11492C99O11464C113O11450C141O11510C145O11510C149O11546C151O11564C153O11569C155O11584C162O11600C164O11598C171O11612C173O11608C178O11627C180O11644C184O11663C190O11683C196O11697C200O11683C210O11734C211O11745C216O11758C221O11804C223O11815C225O11813C230O11833C238O11839C243O11833C244O11891C246O11909C252O11916C258O11916C264O11956C267O11975C269O11984C271O12015C273O12024C275O12022C279O12069C283O12069C287O12096C291O12121C299O12143C306O12156C310O12130C316O12209C322O12224C328O12240C340O12314C353O12224C367O12210C400O12339C402O12352C409O12368C410O12382C417O12409C422O12451C426O12440C433O12462C435O12503C437O12513C441O12556C452O12628C456O12617C461O12662C470O12662C477O12704C481O12729C482O12738C489O12748C491O12772C497O12772C502O12819C508O12833C514O12833C529O12860C530O12879C540O12893C541O12909C545O12949C551O12949C565O12968C566O13001C572O13001C584O13020C594O13034C595O13046C599O13086C605O13086C619O13112C620O13121C625O13136C632O13175C641O13241C647O13241C652O13284C658O13300C666O13316C670O13300C676O12050,,
code-creation,LazyCompile,10,63542,0x287bc38e278,8,get fd node:internal/fs/promises:144:9,0x2ffc48525fe0,~
code-source-info,0x287bc38e278,403,3442,3472,C0O3451C2O3463C4O3462C7O3468,,
code-creation,LazyCompile,10,63601,0x287bc38e480,79,handleFdClose node:internal/fs/promises:397:29,0x2ffc485250c8,~
code-source-info,0x287bc38e480,403,9146,9489,C0O9146C23O9177C30O9210C43O9184C56O9487,,
code-creation,LazyCompile,10,63697,0x287bc38e600,19,allocUnsafeSlow node:buffer:427:50,0x28d42e2be1d8,~
script-source,30,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetBuffer\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeGetByteOffset\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeSet\x2C\n  TypedArrayPrototypeSlice\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  isAscii: bindingIsAscii\x2C\n  isUtf8: bindingIsUtf8\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n} = internalBinding('buffer');\nconst {\n  constants: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\x2C\n  }\x2C\n  getOwnNonIndexProperties\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\x2C\n  defineLazyProperties\x2C\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isTypedArray\x2C\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\x2C\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\x2C\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\x2C\n} = require('internal/buffer');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    __proto__: null\x2C\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n  MAX_STRING_LENGTH: {\n    __proto__: null\x2C\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\x2C\n  }\x2C\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0 || sourceStart > source.length)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C `>= 0 && <= ${source.length}`\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\x2C\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\x2C\n  );\n};\n\n/**\n * Creates the Buffer as a copy of the underlying ArrayBuffer of the view\n * rather than the contents of the view.\n * @param {TypedArray} view\n * @param {number} [offset]\n * @param {number} [length]\n * @returns {Buffer}\n */\nBuffer.copyBytesFrom = function copyBytesFrom(view\x2C offset\x2C length) {\n  if (!isTypedArray(view)) {\n    throw new ERR_INVALID_ARG_TYPE('view'\x2C [ 'TypedArray' ]\x2C view);\n  }\n\n  const viewLength = TypedArrayPrototypeGetLength(view);\n  if (viewLength === 0) {\n    return Buffer.alloc(0);\n  }\n\n  if (offset !== undefined || length !== undefined) {\n    if (offset !== undefined) {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n      if (offset >= viewLength) return Buffer.alloc(0);\n    } else {\n      offset = 0;\n    }\n    let end;\n    if (length !== undefined) {\n      validateInteger(length\x2C 'length'\x2C 0);\n      end = offset + length;\n    } else {\n      end = viewLength;\n    }\n\n    view = TypedArrayPrototypeSlice(view\x2C offset\x2C end);\n  }\n\n  return fromArrayLike(new Uint8Array(\n    TypedArrayPrototypeGetBuffer(view)\x2C\n    TypedArrayPrototypeGetByteOffset(view)\x2C\n    TypedArrayPrototypeGetByteLength(view)));\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\x2C\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x2C\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\x2C\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\x2C\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\x2C\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\x2C\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\x2C\n  }\x2C\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\x2C\n    );\n  }\n\n  const len = string.length;\n  if (len === 0)\n    return 0;\n\n  if (encoding) {\n    const ops = getEncodingOps(encoding);\n    if (ops) {\n      return ops.byteLength(string);\n    }\n  }\n  return byteLengthUtf8(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\x2C\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\x2C\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C this.hexSlice(0\x2C actualMax)\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\x2C\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\x2C\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\x2C\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\x2C\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\n// Refs: https://infra.spec.whatwg.org/#forgiving-base64-decode\nconst kForgivingBase64AllowedChars = [\n  // ASCII whitespace\n  // Refs: https://infra.spec.whatwg.org/#ascii-whitespace\n  0x09\x2C 0x0A\x2C 0x0C\x2C 0x0D\x2C 0x20\x2C\n\n  // Uppercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('A') + i)\x2C\n\n  // Lowercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('a') + i)\x2C\n\n  // Decimal digits\n  ...ArrayFrom({ length: 10 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('0') + i)\x2C\n\n  0x2B\x2C // +\n  0x2F\x2C // /\n  0x3D\x2C // =\n];\nconst kEqualSignIndex = ArrayPrototypeIndexOf(kForgivingBase64AllowedChars\x2C\n                                              0x3D);\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n\n  input = `${input}`;\n  let nonAsciiWhitespaceCharCount = 0;\n  let equalCharCount = 0;\n\n  for (let n = 0; n < input.length; n++) {\n    const index = ArrayPrototypeIndexOf(\n      kForgivingBase64AllowedChars\x2C\n      StringPrototypeCharCodeAt(input\x2C n));\n\n    if (index > 4) {\n      // The first 5 elements of `kForgivingBase64AllowedChars` are\n      // ASCII whitespace char codes.\n      nonAsciiWhitespaceCharCount++;\n\n      if (index === kEqualSignIndex) {\n        equalCharCount++;\n      } else if (equalCharCount) {\n        // The `=` char is only allowed at the end.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n\n      if (equalCharCount > 2) {\n        // Only one more `=` is permitted after the first equal sign.\n        throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n      }\n    } else if (index === -1) {\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n    }\n  }\n\n  let reminder = nonAsciiWhitespaceCharCount % 4;\n\n  // See #2\x2C #3\x2C #4 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (!reminder) {\n    // Remove all trailing `=` characters and get the new reminder.\n    reminder = (nonAsciiWhitespaceCharCount - equalCharCount) % 4;\n  } else if (equalCharCount) {\n    // `=` should not in the input if there's a reminder.\n    throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n\n  // See #3 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (reminder === 1) {\n    throw lazyDOMException(\n      'The string to be decoded is not correctly encoded.'\x2C\n      'InvalidCharacterError');\n  }\n\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nfunction isUtf8(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsUtf8(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['TypedArray'\x2C 'Buffer']\x2C input);\n}\n\nfunction isAscii(input) {\n  if (isTypedArray(input) || isAnyArrayBuffer(input)) {\n    return bindingIsAscii(input);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('input'\x2C ['ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray']\x2C input);\n}\n\nmodule.exports = {\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  isUtf8\x2C\n  isAscii\x2C\n\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\x2C\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\x2C\n  }\x2C\n});\n\ndefineLazyProperties(\n  module.exports\x2C\n  'internal/blob'\x2C\n  ['Blob'\x2C 'resolveObjectURL']\x2C\n);\ndefineLazyProperties(\n  module.exports\x2C\n  'internal/file'\x2C\n  ['File']\x2C\n);\n
code-source-info,0x287bc38e600,30,12493,12558,C0O12504C5O12504C9O12524C14O12531C18O12556,,
tick,0x7f6e653749da,64849,0,0x0,3,0x12da7b0,0x287bc38de9a,0x16c843f
code-creation,LazyCompile,10,64861,0x287bc391360,54, node:buffer:393:36,0x28d42e2be0e8,~
code-source-info,0x287bc391360,30,11471,11626,C0O11485C8O11485C13O11517C14O11528C21O11544C23O11541C28O11563C33O11595C46O11569C51O11563C53O11625,,
tick,0xdb7d0c,64911,0,0x0,2,0x12da7b0,0x287bc391368,0x287bc38e605,0x287bc38de9a,0x16c843f
code-creation,LazyCompile,10,64923,0x287bc3914e8,177,validateNumber node:internal/validators:175:24,0x23f41f7bc008,~
code-source-info,0x287bc3914e8,20,4453,4898,C19O4493C25O4528C41O4534C46O4528C47O4586C54O4612C66O4644C83O4693C86O4693C92O4720C110O4789C136O4821C151O4865C169O4726C174O4720C176O4897,,
code-creation,LazyCompile,10,65371,0x287bc391708,36, node:internal/fs/promises:400:5,0x287bc38e350,~
code-source-info,0x287bc391708,403,9229,9288,C0O9229C9O9241C21O9262C30O9241C35O9288,,
code-creation,LazyCompile,10,65420,0x287bc391a00,248,close node:internal/fs/promises:211:11,0x2ffc485284e8,~
code-source-info,0x287bc391a00,403,4715,5507,C0O4727C7O4736C9O4735C15O4741C20O4757C27O4764C30O4781C31O4793C38O4802C40O4801C45O4826C52O4838C54O4837C57O4853C58O4865C65O4870C73O4876C77O4884C84O4893C86O4892C91O4900C96O4915C103O4920C108O4925C112O4937C119O4942C126O4959C136O5001C138O5000C142O5010C147O5010C157O4959C162O4957C168O5099C175O5104C182O5121C189O5162C199O5158C210O5121C215O5119C219O5452C222O5457C230O5457C235O5476C242O5488C244O5487C247O5503,,
code-creation,LazyCompile,10,65487,0x287bc391de8,33,primordials.SafePromisePrototypeFinally node:internal/per_context/primordials:468:43,0x23f41f788e60,~
code-source-info,0x287bc391de8,12,13686,13960,C0O13686C13O13819C27O13819C32O13960,,
code-creation,LazyCompile,10,65517,0x287bc391f80,46, node:internal/per_context/primordials:471:15,0x287bc391d38,~
code-source-info,0x287bc391f80,12,13831,13955,C0O13945C14O13845C20O13919C28O13926C34O13944C39O13945C45O13955,,
code-creation,LazyCompile,10,65538,0x287bc3920c0,27,SafePromise node:internal/per_context/primordials:455:16,0x23f41f788e10,~
code-source-info,0x287bc3920c0,12,13151,13182,C3O13164C7O13170C11O13164C26O13181,,
code-creation,LazyCompile,10,65558,0x287bc3921b8,22, node:internal/per_context/primordials:472:21,0x287bc391ec8,~
code-source-info,0x287bc3921b8,12,13861,13910,C0O13871C16O13871C21O13910,,
code-creation,LazyCompile,10,65591,0x287bc3922a8,17, node:internal/fs/promises:225:9,0x287bc3917e8,~
code-source-info,0x287bc3922a8,403,5027,5069,C0O5035C7O5040C11O5055C16O5068,,
code-creation,LazyCompile,10,65609,0x287bc392380,3, node:internal/fs/promises:400:51,0x287bc391658,~
code-source-info,0x287bc392380,403,9275,9287,C0O9281C2O9287,,
code-creation,LazyCompile,10,65636,0x287bc392448,31,validateLoadResult node:internal/modules/esm/loader:422:21,0x3a1b5d336678,~
code-source-info,0x287bc392448,392,14068,14201,C0O14088C5O14116C13O14116C18O14152C23O14153C30O14200,,
code-creation,LazyCompile,10,65701,0x287bc392740,196,moduleStrategy node:internal/modules/esm/translators:147:56,0x3a1b5d33fe20,~
code-source-info,0x287bc392740,395,4746,5242,C0O4746C27O4772C40O4772C45O4816C50O4825C56O4846C66O4846C71O4882C83O4918C88O4882C92O4943C113O4943C119O5018C127O5018C132O4999C137O5074C142O5131C154O5193C158O5059C163O5226C173O5240,,
code-creation,LazyCompile,10,65736,0x287bc393638,83,assertBufferSource node:internal/modules/esm/translators:93:28,0x3a1b5d33fbf0,~
code-source-info,0x287bc393638,395,2860,3254,C0O2894C10O2945C11O2952C12O3007C15O3007C19O2967C24O2986C29O3026C35O3053C41O3083C42O3090C43O3097C50O3149C77O3103C82O3097,,
code-creation,LazyCompile,10,65757,0x287bc393790,31,lazyTypes node:internal/modules/esm/translators:27:19,0x3a1b5d33fb50,~
code-source-info,0x287bc393790,395,539,637,C0O546C6O569C10O583C11O588C17O604C24O602C30O635,,
code-creation,LazyCompile,10,65784,0x287bc3938d0,85,stringify node:internal/modules/esm/translators:114:19,0x3a1b5d33fc40,~
code-source-info,0x287bc3938d0,395,3496,3756,C0O3507C6O3539C8O3551C9O3556C20O3556C25O3634C31O3634C36O3618C41O3666C49O3695C58O3715C63O3674C69O3726C74O3741C79O3741C84O3754,,
tick,0xd9a9c5,66011,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x287bc3938ef,0x287bc392772,0x2ffc48520580,0x16c843f
code-creation,Eval,10,66157,0x287bc395998,5, node:internal/encoding:1:1,0x287bc395578,~
script-source,412,node:internal/encoding,'use strict';\n\n// An implementation of the WHATWG Encoding Standard\n// https://encoding.spec.whatwg.org\n\nconst {\n  Boolean\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  SafeMap\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  Uint32Array\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_ENCODING_NOT_SUPPORTED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_NO_ICU\x2C\n} = require('internal/errors').codes;\nconst kHandle = Symbol('handle');\nconst kFlags = Symbol('flags');\nconst kEncoding = Symbol('encoding');\nconst kDecoder = Symbol('decoder');\nconst kEncoder = Symbol('encoder');\nconst kFatal = Symbol('kFatal');\nconst kUTF8FastPath = Symbol('kUTF8FastPath');\nconst kIgnoreBOM = Symbol('kIgnoreBOM');\n\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol: inspect\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\n\nconst {\n  validateString\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  encodeInto\x2C\n  encodeUtf8String\x2C\n  decodeUTF8\x2C\n} = internalBinding('buffer');\n\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === undefined)\n    Buffer = require('buffer').Buffer;\n  return Buffer;\n}\n\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS('TextEncoder');\n}\n\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS('TextDecoder');\n}\n\nconst CONVERTER_FLAGS_FLUSH = 0x1;\nconst CONVERTER_FLAGS_FATAL = 0x2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\n\nconst empty = new Uint8Array(0);\n\nconst encodings = new SafeMap([\n  ['unicode-1-1-utf-8'\x2C 'utf-8']\x2C\n  ['utf8'\x2C 'utf-8']\x2C\n  ['utf-8'\x2C 'utf-8']\x2C\n  ['866'\x2C 'ibm866']\x2C\n  ['cp866'\x2C 'ibm866']\x2C\n  ['csibm866'\x2C 'ibm866']\x2C\n  ['ibm866'\x2C 'ibm866']\x2C\n  ['csisolatin2'\x2C 'iso-8859-2']\x2C\n  ['iso-8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso-ir-101'\x2C 'iso-8859-2']\x2C\n  ['iso8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso88592'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2:1987'\x2C 'iso-8859-2']\x2C\n  ['l2'\x2C 'iso-8859-2']\x2C\n  ['latin2'\x2C 'iso-8859-2']\x2C\n  ['csisolatin3'\x2C 'iso-8859-3']\x2C\n  ['iso-8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso-ir-109'\x2C 'iso-8859-3']\x2C\n  ['iso8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso88593'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3:1988'\x2C 'iso-8859-3']\x2C\n  ['l3'\x2C 'iso-8859-3']\x2C\n  ['latin3'\x2C 'iso-8859-3']\x2C\n  ['csisolatin4'\x2C 'iso-8859-4']\x2C\n  ['iso-8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso-ir-110'\x2C 'iso-8859-4']\x2C\n  ['iso8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso88594'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4:1988'\x2C 'iso-8859-4']\x2C\n  ['l4'\x2C 'iso-8859-4']\x2C\n  ['latin4'\x2C 'iso-8859-4']\x2C\n  ['csisolatincyrillic'\x2C 'iso-8859-5']\x2C\n  ['cyrillic'\x2C 'iso-8859-5']\x2C\n  ['iso-8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso-ir-144'\x2C 'iso-8859-5']\x2C\n  ['iso8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso88595'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5:1988'\x2C 'iso-8859-5']\x2C\n  ['arabic'\x2C 'iso-8859-6']\x2C\n  ['asmo-708'\x2C 'iso-8859-6']\x2C\n  ['csiso88596e'\x2C 'iso-8859-6']\x2C\n  ['csiso88596i'\x2C 'iso-8859-6']\x2C\n  ['csisolatinarabic'\x2C 'iso-8859-6']\x2C\n  ['ecma-114'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-e'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-i'\x2C 'iso-8859-6']\x2C\n  ['iso-ir-127'\x2C 'iso-8859-6']\x2C\n  ['iso8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso88596'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6:1987'\x2C 'iso-8859-6']\x2C\n  ['csisolatingreek'\x2C 'iso-8859-7']\x2C\n  ['ecma-118'\x2C 'iso-8859-7']\x2C\n  ['elot_928'\x2C 'iso-8859-7']\x2C\n  ['greek'\x2C 'iso-8859-7']\x2C\n  ['greek8'\x2C 'iso-8859-7']\x2C\n  ['iso-8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso-ir-126'\x2C 'iso-8859-7']\x2C\n  ['iso8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso88597'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7:1987'\x2C 'iso-8859-7']\x2C\n  ['sun_eu_greek'\x2C 'iso-8859-7']\x2C\n  ['csiso88598e'\x2C 'iso-8859-8']\x2C\n  ['csisolatinhebrew'\x2C 'iso-8859-8']\x2C\n  ['hebrew'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8-e'\x2C 'iso-8859-8']\x2C\n  ['iso-ir-138'\x2C 'iso-8859-8']\x2C\n  ['iso8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso88598'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8:1988'\x2C 'iso-8859-8']\x2C\n  ['visual'\x2C 'iso-8859-8']\x2C\n  ['csiso88598i'\x2C 'iso-8859-8-i']\x2C\n  ['iso-8859-8-i'\x2C 'iso-8859-8-i']\x2C\n  ['logical'\x2C 'iso-8859-8-i']\x2C\n  ['csisolatin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso-ir-157'\x2C 'iso-8859-10']\x2C\n  ['iso8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso885910'\x2C 'iso-8859-10']\x2C\n  ['l6'\x2C 'iso-8859-10']\x2C\n  ['latin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso885913'\x2C 'iso-8859-13']\x2C\n  ['iso-8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso885914'\x2C 'iso-8859-14']\x2C\n  ['csisolatin9'\x2C 'iso-8859-15']\x2C\n  ['iso-8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso885915'\x2C 'iso-8859-15']\x2C\n  ['iso_8859-15'\x2C 'iso-8859-15']\x2C\n  ['l9'\x2C 'iso-8859-15']\x2C\n  ['cskoi8r'\x2C 'koi8-r']\x2C\n  ['koi'\x2C 'koi8-r']\x2C\n  ['koi8'\x2C 'koi8-r']\x2C\n  ['koi8-r'\x2C 'koi8-r']\x2C\n  ['koi8_r'\x2C 'koi8-r']\x2C\n  ['koi8-ru'\x2C 'koi8-u']\x2C\n  ['koi8-u'\x2C 'koi8-u']\x2C\n  ['csmacintosh'\x2C 'macintosh']\x2C\n  ['mac'\x2C 'macintosh']\x2C\n  ['macintosh'\x2C 'macintosh']\x2C\n  ['x-mac-roman'\x2C 'macintosh']\x2C\n  ['dos-874'\x2C 'windows-874']\x2C\n  ['iso-8859-11'\x2C 'windows-874']\x2C\n  ['iso8859-11'\x2C 'windows-874']\x2C\n  ['iso885911'\x2C 'windows-874']\x2C\n  ['tis-620'\x2C 'windows-874']\x2C\n  ['windows-874'\x2C 'windows-874']\x2C\n  ['cp1250'\x2C 'windows-1250']\x2C\n  ['windows-1250'\x2C 'windows-1250']\x2C\n  ['x-cp1250'\x2C 'windows-1250']\x2C\n  ['cp1251'\x2C 'windows-1251']\x2C\n  ['windows-1251'\x2C 'windows-1251']\x2C\n  ['x-cp1251'\x2C 'windows-1251']\x2C\n  ['ansi_x3.4-1968'\x2C 'windows-1252']\x2C\n  ['ascii'\x2C 'windows-1252']\x2C\n  ['cp1252'\x2C 'windows-1252']\x2C\n  ['cp819'\x2C 'windows-1252']\x2C\n  ['csisolatin1'\x2C 'windows-1252']\x2C\n  ['ibm819'\x2C 'windows-1252']\x2C\n  ['iso-8859-1'\x2C 'windows-1252']\x2C\n  ['iso-ir-100'\x2C 'windows-1252']\x2C\n  ['iso8859-1'\x2C 'windows-1252']\x2C\n  ['iso88591'\x2C 'windows-1252']\x2C\n  ['iso_8859-1'\x2C 'windows-1252']\x2C\n  ['iso_8859-1:1987'\x2C 'windows-1252']\x2C\n  ['l1'\x2C 'windows-1252']\x2C\n  ['latin1'\x2C 'windows-1252']\x2C\n  ['us-ascii'\x2C 'windows-1252']\x2C\n  ['windows-1252'\x2C 'windows-1252']\x2C\n  ['x-cp1252'\x2C 'windows-1252']\x2C\n  ['cp1253'\x2C 'windows-1253']\x2C\n  ['windows-1253'\x2C 'windows-1253']\x2C\n  ['x-cp1253'\x2C 'windows-1253']\x2C\n  ['cp1254'\x2C 'windows-1254']\x2C\n  ['csisolatin5'\x2C 'windows-1254']\x2C\n  ['iso-8859-9'\x2C 'windows-1254']\x2C\n  ['iso-ir-148'\x2C 'windows-1254']\x2C\n  ['iso8859-9'\x2C 'windows-1254']\x2C\n  ['iso88599'\x2C 'windows-1254']\x2C\n  ['iso_8859-9'\x2C 'windows-1254']\x2C\n  ['iso_8859-9:1989'\x2C 'windows-1254']\x2C\n  ['l5'\x2C 'windows-1254']\x2C\n  ['latin5'\x2C 'windows-1254']\x2C\n  ['windows-1254'\x2C 'windows-1254']\x2C\n  ['x-cp1254'\x2C 'windows-1254']\x2C\n  ['cp1255'\x2C 'windows-1255']\x2C\n  ['windows-1255'\x2C 'windows-1255']\x2C\n  ['x-cp1255'\x2C 'windows-1255']\x2C\n  ['cp1256'\x2C 'windows-1256']\x2C\n  ['windows-1256'\x2C 'windows-1256']\x2C\n  ['x-cp1256'\x2C 'windows-1256']\x2C\n  ['cp1257'\x2C 'windows-1257']\x2C\n  ['windows-1257'\x2C 'windows-1257']\x2C\n  ['x-cp1257'\x2C 'windows-1257']\x2C\n  ['cp1258'\x2C 'windows-1258']\x2C\n  ['windows-1258'\x2C 'windows-1258']\x2C\n  ['x-cp1258'\x2C 'windows-1258']\x2C\n  ['x-mac-cyrillic'\x2C 'x-mac-cyrillic']\x2C\n  ['x-mac-ukrainian'\x2C 'x-mac-cyrillic']\x2C\n  ['chinese'\x2C 'gbk']\x2C\n  ['csgb2312'\x2C 'gbk']\x2C\n  ['csiso58gb231280'\x2C 'gbk']\x2C\n  ['gb2312'\x2C 'gbk']\x2C\n  ['gb_2312'\x2C 'gbk']\x2C\n  ['gb_2312-80'\x2C 'gbk']\x2C\n  ['gbk'\x2C 'gbk']\x2C\n  ['iso-ir-58'\x2C 'gbk']\x2C\n  ['x-gbk'\x2C 'gbk']\x2C\n  ['gb18030'\x2C 'gb18030']\x2C\n  ['big5'\x2C 'big5']\x2C\n  ['big5-hkscs'\x2C 'big5']\x2C\n  ['cn-big5'\x2C 'big5']\x2C\n  ['csbig5'\x2C 'big5']\x2C\n  ['x-x-big5'\x2C 'big5']\x2C\n  ['cseucpkdfmtjapanese'\x2C 'euc-jp']\x2C\n  ['euc-jp'\x2C 'euc-jp']\x2C\n  ['x-euc-jp'\x2C 'euc-jp']\x2C\n  ['csiso2022jp'\x2C 'iso-2022-jp']\x2C\n  ['iso-2022-jp'\x2C 'iso-2022-jp']\x2C\n  ['csshiftjis'\x2C 'shift_jis']\x2C\n  ['ms932'\x2C 'shift_jis']\x2C\n  ['ms_kanji'\x2C 'shift_jis']\x2C\n  ['shift-jis'\x2C 'shift_jis']\x2C\n  ['shift_jis'\x2C 'shift_jis']\x2C\n  ['sjis'\x2C 'shift_jis']\x2C\n  ['windows-31j'\x2C 'shift_jis']\x2C\n  ['x-sjis'\x2C 'shift_jis']\x2C\n  ['cseuckr'\x2C 'euc-kr']\x2C\n  ['csksc56011987'\x2C 'euc-kr']\x2C\n  ['euc-kr'\x2C 'euc-kr']\x2C\n  ['iso-ir-149'\x2C 'euc-kr']\x2C\n  ['korean'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1987'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1989'\x2C 'euc-kr']\x2C\n  ['ksc5601'\x2C 'euc-kr']\x2C\n  ['ksc_5601'\x2C 'euc-kr']\x2C\n  ['windows-949'\x2C 'euc-kr']\x2C\n  ['utf-16be'\x2C 'utf-16be']\x2C\n  ['utf-16le'\x2C 'utf-16le']\x2C\n  ['utf-16'\x2C 'utf-16le']\x2C\n]);\n\n// Unfortunately\x2C String.prototype.trim also removes non-ascii whitespace\x2C\n// so we have to do this manually\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (\n    label[s] === '\\u0009' ||\n    label[s] === '\\u000a' ||\n    label[s] === '\\u000c' ||\n    label[s] === '\\u000d' ||\n    label[s] === '\\u0020')) {\n    s++;\n  }\n  while (e > s && (\n    label[e - 1] === '\\u0009' ||\n    label[e - 1] === '\\u000a' ||\n    label[e - 1] === '\\u000c' ||\n    label[e - 1] === '\\u000d' ||\n    label[e - 1] === '\\u0020')) {\n    e--;\n  }\n  return StringPrototypeSlice(label\x2C s\x2C e);\n}\n\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== undefined) return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\n\nconst encodeIntoResults = new Uint32Array(2);\n\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n\n  get encoding() {\n    validateEncoder(this);\n    return 'utf-8';\n  }\n\n  encode(input = '') {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n\n  encodeInto(src\x2C dest) {\n    validateEncoder(this);\n    validateString(src\x2C 'src');\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE('dest'\x2C 'Uint8Array'\x2C dest);\n    encodeInto(src\x2C dest\x2C encodeIntoResults);\n    return { read: encodeIntoResults[0]\x2C written: encodeIntoResults[1] };\n  }\n\n  [inspect](depth\x2C opts) {\n    validateEncoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\x2C\n    });\n    obj.encoding = this.encoding;\n    // Lazy to avoid circular dependency\n    return require('internal/util/inspect').inspect(obj\x2C opts);\n  }\n}\n\nObjectDefineProperties(\n  TextEncoder.prototype\x2C {\n    'encode': kEnumerableProperty\x2C\n    'encodeInto': kEnumerableProperty\x2C\n    'encoding': kEnumerableProperty\x2C\n    [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'TextEncoder' }\x2C\n  });\n\nconst TextDecoder =\n  internalBinding('config').hasIntl ?\n    makeTextDecoderICU() :\n    makeTextDecoderJS();\n\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode\x2C\n    getConverter\x2C\n  } = internalBinding('icu');\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = kEmptyObject) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kIgnoreBOM] = Boolean(options?.ignoreBOM);\n      this[kFatal] = Boolean(options?.fatal);\n      // Only support fast path for UTF-8.\n      this[kUTF8FastPath] = enc === 'utf-8';\n      this[kHandle] = undefined;\n\n      if (!this[kUTF8FastPath]) {\n        this.#prepareConverter();\n      }\n    }\n\n    #prepareConverter() {\n      if (this[kHandle] !== undefined) return;\n      const handle = getConverter(this[kEncoding]\x2C this[kFlags]);\n      if (handle === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(this[kEncoding]);\n      this[kHandle] = handle;\n    }\n\n    decode(input = empty\x2C options = kEmptyObject) {\n      validateDecoder(this);\n\n      this[kUTF8FastPath] &&= !(options?.stream);\n\n      if (this[kUTF8FastPath]) {\n        return decodeUTF8(input\x2C this[kIgnoreBOM]\x2C this[kFatal]);\n      }\n\n      this.#prepareConverter();\n\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n\n      return _decode(this[kHandle]\x2C input\x2C flags\x2C this.encoding);\n    }\n  }\n\n  return TextDecoder;\n}\n\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === undefined)\n      ({ StringDecoder } = require('string_decoder'));\n    return StringDecoder;\n  }\n\n  const kBOMSeen = Symbol('BOM seen');\n\n  function hasConverter(encoding) {\n    return encoding === 'utf-8' || encoding === 'utf-16le';\n  }\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = kEmptyObject) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('"fatal" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n\n    decode(input = empty\x2C options = kEmptyObject) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        try {\n          input = lazyBuffer().from(input);\n        } catch {\n          input = empty;\n        }\n      } else if (isArrayBufferView(input)) {\n        try {\n          input = lazyBuffer().from(input.buffer\x2C input.byteOffset\x2C\n                                    input.byteLength);\n        } catch {\n          input = empty;\n        }\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\n        this[kHandle].end(input) :\n        this[kHandle].write(input);\n\n      if (result.length > 0 &&\n          !this[kBOMSeen] &&\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        // If the very first result in the stream is a BOM\x2C and we are not\n        // explicitly told to ignore it\x2C then we discard it.\n        if (result[0] === '\\ufeff') {\n          result = StringPrototypeSlice(result\x2C 1);\n        }\n        this[kBOMSeen] = true;\n      }\n\n      return result;\n    }\n  }\n\n  return TextDecoder;\n}\n\n// Mix in some shared properties.\nconst sharedProperties = ObjectGetOwnPropertyDescriptors({\n  get encoding() {\n    validateDecoder(this);\n    return this[kEncoding];\n  }\x2C\n\n  get fatal() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n  }\x2C\n\n  get ignoreBOM() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\n              CONVERTER_FLAGS_IGNORE_BOM;\n  }\x2C\n\n  [inspect](depth\x2C opts) {\n    validateDecoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const constructor = getConstructorOf(this) || TextDecoder;\n    const obj = ObjectCreate({ constructor });\n    obj.encoding = this.encoding;\n    obj.fatal = this.fatal;\n    obj.ignoreBOM = this.ignoreBOM;\n    if (opts.showHidden) {\n      obj[kFlags] = this[kFlags];\n      obj[kHandle] = this[kHandle];\n    }\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return `${constructor.name} ${inspect(obj)}`;\n  }\x2C\n});\nconst propertiesValues = ObjectValues(sharedProperties);\nfor (let i = 0; i < propertiesValues.length; i++) {\n  // We want to use null-prototype objects to not rely on globally mutable\n  // %Object.prototype%.\n  ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n}\nsharedProperties[inspect].enumerable = false;\n\nObjectDefineProperties(TextDecoder.prototype\x2C {\n  decode: kEnumerableProperty\x2C\n  ...sharedProperties\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    value: 'TextDecoder'\x2C\n  }\x2C\n});\n\nmodule.exports = {\n  getEncodingFromLabel\x2C\n  TextDecoder\x2C\n  TextEncoder\x2C\n};\n
code-source-info,0x287bc395998,412,0,16816,C0O0C4O16816,,
code-creation,Function,10,66680,0x287bc399bc0,922, node:internal/encoding:1:1,0x287bc395910,~
code-source-info,0x287bc399bc0,412,0,16816,C0O0C155O115C161O126C167O142C172O168C177O203C182O227C187O243C192O254C198O278C204O288C209O309C214O324C219O454C227O454C233O480C239O364C245O394C251O418C257O438C263O504C271O504C275O504C277O537C285O537C289O537C291O572C299O572C303O572C305O609C313O609C317O609C319O645C327O645C331O645C333O679C341O679C345O679C347O719C355O719C359O719C361O763C369O763C373O763C375O889C383O889C389O796C395O837C400O848C406O864C411O985C419O985C425O926C431O946C437O967C443O1066C451O1066C457O1028C463O1046C469O1159C477O1159C483O1109C489O1123C495O1143C501O1191C502O1191C504O1594C506O1594C508O1629C510O1629C512O1669C514O1669C516O1689C521O1689C526O1689C528O1727C536O1727C541O1727C543O9015C549O9015C554O9015C592O9590C621O10027C635O10054C641O10093C647O10130C653O10156C655O10176C664O9989C669O10268C677O10268C683O10293C689O10308C694O10335C697O10268C699O15239C773O15636C775O15635C784O15239C789O16248C794O16293C796O16317C800O16298C805O16434C807O16471C815O16434C820O16326C825O16280C828O16485C830O16501C836O16522C840O16532C844O16567C858O16590C868O16616C874O16637C876O16657C885O16532C890O16740C898O16761C904O16785C910O16800C916O16755C921O16815,,
code-creation,LazyCompile,10,66982,0x287bc39bbd0,88,makeTextDecoderICU node:internal/encoding:380:28,0x287bc395b58,~
code-source-info,0x287bc39bbd0,412,10384,12323,C0O10384C11O10444C19O10444C24O10411C30O10424C85O12302C87O12321,,
tick,0xd9b8fb,67077,0,0x0,2,0x12f0560,0x287bc393901,0x287bc392772,0x2ffc48520580,0x16c843f
code-creation,LazyCompile,10,67109,0x287bc39d448,311,TextDecoder node:internal/encoding:387:16,0x287bc39b948,~
code-source-info,0x287bc39d448,412,10506,11432,C5O10506C28O10537C35O10559C39O10591C49O10606C57O10591C62O10736C67O10736C72O10774C74O10805C83O10811C88O10805C89O10872C91O10881C95O10930C108O10938C117O10990C130O11002C139O11049C143O11054C147O11064C151O11078C155O11083C160O11091C164O11106C168O11111C173O11122C177O11135C181O11140C188O11154C201O11169C209O11154C213O11152C217O11189C221O11194C228O11204C241O11219C249O11204C253O11202C257O11278C261O11283C266O11304C269O11298C273O11323C277O11328C281O11337C285O11357C289O11367C291O11366C296O11393C298O11398C304O11415C310O11431,,
code-creation,LazyCompile,10,67161,0x287bc39d700,128, node:internal/validators:246:3,0x23f41f7bc148,~
code-source-info,0x287bc39d700,20,6266,6821,C16O6324C27O6324C33O6410C44O6410C50O6494C61O6494C67O6556C75O6603C79O6617C82O6617C96O6692C104O6757C120O6763C125O6757C127O6820,,
code-creation,LazyCompile,10,67185,0x287bc39d898,27,getOwnPropertyValueOrDefault node:internal/validators:227:38,0x23f41f7bc0f8,~
code-source-info,0x287bc39d898,20,5857,6001,C0O5890C7O5917C10O5917C23O5993C26O5999,,
code-creation,LazyCompile,10,67208,0x287bc39d9a0,55,getEncodingFromLabel node:internal/encoding:321:30,0x287bc395b08,~
code-source-info,0x287bc39d9a0,412,8837,8987,C0O8861C5O8871C10O8871C16O8885C18O8908C20O8919C21O8922C26O8939C34O8969C39O8969C44O8943C49O8939C54O8985,,
code-creation,LazyCompile,10,67259,0x287bc39dbb8,218,decode node:internal/encoding:427:11,0x287bc39b998,~
code-source-info,0x287bc39dbb8,412,11715,12294,C8O11724C23O11741C30O11763C35O11763C39O11793C43O11798C61O11826C69O11813C73O11844C77O11853C79O11852C84O11879C95O11909C97O11908C105O11927C107O11926C114O11886C119O11936C120O11952C122O11957C128O11974C133O11985C143O12000C151O11985C156O12130C158O12139C162O12186C178O12199C184O12229C195O12249C197O12248C201O12278C212O12236C217O12288,,
code-creation,LazyCompile,10,67283,0x287bc39ddd0,37,validateDecoder node:internal/encoding:72:25,0x287bc395a68,~
code-source-info,0x287bc39ddd0,412,1461,1562,C0O1471C7O1494C9O1493C14O1504C19O1518C29O1524C34O1518C36O1561,,
code-creation,LazyCompile,10,67346,0x287bc39e140,352,maybeCacheSourceMap node:internal/source_map/source_map_cache:112:29,0x32bbd7472868,~
code-source-info,0x287bc39e140,44,3543,5217,C0O3656C3O3656C7O3682C10O3696C15O3700C23O3720C25O3740C26O3747C30O3793C36O3793C41O3768C46O3845C55O3843C65O3978C75O3978C79O3994C80O4001C81O4009C85O4047C88O4062C94O4158C100O4202C101O4209C102O4217C106O4252C109O4264C115O4323C118O4323C124O4374C132O4404C136O4433C141O4433C145O4455C150O4460C157O4487C164O4516C174O4544C180O4556C186O4567C190O4456C198O4595C202O4638C210O4659C220O4687C226O4699C232O4710C239O4732C244O4756C249O4756C255O4782C259O4805C264O4829C269O4829C277O5004C285O5025C295O5053C301O5065C307O5076C314O5098C319O5116C324O5116C330O5142C334O5165C339O5183C344O5183C351O5216,,
code-creation,LazyCompile,10,67371,0x287bc39e430,5,getSourceMapsEnabled node:internal/source_map/source_map_cache:56:30,0x32bbd7472728,~
code-source-info,0x287bc39e430,44,1888,1922,C0O1895C4O1920,,
code-creation,LazyCompile,10,67394,0x287bc39e4f0,10, node:internal/modules/esm/translators:44:63,0x3a1b5d33fdd0,~
code-source-info,0x287bc39e4f0,395,1034,1059,C0O1046C2O1052C9O1058,,
code-creation,Script,10,67424,0x287bc39e730,58, file:///home/gin/person/resources/nodejs/index.js:1:1,0x287bc39e5f8,~
script-source,413,file:///home/gin/person/resources/nodejs/index.js,console.log("hello nodejs");\n
code-source-info,0x287bc39e730,413,0,29,C10O0C15O0C35O0C39O0C43O8C51O8C57O29,,
code-creation,LazyCompile,10,67471,0x287bc39ea00,63,registerModule node:internal/modules/esm/utils:135:24,0x1d7bd0ee91b8,~
code-source-info,0x287bc39ea00,66,4004,4524,C0O4046C2O4055C4O4054C8O4086C10O4103C12O4099C19O4154C21O4150C26O4388C27O4395C28O4439C41O4465C45O4481C50O4498C55O4498C62O4523,,
code-creation,LazyCompile,10,67520,0x287bc39ebf0,33,primordials.SafePromiseAllReturnVoid node:internal/per_context/primordials:539:40,0x23f41f789060,~
code-source-info,0x287bc39ebf0,12,16178,16580,C0O16178C13O16201C27O16201C32O16580,,
code-creation,LazyCompile,10,67556,0x287bc39edb0,188, node:internal/per_context/primordials:540:15,0x287bc39eb40,~
code-source-info,0x287bc39edb0,12,16213,16579,C0O16213C12O16262C17O16271C21O16262C23O16283C27O16303C32O16310C35O16310C38O16338C49O16574C58O16363C66O16343C71O16354C75O16343C91O16391C110O16421C114O16407C128O16439C132O16450C143O16471C146O16471C159O16450C171O16325C187O16578,,
code-creation,LazyCompile,10,67595,0x287bc39f050,33,primordials.SafePromiseAllReturnArrayLike node:internal/per_context/primordials:513:45,0x23f41f788fd0,~
code-source-info,0x287bc39f050,12,15280,15836,C0O15280C13O15303C27O15303C32O15836,,
code-creation,LazyCompile,10,67633,0x287bc39f270,237, node:internal/per_context/primordials:514:15,0x287bc39efa0,~
code-source-info,0x287bc39f270,12,15315,15835,C0O15315C15O15361C20O15350C25O15394C32O15394C36O15394C38O15424C50O15424C55O15467C56O15478C61O15485C67O15485C71O15532C73O15532C75O15557C81O15830C103O15573C107O15573C112O15562C117O15562C135O15601C154O15631C161O15617C175O15649C179O15660C190O15681C193O15681C206O15660C216O15544C236O15834,,
code-creation,LazyCompile,10,67712,0x287bc39f568,38,log node:internal/console/constructor:379:6,0x13800b1495e8,~
code-source-info,0x287bc39f568,50,11599,11683,C0O11599C3O11615C5O11620C7O11619C13O11637C18O11654C20O11653C24O11671C30O11636C37O11682,,
code-creation,LazyCompile,10,67740,0x287bc39f698,50,value node:internal/console/constructor:340:20,0x13800b149488,~
code-source-info,0x287bc39f698,50,10143,10315,C0O10171C2O10176C4O10175C8O10201C13O10195C19O10217C24O10217C29O10258C36O10278C44O10265C49O10309,,
code-creation,LazyCompile,10,67759,0x287bc39f7b8,27,get node:internal/console/constructor:214:14,0x3a1b5d3106d0,~
code-source-info,0x287bc39f7b8,50,6060,6152,C0O6077C6O6090C9O6106C16O6097C22O6126C26O6140,,
code-creation,LazyCompile,10,67802,0x287bc39f9b0,125,getStdout node:internal/bootstrap/switches/is_main_thread:148:19,0x13800b15e4a0,~
script-source,56,node:internal/bootstrap/switches/is_main_thread,'use strict';\n\nconst { ObjectDefineProperty } = primordials;\nconst rawMethods = internalBinding('process_methods');\nconst {\n  namespace: {\n    addSerializeCallback\x2C\n    isBuildingSnapshot\x2C\n  }\x2C\n} = require('internal/v8/startup_snapshot');\n// TODO(joyeecheung): deprecate and remove these underscore methods\nprocess._debugProcess = rawMethods._debugProcess;\nprocess._debugEnd = rawMethods._debugEnd;\n\n// See the discussion in https://github.com/nodejs/node/issues/19009 and\n// https://github.com/nodejs/node/pull/34010 for why these are no-ops.\n// Five word summary: they were broken beyond repair.\nprocess._startProfilerIdleNotifier = () => {};\nprocess._stopProfilerIdleNotifier = () => {};\n\nfunction defineStream(name\x2C getter) {\n  ObjectDefineProperty(process\x2C name\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: getter\x2C\n  });\n}\n\ndefineStream('stdout'\x2C getStdout);\ndefineStream('stdin'\x2C getStdin);\ndefineStream('stderr'\x2C getStderr);\n\n// Worker threads don't receive signals.\nconst {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\x2C\n} = require('internal/process/signal');\nprocess.on('newListener'\x2C startListeningIfSignal);\nprocess.on('removeListener'\x2C stopListeningIfSignal);\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst { guessHandleType } = internalBinding('util');\n\nfunction createWritableStdioStream(fd) {\n  let stream;\n  // Note stream._type is used for test-module-load-list.js\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n    }\n\n    case 'FILE': {\n      const SyncWriteStream = require('internal/fs/sync_write_stream');\n      stream = new SyncWriteStream(fd\x2C { autoClose: false });\n      stream._type = 'fs';\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // If fd is already being used for the IPC channel\x2C libuv will return\n      // an error when trying to use it again. In that case\x2C create the socket\n      // using the existing handle instead of the fd.\n      if (process.channel && process.channel.fd === fd) {\n        const { kChannelHandle } = require('internal/child_process');\n        stream = new net.Socket({\n          handle: process[kChannelHandle]\x2C\n          readable: false\x2C\n          writable: true\x2C\n        });\n      } else {\n        stream = new net.Socket({\n          fd\x2C\n          readable: false\x2C\n          writable: true\x2C\n        });\n      }\n\n      stream._type = 'pipe';\n      break;\n    }\n\n    default: {\n      // Provide a dummy black-hole output for e.g. non-console\n      // Windows applications.\n      const { Writable } = require('stream');\n      stream = new Writable({\n        write(buf\x2C enc\x2C cb) {\n          cb();\n        }\x2C\n      });\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\nfunction dummyDestroy(err\x2C cb) {\n  cb(err);\n  this._undestroy();\n\n  // We need to emit 'close' anyway so that the closing\n  // of the stream is observable. We just make sure we\n  // are not going to do it twice.\n  // The 'close' event is needed so that finished and\n  // pipeline work correctly.\n  if (!this._writableState.emitClose) {\n    process.nextTick(() => {\n      this.emit('close');\n    });\n  }\n}\n\nlet stdin;\nlet stdout;\nlet stderr;\n\nlet stdoutDestroy;\nlet stderrDestroy;\n\nfunction refreshStdoutOnSigWinch() {\n  stdout._refreshSize();\n}\n\nfunction refreshStderrOnSigWinch() {\n  stderr._refreshSize();\n}\n\nfunction addCleanup(fn) {\n  if (isBuildingSnapshot()) {\n    addSerializeCallback(fn);\n  }\n}\n\nfunction getStdout() {\n  if (stdout) return stdout;\n  stdout = createWritableStdioStream(1);\n  stdout.destroySoon = stdout.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stdoutDestroy = stdout._destroy;\n  stdout._destroy = dummyDestroy;\n  if (stdout.isTTY) {\n    process.on('SIGWINCH'\x2C refreshStdoutOnSigWinch);\n  }\n\n  addCleanup(function cleanupStdout() {\n    stdout._destroy = stdoutDestroy;\n    stdout.destroy();\n    process.removeListener('SIGWINCH'\x2C refreshStdoutOnSigWinch);\n    stdout = undefined;\n  });\n  // No need to add deserialize callback because stdout = undefined above\n  // causes the stream to be lazily initialized again later.\n  return stdout;\n}\n\nfunction getStderr() {\n  if (stderr) return stderr;\n  stderr = createWritableStdioStream(2);\n  stderr.destroySoon = stderr.destroy;\n  stderrDestroy = stderr._destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stderr._destroy = dummyDestroy;\n  if (stderr.isTTY) {\n    process.on('SIGWINCH'\x2C refreshStderrOnSigWinch);\n  }\n  addCleanup(function cleanupStderr() {\n    stderr._destroy = stderrDestroy;\n    stderr.destroy();\n    process.removeListener('SIGWINCH'\x2C refreshStderrOnSigWinch);\n    stderr = undefined;\n  });\n  // No need to add deserialize callback because stderr = undefined above\n  // causes the stream to be lazily initialized again later.\n  return stderr;\n}\n\nfunction getStdin() {\n  if (stdin) return stdin;\n  const fd = 0;\n\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stdin = new tty.ReadStream(fd);\n      break;\n    }\n\n    case 'FILE': {\n      const fs = require('fs');\n      stdin = new fs.ReadStream(null\x2C { fd: fd\x2C autoClose: false });\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // It could be that process has been started with an IPC channel\n      // sitting on fd=0\x2C in such case the pipe for this fd is already\n      // present and creating a new one will lead to the assertion failure\n      // in libuv.\n      if (process.channel && process.channel.fd === fd) {\n        stdin = new net.Socket({\n          handle: process.channel\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\x2C\n        });\n      } else {\n        stdin = new net.Socket({\n          fd: fd\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\x2C\n        });\n      }\n      // Make sure the stdin can't be `.end()`-ed\n      stdin._writableState.ended = true;\n      break;\n    }\n\n    default: {\n      // Provide a dummy contentless input for e.g. non-console\n      // Windows applications.\n      const { Readable } = require('stream');\n      stdin = new Readable({ read() {} });\n      stdin.push(null);\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stdin.fd = fd;\n\n  // `stdin` starts out life in a paused state\x2C but node doesn't\n  // know yet. Explicitly to readStop() it to put it in the\n  // not-reading state.\n  if (stdin._handle && stdin._handle.readStop) {\n    stdin._handle.reading = false;\n    stdin._readableState.reading = false;\n    stdin._handle.readStop();\n  }\n\n  // If the user calls stdin.pause()\x2C then we need to stop reading\n  // once the stream implementation does so (one nextTick later)\x2C\n  // so that the process can close down.\n  stdin.on('pause'\x2C () => {\n    process.nextTick(onpause);\n  });\n\n  function onpause() {\n    if (!stdin._handle)\n      return;\n    if (stdin._handle.reading && !stdin.readableFlowing) {\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    }\n  }\n\n  addCleanup(function cleanupStdin() {\n    stdin.destroy();\n    stdin = undefined;\n  });\n  // No need to add deserialize callback because stdin = undefined above\n  // causes the stream to be lazily initialized again later.\n  return stdin;\n}\n\n// Used by internal tests.\nrawMethods.resetStdioForTesting = function() {\n  stdin = undefined;\n  stdout = undefined;\n  stderr = undefined;\n};\n\n// Needed by the module loader and generally needed everywhere.\nrequire('fs');\nrequire('util');\nrequire('url');\n\nrequire('internal/modules/cjs/loader');\nrequire('internal/modules/esm/utils');\nrequire('internal/vm/module');\n// Needed to refresh the time origin.\nrequire('internal/perf/utils');\n// Needed to register the async hooks.\nif (internalBinding('config').hasInspector) {\n  require('internal/inspector_async_hook');\n}\n// Needed to set the wasm web API callbacks.\ninternalBinding('wasm_web_api');\n// Needed to detect whether it's on main thread.\ninternalBinding('worker');\n// Needed by most execution modes.\nrequire('internal/modules/run_main');\n// Needed to refresh DNS configurations.\nrequire('internal/dns/utils');\n// Needed by almost all execution modes. It's fine to\n// load them into the snapshot as long as we don't run\n// any of the initialization.\nrequire('internal/process/pre_execution');\n
code-source-info,0x287bc39f9b0,56,3749,4423,C0O3756C6O3768C10O3782C11O3785C17O3794C24O3792C30O3826C37O3847C40O3854C44O3845C48O3929C53O3952C60O3943C66O3964C73O3980C77O3998C82O4009C88O4022C91O4030C102O4030C108O4078C116O4078C120O4407C124O4421,,
code-creation,LazyCompile,10,68087,0x287bc3a08e8,280,createWritableStdioStream node:internal/bootstrap/switches/is_main_thread:47:35,0x13800b15e2e0,~
code-source-info,0x287bc3a08e8,56,1457,3025,C0O1470C2O1540C7O1548C42O1607C48O1607C53O1646C60O1638C66O1669C68O1682C72O1697C74O1760C80O1760C85O1837C95O1817C101O1870C103O1883C107O1897C109O1964C115O1964C120O2196C123O2208C132O2227C137O2235C144O2238C149O2283C155O2283C160O2264C165O2343C180O2377C189O2335C197O2500C209O2519C215O2492C221O2603C223O2616C227O2632C229O2783C235O2783C240O2770C245O2808C250O2840C260O2817C266O2963C268O2973C272O2982C273O2998C277O3009C279O3023,,
tick,0xd9a9c0,68147,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,68283,0x287bc3a0f78,5, node:tty:1:1,0x287bc3a0d70,~
script-source,414,node:tty,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  NumberIsInteger\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst net = require('net');\nconst { TTY\x2C isTTY } = internalBinding('tty_wrap');\nconst errors = require('internal/errors');\nconst { ERR_INVALID_FD\x2C ERR_TTY_INIT_FAILED } = errors.codes;\nconst {\n  getColorDepth\x2C\n  hasColors\x2C\n} = require('internal/tty');\n\n// Lazy loaded for startup performance.\nlet readline;\n\nfunction isatty(fd) {\n  return NumberIsInteger(fd) && fd >= 0 && fd <= 2147483647 &&\n         isTTY(fd);\n}\n\nfunction ReadStream(fd\x2C options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(fd\x2C options);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n\n  const ctx = {};\n  const tty = new TTY(fd\x2C ctx);\n  if (ctx.code !== undefined) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n\n  net.Socket.call(this\x2C {\n    readableHighWaterMark: 0\x2C\n    handle: tty\x2C\n    manualStart: true\x2C\n    ...options\x2C\n  });\n\n  this.isRaw = false;\n  this.isTTY = true;\n}\n\nObjectSetPrototypeOf(ReadStream.prototype\x2C net.Socket.prototype);\nObjectSetPrototypeOf(ReadStream\x2C net.Socket);\n\nReadStream.prototype.setRawMode = function(flag) {\n  flag = !!flag;\n  const err = this._handle?.setRawMode(flag);\n  if (err) {\n    this.emit('error'\x2C errors.errnoException(err\x2C 'setRawMode'));\n    return this;\n  }\n  this.isRaw = flag;\n  return this;\n};\n\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(fd);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n\n  const ctx = {};\n  const tty = new TTY(fd\x2C ctx);\n  if (ctx.code !== undefined) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n\n  net.Socket.call(this\x2C {\n    readableHighWaterMark: 0\x2C\n    handle: tty\x2C\n    manualStart: true\x2C\n  });\n\n  // Prevents interleaved or dropped stdout/stderr output for terminals.\n  // As noted in the following reference\x2C local TTYs tend to be quite fast and\n  // this behavior has become expected due historical functionality on OS X\x2C\n  // even though it was originally intended to change in v1.0.2 (Libuv 1.2.1).\n  // Ref: https://github.com/nodejs/node/pull/1771#issuecomment-119351671\n  this._handle.setBlocking(true);\n\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (!err) {\n    this.columns = winSize[0];\n    this.rows = winSize[1];\n  }\n}\n\nObjectSetPrototypeOf(WriteStream.prototype\x2C net.Socket.prototype);\nObjectSetPrototypeOf(WriteStream\x2C net.Socket);\n\nWriteStream.prototype.isTTY = true;\n\nWriteStream.prototype.getColorDepth = getColorDepth;\n\nWriteStream.prototype.hasColors = hasColors;\n\nWriteStream.prototype._refreshSize = function() {\n  const oldCols = this.columns;\n  const oldRows = this.rows;\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (err) {\n    this.emit('error'\x2C errors.errnoException(err\x2C 'getWindowSize'));\n    return;\n  }\n  const { 0: newCols\x2C 1: newRows } = winSize;\n  if (oldCols !== newCols || oldRows !== newRows) {\n    this.columns = newCols;\n    this.rows = newRows;\n    this.emit('resize');\n  }\n};\n\n// Backwards-compat\nWriteStream.prototype.cursorTo = function(x\x2C y\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.cursorTo(this\x2C x\x2C y\x2C callback);\n};\nWriteStream.prototype.moveCursor = function(dx\x2C dy\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.moveCursor(this\x2C dx\x2C dy\x2C callback);\n};\nWriteStream.prototype.clearLine = function(dir\x2C callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.clearLine(this\x2C dir\x2C callback);\n};\nWriteStream.prototype.clearScreenDown = function(callback) {\n  if (readline === undefined) readline = require('readline');\n  return readline.clearScreenDown(this\x2C callback);\n};\nWriteStream.prototype.getWindowSize = function() {\n  return [this.columns\x2C this.rows];\n};\n\nmodule.exports = { isatty\x2C ReadStream\x2C WriteStream };\n
code-source-info,0x287bc3a0f78,414,0,5058,C0O0C4O5058,,
code-creation,Function,10,68431,0x287bc3a1650,426, node:tty:1:1,0x287bc3a0ef0,~
code-source-info,0x287bc3a1650,414,0,5058,C0O0C53O1159C59O1168C65O1187C70O1239C76O1239C80O1239C82O1278C85O1278C90O1263C96O1268C102O1322C108O1322C112O1322C114O1398C117O1405C122O1358C128O1374C134O1454C140O1454C145O1422C150O1439C155O1524C156O1524C158O2114C161O2146C169O2161C174O2168C179O2114C184O2180C190O2217C195O2180C200O2227C203O2238C212O2259C216O3455C219O3488C227O3503C232O3510C237O3455C242O3522C248O3560C253O3522C258O3570C261O3582C267O3598C271O3607C274O3619C281O3643C285O3661C288O3673C295O3693C299O3707C302O3719C311O3742C315O4203C318O4215C327O4234C331O4378C334O4390C343O4411C347O4561C350O4573C359O4593C363O4736C366O4748C375O4774C379O4913C382O4925C391O4949C395O5004C402O5023C408O5031C414O5043C420O5019C425O5057,,
tick,0xf152a6,69216,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,69407,0x287bc3a5148,5, node:net:1:1,0x287bc3a3b60,~
script-source,415,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  Boolean\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n  ObjectCreate\x2C\n  SymbolAsyncDispose\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  kReinitializeHandle\x2C\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\x2C\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\x2C\n  UV_ECANCELED\x2C\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\x2C\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\x2C\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\x2C\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\x2C\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_SOCKET_CLOSED_BEFORE_CONNECTION\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  aggregateErrors\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  genericNodeError\x2C\n  uvExceptionWithHostPort\x2C\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst { queueMicrotask } = require('internal/process/task_queues');\nconst { kEmptyObject\x2C promisify } = require('internal/util');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\x2C\n} = require('internal/dtrace');\nconst { getOptionValue } = require('internal/options');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\nlet autoSelectFamilyDefault = getOptionValue('--enable-network-family-autoselection');\nlet autoSelectFamilyAttemptTimeoutDefault = 250;\n\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nconst kPerfHooksNetConnectContext = Symbol('kPerfHooksNetConnectContext');\n\nlet netClientSocketChannel;\nlet netServerSocketChannel;\nfunction lazyChannels() {\n  // TODO(joyeecheung): support diagnostics channels in the snapshot.\n  // For now it is fine to create them lazily when there isn't a snapshot to\n  // build. If users need the channels they would have to create them first\n  // before invoking any built-ins that would publish to these channels\n  // anyway.\n  if (netClientSocketChannel === undefined) {\n    const dc = require('diagnostics_channel');\n    netClientSocketChannel = dc.channel('net.client.socket');\n    netServerSocketChannel = dc.channel('net.server.socket');\n  }\n}\n\nconst {\n  hasObserver\x2C\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\nconst { getDefaultHighWaterMark } = require('internal/streams/state');\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\x2C\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\x2C\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n  lazyChannels();\n  if (netClientSocketChannel.hasSubscribers) {\n    netClientSocketChannel.publish({\n      socket\x2C\n    });\n  }\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\nfunction getDefaultAutoSelectFamily() {\n  return autoSelectFamilyDefault;\n}\n\nfunction setDefaultAutoSelectFamily(value) {\n  validateBoolean(value\x2C 'value');\n  autoSelectFamilyDefault = value;\n}\n\nfunction getDefaultAutoSelectFamilyAttemptTimeout() {\n  return autoSelectFamilyAttemptTimeoutDefault;\n}\n\nfunction setDefaultAutoSelectFamilyAttemptTimeout(value) {\n  validateInt32(value\x2C 'value'\x2C 1);\n\n  if (value < 10) {\n    value = 10;\n  }\n\n  autoSelectFamilyAttemptTimeoutDefault = value;\n}\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\nfunction closeSocketHandle(self\x2C isException\x2C isCleanupPending = false) {\n  if (self._handle) {\n    self._handle.close(() => {\n      debug('emit close');\n      self.emit('close'\x2C isException);\n      if (isCleanupPending) {\n        self._handle.onread = noop;\n        self._handle = null;\n        self._sockname = null;\n      }\n    });\n  }\n}\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\x2C\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\x2C\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\x2C\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n  this._closeAfterHandlingError = false;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        __proto__: null\x2C\n        value: 0\x2C writable: true\x2C\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party'\x2C\n    { code: 'EPIPE' }\x2C\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable\x2C initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (!this._handle.setKeepAlive) {\n    return this;\n  }\n\n  if (enable !== this[kSetKeepAlive] ||\n      (\n        enable &&\n        this[kSetKeepAliveInitialDelay] !== initialDelay\n      )\n  ) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable\x2C initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this.connecting;\n  }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  __proto__: null\x2C\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\x2C\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this._unrefTimer;\n  }\x2C\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug(\n    '_read - n'\x2C n\x2C\n    'isConnecting?'\x2C !!this.connecting\x2C\n    'hasHandle?'\x2C !!this._handle\x2C\n  );\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\nSocket.prototype.resetAndDestroy = function() {\n  if (this._handle) {\n    if (!(this._handle instanceof TCP))\n      throw new ERR_INVALID_HANDLE_TYPE();\n    if (this.connecting) {\n      debug('reset wait for connection');\n      this.once('connect'\x2C () => this._reset());\n    } else {\n      this._reset();\n    }\n  } else {\n    this.destroy(new ERR_SOCKET_CLOSED());\n  }\n  return this;\n};\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    if (this.resetAndClosing) {\n      this.resetAndClosing = false;\n      const err = this._handle.reset(() => {\n        debug('emit close');\n        this.emit('close'\x2C isException);\n      });\n      if (err)\n        this.emit('error'\x2C errnoException(err\x2C 'reset'));\n    } else if (this._closeAfterHandlingError) {\n      // Enqueue closing the socket as a microtask\x2C so that the socket can be\n      // accessible when an `error` event is handled in the `next tick queue`.\n      queueMicrotask(() => closeSocketHandle(this\x2C isException\x2C true));\n    } else {\n      closeSocketHandle(this\x2C isException);\n    }\n\n    if (!this._closeAfterHandlingError) {\n      this._handle.onread = noop;\n      this._handle = null;\n      this._sockname = null;\n    }\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._reset = function() {\n  debug('reset connection');\n  this.resetAndClosing = true;\n  return this.destroy();\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername || this.connecting) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    const out = {};\n    const err = this._handle.getpeername(out);\n    if (err) return out;\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\x2C\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\nprotoGetter('localFamily'\x2C function localFamily() {\n  return this._getsockname().family;\n});\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this.off('close'\x2C onClose);\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    function onClose() {\n      cb(new ERR_SOCKET_CLOSED_BEFORE_CONNECTION());\n    }\n    this.once('close'\x2C onClose);\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('connect: binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  debug('connect: attempting to connect to %s:%d (addressType: %d)'\x2C address\x2C port\x2C addressType);\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  } else if ((addressType === 6 || addressType === 4) && hasObserver('net')) {\n    startPerf(self\x2C kPerfHooksNetConnectContext\x2C { type: 'net'\x2C name: 'connect'\x2C detail: { host: address\x2C port } });\n  }\n}\n\n\nfunction internalConnectMultiple(context\x2C canceled) {\n  clearTimeout(context[kTimeout]);\n  const self = context.socket;\n\n  // All connections have been tried without success\x2C destroy with error\n  if (canceled || context.current === context.addresses.length) {\n    self.destroy(aggregateErrors(context.errors));\n    return;\n  }\n\n  assert(self.connecting);\n\n  const current = context.current++;\n  const handle = current === 0 ? self._handle : new TCP(TCPConstants.SOCKET);\n  const { localPort\x2C port\x2C flags } = context;\n  const { address\x2C family: addressType } = context.addresses[current];\n  let localAddress;\n  let err;\n\n  if (localPort) {\n    if (addressType === 4) {\n      localAddress = DEFAULT_IPV4_ADDR;\n      err = handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = DEFAULT_IPV6_ADDR;\n      err = handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n\n    debug('connect/multiple: binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C handle);\n    if (err) {\n      ArrayPrototypePush(context.errors\x2C exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort));\n      internalConnectMultiple(context);\n      return;\n    }\n  }\n\n  debug('connect/multiple: attempting to connect to %s:%d (addressType: %d)'\x2C address\x2C port\x2C addressType);\n\n  const req = new TCPConnectWrap();\n  req.oncomplete = FunctionPrototypeBind(afterConnectMultiple\x2C undefined\x2C context\x2C current);\n  req.address = address;\n  req.port = port;\n  req.localAddress = localAddress;\n  req.localPort = localPort;\n\n  ArrayPrototypePush(self.autoSelectFamilyAttemptedAddresses\x2C `${address}:${port}`);\n\n  if (addressType === 4) {\n    err = handle.connect(req\x2C address\x2C port);\n  } else {\n    err = handle.connect6(req\x2C address\x2C port);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    ArrayPrototypePush(context.errors\x2C exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details));\n    internalConnectMultiple(context);\n    return;\n  }\n\n  if (current < context.addresses.length - 1) {\n    debug('connect/multiple: setting the attempt timeout to %d ms'\x2C context.timeout);\n\n    // If the attempt has not returned an error\x2C start the connection timer\n    context[kTimeout] = setTimeout(internalConnectMultipleTimeout\x2C context.timeout\x2C context\x2C req\x2C handle);\n  }\n}\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\x2C\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\nSocket.prototype[kReinitializeHandle] = function reinitializeHandle(handle) {\n  this._handle?.close();\n\n  this._handle = handle;\n  this._handle[owner_symbol] = this;\n\n  initSocketHandle(this);\n};\n\nfunction socketToDnsFamily(family) {\n  switch (family) {\n    case 'IPv4':\n      return 4;\n    case 'IPv6':\n      return 6;\n  }\n\n  return family;\n}\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port\x2C autoSelectFamilyAttemptTimeout\x2C autoSelectFamily } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n\n  if (autoSelectFamily != null) {\n    validateBoolean(autoSelectFamily\x2C 'options.autoSelectFamily');\n  } else {\n    autoSelectFamily = autoSelectFamilyDefault;\n  }\n\n  if (autoSelectFamilyAttemptTimeout != null) {\n    validateInt32(autoSelectFamilyAttemptTimeout\x2C 'options.autoSelectFamilyAttemptTimeout'\x2C 1);\n\n    if (autoSelectFamilyAttemptTimeout < 10) {\n      autoSelectFamilyAttemptTimeout = 10;\n    }\n  } else {\n    autoSelectFamilyAttemptTimeout = autoSelectFamilyAttemptTimeoutDefault;\n  }\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C\n        );\n    });\n    return;\n  }\n\n  if (options.lookup != null)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: socketToDnsFamily(options.family)\x2C\n    hints: options.hints || 0\x2C\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && !localAddress && autoSelectFamily) {\n    debug('connect: autodetecting');\n\n    dnsopts.all = true;\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n      lookupAndConnectMultiple(\n        self\x2C\n        async_id_symbol\x2C\n        lookup\x2C\n        host\x2C\n        options\x2C\n        dnsopts\x2C\n        port\x2C\n        localPort\x2C\n        autoSelectFamilyAttemptTimeout\x2C\n      );\n    });\n\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C\n        );\n      }\n    });\n  });\n}\n\nfunction lookupAndConnectMultiple(self\x2C async_id_symbol\x2C lookup\x2C host\x2C options\x2C dnsopts\x2C port\x2C localPort\x2C timeout) {\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function emitLookup() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C addresses) {\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) {\n        return;\n      } else if (err) {\n        self.emit('lookup'\x2C err\x2C undefined\x2C undefined\x2C host);\n\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n        return;\n      }\n\n      // Filter addresses by only keeping the one which are either IPv4 or IPV6.\n      // The first valid address determines which group has preference on the\n      // alternate family sorting which happens later.\n      const validIps = [[]\x2C []];\n      let destinations;\n      for (let i = 0\x2C l = addresses.length; i < l; i++) {\n        const address = addresses[i];\n        const { address: ip\x2C family: addressType } = address;\n        self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n        if (isIP(ip) && (addressType === 4 || addressType === 6)) {\n          if (!destinations) {\n            destinations = addressType === 6 ? { 6: 0\x2C 4: 1 } : { 4: 0\x2C 6: 1 };\n          }\n\n          ArrayPrototypePush(validIps[destinations[addressType]]\x2C address);\n        }\n      }\n\n      // When no AAAA or A records are available\x2C fail on the first one\n      if (!validIps[0].length && !validIps[1].length) {\n        const { address: firstIp\x2C family: firstAddressType } = addresses[0];\n\n        if (!isIP(firstIp)) {\n          err = new ERR_INVALID_IP_ADDRESS(firstIp);\n          process.nextTick(connectErrorNT\x2C self\x2C err);\n        } else if (firstAddressType !== 4 && firstAddressType !== 6) {\n          err = new ERR_INVALID_ADDRESS_FAMILY(firstAddressType\x2C\n                                               options.host\x2C\n                                               options.port);\n          process.nextTick(connectErrorNT\x2C self\x2C err);\n        }\n\n        return;\n      }\n\n      // Sort addresses alternating families\n      const toAttempt = [];\n      for (let i = 0\x2C l = MathMax(validIps[0].length\x2C validIps[1].length); i < l; i++) {\n        if (i in validIps[0]) {\n          ArrayPrototypePush(toAttempt\x2C validIps[0][i]);\n        }\n        if (i in validIps[1]) {\n          ArrayPrototypePush(toAttempt\x2C validIps[1][i]);\n        }\n      }\n\n      self.autoSelectFamilyAttemptedAddresses = [];\n\n      const context = {\n        socket: self\x2C\n        addresses: toAttempt\x2C\n        current: 0\x2C\n        port\x2C\n        localPort\x2C\n        timeout\x2C\n        [kTimeout]: null\x2C\n        errors: []\x2C\n      };\n\n      self._unrefTimer();\n      defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C internalConnectMultiple\x2C context);\n    });\n  });\n}\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true\x2C self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n    if (self[kPerfHooksNetConnectContext] && hasObserver('net')) {\n      stopPerf(self\x2C kPerfHooksNetConnectContext);\n    }\n  } else {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction afterConnectMultiple(context\x2C current\x2C status\x2C handle\x2C req\x2C readable\x2C writable) {\n  // Make sure another connection is not spawned\n  clearTimeout(context[kTimeout]);\n\n  // One of the connection has completed and correctly dispatched but after timeout\x2C ignore this one\n  if (status === 0 && current !== context.current - 1) {\n    debug('connect/multiple: ignoring successful but timedout connection to %s:%s'\x2C req.address\x2C req.port);\n    handle.close();\n    return;\n  }\n\n  const self = context.socket;\n\n\n  // Some error occurred\x2C add to the list of exceptions\n  if (status !== 0) {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n\n    ArrayPrototypePush(context.errors\x2C ex);\n\n    // Try the next address\n    internalConnectMultiple(context\x2C status === UV_ECANCELED);\n    return;\n  }\n\n  // One of the connection has completed and correctly dispatched but after timeout\x2C ignore this one\n  if (status === 0 && current !== context.current - 1) {\n    debug('connect/multiple: ignoring successful but timedout connection to %s:%s'\x2C req.address\x2C req.port);\n    handle.close();\n    return;\n  }\n\n  if (context.current > 1 && self[kReinitializeHandle]) {\n    self[kReinitializeHandle](handle);\n    handle = self._handle;\n  }\n\n  if (hasObserver('net')) {\n    startPerf(\n      self\x2C\n      kPerfHooksNetConnectContext\x2C\n      { type: 'net'\x2C name: 'connect'\x2C detail: { host: req.address\x2C port: req.port } }\x2C\n    );\n  }\n\n  afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable);\n}\n\nfunction internalConnectMultipleTimeout(context\x2C req\x2C handle) {\n  debug('connect/multiple: connection to %s:%s timed out'\x2C req.address\x2C req.port);\n  req.oncomplete = undefined;\n  handle.close();\n  internalConnectMultiple(context);\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = kEmptyObject;\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\x2C\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n  if (typeof options.highWaterMark !== 'undefined') {\n    validateNumber(\n      options.highWaterMark\x2C 'options.highWaterMark'\x2C\n    );\n\n    if (options.highWaterMark < 0) {\n      options.highWaterMark = getDefaultHighWaterMark();\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n  this.highWaterMark = options.highWaterMark ?? getDefaultHighWaterMark();\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags\x2C options) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n    backlog\x2C\n    ...options\x2C\n  };\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C\n                    pipeName\x2C\n                    -1\x2C\n                    -1\x2C\n                    backlog\x2C\n                    undefined\x2C\n                    options.exclusive\x2C\n                    undefined\x2C\n                    {\n                      readableAll: options.readableAll\x2C\n                      writableAll: options.writableAll\x2C\n                    });\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    if (clientHandle.getsockname || clientHandle.getpeername) {\n      const data = ObjectCreate(null);\n      if (clientHandle.getsockname) {\n        const localInfo = ObjectCreate(null);\n        clientHandle.getsockname(localInfo);\n        data.localAddress = localInfo.address;\n        data.localPort = localInfo.port;\n        data.localFamily = localInfo.family;\n      }\n      if (clientHandle.getpeername) {\n        const remoteInfo = ObjectCreate(null);\n        clientHandle.getpeername(remoteInfo);\n        data.remoteAddress = remoteInfo.address;\n        data.remotePort = remoteInfo.port;\n        data.remoteFamily = remoteInfo.family;\n      }\n      self.emit('drop'\x2C data);\n    } else {\n      self.emit('drop');\n    }\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\x2C\n    readableHighWaterMark: self.highWaterMark\x2C\n    writableHighWaterMark: self.highWaterMark\x2C\n  });\n\n  if (self.noDelay && clientHandle.setNoDelay) {\n    socket[kSetNoDelay] = true;\n    clientHandle.setNoDelay(true);\n  }\n  if (self.keepAlive && clientHandle.setKeepAlive) {\n    socket[kSetKeepAlive] = true;\n    socket[kSetKeepAliveInitialDelay] = self.keepAliveInitialDelay;\n    clientHandle.setKeepAlive(true\x2C self.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n  lazyChannels();\n  if (netServerSocketChannel.hasSubscribers) {\n    netServerSocketChannel.publish({\n      socket\x2C\n    });\n  }\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype[SymbolAsyncDispose] = async function() {\n  if (!this._handle) {\n    return;\n  }\n  return FunctionPrototypeCall(promisify(this.close)\x2C this);\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\x2C\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  __proto__: null\x2C\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\x2C\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n  getDefaultAutoSelectFamily\x2C\n  setDefaultAutoSelectFamily\x2C\n  getDefaultAutoSelectFamilyAttemptTimeout\x2C\n  setDefaultAutoSelectFamilyAttemptTimeout\x2C\n};\n
code-source-info,0x287bc3a5148,415,0,64869,C0O0C4O64869,,
code-creation,Function,10,71188,0x287bc3a8810,3447, node:net:1:1,0x287bc3a50c0,~
code-source-info,0x287bc3a8810,415,0,64869,C0O0C552O1159C558O1175C564O1200C570O1222C576O1233C582O1258C588O1283C594O1294C600O1304C606O1319C612O1337C618O1361C623O1385C628O1395C634O1411C639O1470C647O1470C651O1470C653O1504C661O1504C665O1504C667O1535C675O1535C681O1568C697O1569C703O1535C705O1717C713O1717C719O1623C725O1646C731O1654C736O1664C741O1674C747O1698C753O1757C761O1757C765O1757C767O1858C771O1858C777O1795C783O1812C789O1825C795O1840C801O1901C809O1901C815O1890C821O1948C825O1948C831O1928C837O1998C841O1998C847O1981C853O2094C857O2094C863O2040C869O2047C875O2076C881O2190C885O2190C891O2133C897O2141C903O2171C909O2322C917O2322C923O2230C929O2244C941O2285C947O2302C953O2521C961O2521C967O2365C973O2382C979O2398C985O2414C990O2434C996O2445C1001O2461C1006O2481C1012O2492C1018O2505C1024O3011C1032O3011C1038O3011C1044O2585C1050O2617C1056O2643C1062O2670C1068O2695C1074O2723C1080O2752C1086O2783C1092O2811C1098O2834C1104O2875C1110O2900C1116O2919C1122O2937C1128O2962C1134O2982C1140O3064C1148O3064C1154O3047C1160O3123C1168O3123C1174O3104C1180O3200C1188O3200C1194O3172C1200O3186C1206O3369C1214O3369C1220O3236C1226O3259C1232O3278C1238O3298C1244O3315C1250O3333C1256O3349C1262O3429C1266O3429C1270O3429C1272O3528C1280O3528C1286O3469C1292O3501C1298O3583C1306O3583C1312O3564C1317O3664C1318O3664C1320O3677C1321O3677C1323O3686C1324O3686C1326O3701C1327O3701C1329O3746C1333O3746C1337O3746C1339O3847C1343O3847C1345O3890C1353O3890C1359O3861C1365O3875C1371O3930C1379O3930C1385O3917C1391O3985C1393O3985C1395O4022C1397O4022C1399O4047C1403O4055C1411O4064C1414O4047C1416O4091C1420O4091C1422O4138C1426O4138C1430O4138C1432O4182C1433O4182C1435O4210C1436O4210C1438O4844C1446O4844C1452O4802C1458O4817C1464O4830C1470O4914C1478O4914C1484O4886C1490O9349C1494O9349C1498O9349C1500O9393C1504O9393C1508O9393C1510O9438C1514O9438C1518O9438C1520O9483C1524O9483C1528O9483C1530O9542C1534O9542C1538O9542C1540O14124C1544O14152C1554O14170C1560O14177C1566O14124C1571O14189C1579O14225C1585O14189C1590O14265C1594O14272C1604O14294C1608O14520C1612O14527C1622O14544C1630O16028C1634O16035C1642O16056C1650O16078C1654O16085C1664O16106C1672O16616C1676O16623C1686O16644C1694O17027C1698O17034C1708O17057C1716O17669C1720O17676C1730O17694C1738O17744C1746O17772C1765O17826C1777O17744C1787O17877C1795O17905C1814O17950C1826O17877C1836O18036C1844O18064C1863O18117C1875O18036C1885O18440C1893O18468C1912O18521C1924O18440C1934O18608C1942O18636C1948O18647C1957O18689C1972O18608C1982O19055C1986O19062C1996O19078C2004O19403C2008O19410C2018O19424C2026O19616C2030O19623C2040O19649C2048O20004C2052O20011C2062O20027C2070O20367C2074O20374C2084O20391C2092O20581C2096O20588C2106O20603C2114O20940C2118O20947C2128O20969C2136O21122C2140O21129C2150O21148C2158O22663C2162O22670C2172O22687C2180O22791C2184O22798C2194O22821C2202O23307C2212O23307C2222O23427C2232O23427C2242O23526C2252O23526C2262O23622C2272O23622C2282O23713C2286O23720C2296O23743C2304O24025C2314O24025C2324O24123C2334O24123C2344O24211C2354O24211C2364O24305C2368O24312C2374O24322C2378O24340C2386O24392C2390O24399C2400O24423C2408O25341C2412O25348C2422O25366C2430O25440C2434O25447C2444O25464C2452O25708C2462O25708C2472O25848C2482O25848C2492O32092C2496O32099C2506O32117C2514O33573C2518O33580C2528O33590C2532O33611C2540O40978C2544O40985C2554O40999C2562O41192C2566O41199C2576O41215C2584O47150C2588O47178C2602O47202C2612O47150C2622O47214C2630O47214C2640O51200C2644O51207C2656O51226C2664O52711C2668O52718C2682O52735C2690O56980C2698O57008C2721O57060C2736O56980C2746O57152C2750O57159C2767O57177C2775O59541C2779O59548C2796O59573C2804O60332C2808O60339C2825O60355C2833O61227C2837O61234C2847O61244C2854O61264C2862O61389C2866O61396C2883O61426C2891O61904C2895O61911C2909O61934C2926O61958C2934O62276C2942O62301C2967O62344C2982O62384C2997O62276C3007O62432C3015O62460C3036O62505C3051O62540C3066O62432C3076O62583C3080O62590C3097O62613C3105O62859C3109O62866C3126O62880C3134O62983C3138O62990C3155O63006C3163O63114C3166O63169C3167O63169C3169O63176C3184O63199C3185O63199C3187O63223C3202O63931C3211O64203C3222O64245C3232O64283C3242O64300C3252O64559C3262O64588C3272O64599C3282O64621C3292O64637C3302O64655C3312O64665C3322O64675C3332O64693C3342O64720C3352O64750C3362O64780C3372O64824C3437O64218C3446O64868,,
tick,0x7f6e653749e1,71278,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
tick,0x134037f,71343,1,0xb795c0,6,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,71587,0x287bc3af800,5, node:stream:1:1,0x287bc3af5f8,~
script-source,416,node:stream,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  promisify: { custom: customPromisify }\x2C\n} = require('internal/util');\n\nconst {\n  streamReturningOperators\x2C\n  promiseReturningOperators\x2C\n} = require('internal/streams/operators');\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\x2C\n} = require('internal/errors');\nconst compose = require('internal/streams/compose');\nconst { setDefaultHighWaterMark\x2C getDefaultHighWaterMark } = require('internal/streams/state');\nconst { pipeline } = require('internal/streams/pipeline');\nconst { destroyer } = require('internal/streams/destroy');\nconst eos = require('internal/streams/end-of-stream');\nconst internalBuffer = require('internal/buffer');\n\nconst promises = require('stream/promises');\nconst utils = require('internal/streams/utils');\n\nconst Stream = module.exports = require('internal/streams/legacy').Stream;\n\nStream.isDestroyed = utils.isDestroyed;\nStream.isDisturbed = utils.isDisturbed;\nStream.isErrored = utils.isErrored;\nStream.isReadable = utils.isReadable;\nStream.isWritable = utils.isWritable;\n\nStream.Readable = require('internal/streams/readable');\nfor (const key of ObjectKeys(streamReturningOperators)) {\n  const op = streamReturningOperators[key];\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR();\n    }\n    return Stream.Readable.from(ReflectApply(op\x2C this\x2C args));\n  }\n  ObjectDefineProperty(fn\x2C 'name'\x2C { __proto__: null\x2C value: op.name });\n  ObjectDefineProperty(fn\x2C 'length'\x2C { __proto__: null\x2C value: op.length });\n  ObjectDefineProperty(Stream.Readable.prototype\x2C key\x2C {\n    __proto__: null\x2C\n    value: fn\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n  });\n}\nfor (const key of ObjectKeys(promiseReturningOperators)) {\n  const op = promiseReturningOperators[key];\n  function fn(...args) {\n    if (new.target) {\n      throw ERR_ILLEGAL_CONSTRUCTOR();\n    }\n    return ReflectApply(op\x2C this\x2C args);\n  }\n  ObjectDefineProperty(fn\x2C 'name'\x2C { __proto__: null\x2C value: op.name });\n  ObjectDefineProperty(fn\x2C 'length'\x2C { __proto__: null\x2C value: op.length });\n  ObjectDefineProperty(Stream.Readable.prototype\x2C key\x2C {\n    __proto__: null\x2C\n    value: fn\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n  });\n}\nStream.Writable = require('internal/streams/writable');\nStream.Duplex = require('internal/streams/duplex');\nStream.Transform = require('internal/streams/transform');\nStream.PassThrough = require('internal/streams/passthrough');\nStream.pipeline = pipeline;\nconst { addAbortSignal } = require('internal/streams/add-abort-signal');\nStream.addAbortSignal = addAbortSignal;\nStream.finished = eos;\nStream.destroy = destroyer;\nStream.compose = compose;\nStream.setDefaultHighWaterMark = setDefaultHighWaterMark;\nStream.getDefaultHighWaterMark = getDefaultHighWaterMark;\n\nObjectDefineProperty(Stream\x2C 'promises'\x2C {\n  __proto__: null\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    return promises;\n  }\x2C\n});\n\nObjectDefineProperty(pipeline\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    return promises.pipeline;\n  }\x2C\n});\n\nObjectDefineProperty(eos\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    return promises.finished;\n  }\x2C\n});\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream._isUint8Array = require('internal/util/types').isUint8Array;\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return new internalBuffer.FastBuffer(chunk.buffer\x2C\n                                       chunk.byteOffset\x2C\n                                       chunk.byteLength);\n};\n
code-source-info,0x287bc3af800,416,0,4784,C0O0C4O4784,,
code-creation,Function,10,71731,0x287bc3aff20,1092, node:stream:1:1,0x287bc3af778,~
code-source-info,0x287bc3aff20,416,0,4784,C0O0C20O1159C25O1183C30O1197C36O1283C40O1283C46O1283C52O1260C57O1379C61O1379C67O1320C72O1348C77O1476C81O1476C87O1476C93O1442C99O1520C103O1520C108O1618C112O1618C118O1565C123O1590C128O1674C132O1674C138O1661C143O1734C147O1734C153O1720C158O1783C162O1783C167O1849C171O1849C175O1849C177O1895C181O1895C185O1895C187O1937C191O1937C196O1988C200O2005C206O2039C212O2003C218O1988C220O2049C224O2076C228O2068C232O2089C236O2116C240O2108C244O2129C248O2154C252O2146C256O2165C260O2191C264O2183C268O2203C272O2229C276O2221C280O2242C288O2260C292O2258C296O2316C330O2309C361O2309C364O2309C377O2369C379O2393C382O2369C384O2561C388O2582C398O2623C409O2561C414O2634C418O2655C428O2698C439O2634C444O2711C450O2739C456O2748C462O2759C470O2798C477O2711C487O2298C558O2895C592O2888C623O2888C626O2888C639O2949C641O2974C644O2949C646O3120C650O3141C660O3182C671O3120C676O3193C680O3214C690O3257C701O3193C706O3270C712O3298C718O3307C724O3318C732O3357C739O3270C749O2877C820O3436C828O3454C832O3452C836O3492C844O3508C848O3506C852O3544C860O3563C864O3561C868O3602C876O3623C880O3621C884O3664C890O3680C894O3719C898O3719C904O3700C909O3765C915O3787C919O3805C925O3821C929O3828C935O3843C939O3856C945O3871C949O3882C955O3913C959O3940C965O3971C969O3999C977O4020C983O4105C991O3999C996O4175C1002O4235C1016O4144C1021O4309C1027O4369C1041O4283C1046O4453C1052O4467C1056O4478C1064O4501C1070O4531C1074O4499C1078O4546C1086O4573C1091O4783,,
code-creation,Eval,10,72017,0x287bc3b13a8,5, node:internal/streams/operators:1:1,0x287bc3b1060,~
script-source,417,node:internal/streams/operators,'use strict';\n\nconst { AbortController\x2C AbortSignal } = require('internal/abort_controller');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  validateAbortSignal\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { kWeakHandler\x2C kResistStopPropagation } = require('internal/event_target');\nconst { finished } = require('internal/streams/end-of-stream');\nconst staticCompose = require('internal/streams/compose');\nconst {\n  addAbortSignalNoValidate\x2C\n} = require('internal/streams/add-abort-signal');\nconst { isWritable\x2C isNodeStream } = require('internal/streams/utils');\nconst { deprecate } = require('internal/util');\n\nconst {\n  ArrayPrototypePush\x2C\n  Boolean\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  PromisePrototypeThen\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kEmpty = Symbol('kEmpty');\nconst kEof = Symbol('kEof');\n\nfunction compose(stream\x2C options) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  if (isNodeStream(stream) && !isWritable(stream)) {\n    throw new ERR_INVALID_ARG_VALUE('stream'\x2C stream\x2C 'must be writable');\n  }\n\n  const composedStream = staticCompose(this\x2C stream);\n\n  if (options?.signal) {\n    // Not validating as we already validated before\n    addAbortSignalNoValidate(\n      options.signal\x2C\n      composedStream\x2C\n    );\n  }\n\n  return composedStream;\n}\n\nfunction map(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  let concurrency = 1;\n  if (options?.concurrency != null) {\n    concurrency = MathFloor(options.concurrency);\n  }\n\n  let highWaterMark = concurrency - 1;\n  if (options?.highWaterMark != null) {\n    highWaterMark = MathFloor(options.highWaterMark);\n  }\n\n  validateInteger(concurrency\x2C 'options.concurrency'\x2C 1);\n  validateInteger(highWaterMark\x2C 'options.highWaterMark'\x2C 0);\n\n  highWaterMark += concurrency;\n\n  return async function* map() {\n    const signal = AbortSignal.any([options?.signal].filter(Boolean));\n    const stream = this;\n    const queue = [];\n    const signalOpt = { signal };\n\n    let next;\n    let resume;\n    let done = false;\n    let cnt = 0;\n\n    function onCatch() {\n      done = true;\n      afterItemProcessed();\n    }\n\n    function afterItemProcessed() {\n      cnt -= 1;\n      maybeResume();\n    }\n\n    function maybeResume() {\n      if (\n        resume &&\n        !done &&\n        cnt < concurrency &&\n        queue.length < highWaterMark\n      ) {\n        resume();\n        resume = null;\n      }\n    }\n\n    async function pump() {\n      try {\n        for await (let val of stream) {\n          if (done) {\n            return;\n          }\n\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n\n          try {\n            val = fn(val\x2C signalOpt);\n\n            if (val === kEmpty) {\n              continue;\n            }\n\n            val = PromiseResolve(val);\n          } catch (err) {\n            val = PromiseReject(err);\n          }\n\n          cnt += 1;\n\n          PromisePrototypeThen(val\x2C afterItemProcessed\x2C onCatch);\n\n          queue.push(val);\n          if (next) {\n            next();\n            next = null;\n          }\n\n          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {\n            await new Promise((resolve) => {\n              resume = resolve;\n            });\n          }\n        }\n        queue.push(kEof);\n      } catch (err) {\n        const val = PromiseReject(err);\n        PromisePrototypeThen(val\x2C afterItemProcessed\x2C onCatch);\n        queue.push(val);\n      } finally {\n        done = true;\n        if (next) {\n          next();\n          next = null;\n        }\n      }\n    }\n\n    pump();\n\n    try {\n      while (true) {\n        while (queue.length > 0) {\n          const val = await queue[0];\n\n          if (val === kEof) {\n            return;\n          }\n\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n\n          if (val !== kEmpty) {\n            yield val;\n          }\n\n          queue.shift();\n          maybeResume();\n        }\n\n        await new Promise((resolve) => {\n          next = resolve;\n        });\n      }\n    } finally {\n      done = true;\n      if (resume) {\n        resume();\n        resume = null;\n      }\n    }\n  }.call(this);\n}\n\nfunction asIndexedPairs(options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  return async function* asIndexedPairs() {\n    let index = 0;\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError({ cause: options.signal.reason });\n      }\n      yield [index++\x2C val];\n    }\n  }.call(this);\n}\n\nasync function some(fn\x2C options = undefined) {\n  for await (const unused of filter.call(this\x2C fn\x2C options)) {\n    return true;\n  }\n  return false;\n}\n\nasync function every(fn\x2C options = undefined) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n  return !(await some.call(this\x2C async (...args) => {\n    return !(await fn(...args));\n  }\x2C options));\n}\n\nasync function find(fn\x2C options) {\n  for await (const result of filter.call(this\x2C fn\x2C options)) {\n    return result;\n  }\n  return undefined;\n}\n\nasync function forEach(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  async function forEachFn(value\x2C options) {\n    await fn(value\x2C options);\n    return kEmpty;\n  }\n  // eslint-disable-next-line no-unused-vars\n  for await (const unused of map.call(this\x2C forEachFn\x2C options));\n}\n\nfunction filter(fn\x2C options) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'fn'\x2C ['Function'\x2C 'AsyncFunction']\x2C fn);\n  }\n  async function filterFn(value\x2C options) {\n    if (await fn(value\x2C options)) {\n      return value;\n    }\n    return kEmpty;\n  }\n  return map.call(this\x2C filterFn\x2C options);\n}\n\n// Specific to provide better error to reduce since the argument is only\n// missing if the stream has no items in it - but the code is still appropriate\nclass ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {\n  constructor() {\n    super('reduce');\n    this.message = 'Reduce of an empty stream requires an initial value';\n  }\n}\n\nasync function reduce(reducer\x2C initialValue\x2C options) {\n  if (typeof reducer !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'reducer'\x2C ['Function'\x2C 'AsyncFunction']\x2C reducer);\n  }\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  let hasInitialValue = arguments.length > 1;\n  if (options?.signal?.aborted) {\n    const err = new AbortError(undefined\x2C { cause: options.signal.reason });\n    this.once('error'\x2C () => {}); // The error is already propagated\n    await finished(this.destroy(err));\n    throw err;\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  if (options?.signal) {\n    const opts = { once: true\x2C [kWeakHandler]: this\x2C [kResistStopPropagation]: true };\n    options.signal.addEventListener('abort'\x2C () => ac.abort()\x2C opts);\n  }\n  let gotAnyItemFromStream = false;\n  try {\n    for await (const value of this) {\n      gotAnyItemFromStream = true;\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (!hasInitialValue) {\n        initialValue = value;\n        hasInitialValue = true;\n      } else {\n        initialValue = await reducer(initialValue\x2C value\x2C { signal });\n      }\n    }\n    if (!gotAnyItemFromStream && !hasInitialValue) {\n      throw new ReduceAwareErrMissingArgs();\n    }\n  } finally {\n    ac.abort();\n  }\n  return initialValue;\n}\n\nasync function toArray(options) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  const result = [];\n  for await (const val of this) {\n    if (options?.signal?.aborted) {\n      throw new AbortError(undefined\x2C { cause: options.signal.reason });\n    }\n    ArrayPrototypePush(result\x2C val);\n  }\n  return result;\n}\n\nfunction flatMap(fn\x2C options) {\n  const values = map.call(this\x2C fn\x2C options);\n  return async function* flatMap() {\n    for await (const val of values) {\n      yield* val;\n    }\n  }.call(this);\n}\n\nfunction toIntegerOrInfinity(number) {\n  // We coerce here to align with the spec\n  // https://github.com/tc39/proposal-iterator-helpers/issues/169\n  number = Number(number);\n  if (NumberIsNaN(number)) {\n    return 0;\n  }\n  if (number < 0) {\n    throw new ERR_OUT_OF_RANGE('number'\x2C '>= 0'\x2C number);\n  }\n  return number;\n}\n\nfunction drop(number\x2C options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  number = toIntegerOrInfinity(number);\n  return async function* drop() {\n    if (options?.signal?.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (number-- <= 0) {\n        yield val;\n      }\n    }\n  }.call(this);\n}\n\nfunction take(number\x2C options = undefined) {\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  if (options?.signal != null) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n\n  number = toIntegerOrInfinity(number);\n  return async function* take() {\n    if (options?.signal?.aborted) {\n      throw new AbortError();\n    }\n    for await (const val of this) {\n      if (options?.signal?.aborted) {\n        throw new AbortError();\n      }\n      if (number-- > 0) {\n        yield val;\n      }\n\n      // Don't get another item from iterator in case we reached the end\n      if (number <= 0) {\n        return;\n      }\n    }\n  }.call(this);\n}\n\nmodule.exports.streamReturningOperators = {\n  asIndexedPairs: deprecate(asIndexedPairs\x2C 'readable.asIndexedPairs will be removed in a future version.')\x2C\n  drop\x2C\n  filter\x2C\n  flatMap\x2C\n  map\x2C\n  take\x2C\n  compose\x2C\n};\n\nmodule.exports.promiseReturningOperators = {\n  every\x2C\n  forEach\x2C\n  reduce\x2C\n  toArray\x2C\n  some\x2C\n  find\x2C\n};\n
code-source-info,0x287bc3b13a8,417,0,10772,C0O0C4O10772,,
code-creation,Function,10,72319,0x287bc3b1eb8,561, node:internal/streams/operators:1:1,0x287bc3b1320,~
code-source-info,0x287bc3b1eb8,417,0,10772,C0O0C163O56C166O56C171O23C177O40C183O234C186O234C191O234C196O118C202O145C208O171C213O193C219O218C225O334C228O334C233O272C239O295C245O314C251O415C254O415C259O374C265O388C271O470C274O470C279O457C285O535C288O535C292O535C294O612C297O612C302O582C308O695C311O695C316O666C322O678C328O752C331O752C336O738C341O789C347O811C353O822C359O835C365O845C371O860C377O871C383O888C389O906C395O930C400O971C403O971C407O971C409O1002C412O1002C416O1002C418O6699C440O6659C442O10462C456O10517C467O10610C473O10618C479O10628C485O10639C491O10646C497O10654C503O10495C507O10674C519O10714C525O10723C531O10734C537O10744C543O10755C549O10763C555O10708C560O10771,,
tick,0xdb541c,72412,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x287bc3b1f5e,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,72643,0x287bc3b3da0,5, node:internal/abort_controller:1:1,0x287bc3b3898,~
script-source,418,node:internal/abort_controller,'use strict';\n\n// Modeled very closely on the AbortController implementation\n// in https://github.com/mysticatea/abort-controller (MIT license)\n\nconst {\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectDefineProperty\x2C\n  PromiseResolve\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  WeakRef\x2C\n} = primordials;\n\nconst {\n  defineEventHandler\x2C\n  EventTarget\x2C\n  Event\x2C\n  kTrustEvent\x2C\n  kNewListener\x2C\n  kRemoveListener\x2C\n  kResistStopPropagation\x2C\n  kWeakHandler\x2C\n} = require('internal/event_target');\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('internal/util/inspect');\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateAbortSignalArray\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  clearTimeout\x2C\n  setTimeout\x2C\n} = require('timers');\nconst assert = require('internal/assert');\n\nconst {\n  messaging_deserialize_symbol: kDeserialize\x2C\n  messaging_transfer_symbol: kTransfer\x2C\n  messaging_transfer_list_symbol: kTransferList\x2C\n} = internalBinding('symbols');\n\nlet _MessageChannel;\nlet makeTransferable;\n\n// Loading the MessageChannel and makeTransferable have to be done lazily\n// because otherwise we'll end up with a require cycle that ends up with\n// an incomplete initialization of abort_controller.\n\nfunction lazyMessageChannel() {\n  _MessageChannel ??= require('internal/worker/io').MessageChannel;\n  return new _MessageChannel();\n}\n\nfunction lazyMakeTransferable(obj) {\n  makeTransferable ??=\n    require('internal/worker/js_transferable').makeTransferable;\n  return makeTransferable(obj);\n}\n\nconst clearTimeoutRegistry = new SafeFinalizationRegistry(clearTimeout);\nconst gcPersistentSignals = new SafeSet();\n\nconst kAborted = Symbol('kAborted');\nconst kReason = Symbol('kReason');\nconst kCloneData = Symbol('kCloneData');\nconst kTimeout = Symbol('kTimeout');\nconst kMakeTransferable = Symbol('kMakeTransferable');\nconst kComposite = Symbol('kComposite');\nconst kSourceSignals = Symbol('kSourceSignals');\nconst kDependantSignals = Symbol('kDependantSignals');\n\nfunction customInspect(self\x2C obj\x2C depth\x2C options) {\n  if (depth < 0)\n    return self;\n\n  const opts = ObjectAssign({}\x2C options\x2C {\n    depth: options.depth === null ? null : options.depth - 1\x2C\n  });\n\n  return `${self.constructor.name} ${inspect(obj\x2C opts)}`;\n}\n\nfunction validateThisAbortSignal(obj) {\n  if (obj?.[kAborted] === undefined)\n    throw new ERR_INVALID_THIS('AbortSignal');\n}\n\n// Because the AbortSignal timeout cannot be canceled\x2C we don't want the\n// presence of the timer alone to keep the AbortSignal from being garbage\n// collected if it otherwise no longer accessible. We also don't want the\n// timer to keep the Node.js process open on it's own. Therefore\x2C we wrap\n// the AbortSignal in a WeakRef and have the setTimeout callback close\n// over the WeakRef rather than directly over the AbortSignal\x2C and we unref\n// the created timer object. Separately\x2C we add the signal to a\n// FinalizerRegistry that will clear the timeout when the signal is gc'd.\nfunction setWeakAbortSignalTimeout(weakRef\x2C delay) {\n  const timeout = setTimeout(() => {\n    const signal = weakRef.deref();\n    if (signal !== undefined) {\n      gcPersistentSignals.delete(signal);\n      abortSignal(\n        signal\x2C\n        new DOMException(\n          'The operation was aborted due to timeout'\x2C\n          'TimeoutError'));\n    }\n  }\x2C delay);\n  timeout.unref();\n  return timeout;\n}\n\nclass AbortSignal extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get aborted() {\n    validateThisAbortSignal(this);\n    return !!this[kAborted];\n  }\n\n  /**\n   * @type {any}\n   */\n  get reason() {\n    validateThisAbortSignal(this);\n    return this[kReason];\n  }\n\n  throwIfAborted() {\n    validateThisAbortSignal(this);\n    if (this[kAborted]) {\n      throw this[kReason];\n    }\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    return customInspect(this\x2C {\n      aborted: this.aborted\x2C\n    }\x2C depth\x2C options);\n  }\n\n  /**\n   * @param {any} [reason]\n   * @returns {AbortSignal}\n   */\n  static abort(\n    reason = new DOMException('This operation was aborted'\x2C 'AbortError')) {\n    return createAbortSignal({ aborted: true\x2C reason });\n  }\n\n  /**\n   * @param {number} delay\n   * @returns {AbortSignal}\n   */\n  static timeout(delay) {\n    validateUint32(delay\x2C 'delay'\x2C false);\n    const signal = createAbortSignal();\n    signal[kTimeout] = true;\n    clearTimeoutRegistry.register(\n      signal\x2C\n      setWeakAbortSignalTimeout(new WeakRef(signal)\x2C delay));\n    return signal;\n  }\n\n  /**\n   * @param {AbortSignal[]} signals\n   * @returns {AbortSignal}\n   */\n  static any(signals) {\n    validateAbortSignalArray(signals\x2C 'signals');\n    const resultSignal = createAbortSignal({ composite: true });\n    if (!signals.length) {\n      return resultSignal;\n    }\n    const resultSignalWeakRef = new WeakRef(resultSignal);\n    resultSignal[kSourceSignals] = new SafeSet();\n    for (let i = 0; i < signals.length; i++) {\n      const signal = signals[i];\n      if (signal.aborted) {\n        abortSignal(resultSignal\x2C signal.reason);\n        return resultSignal;\n      }\n      signal[kDependantSignals] ??= new SafeSet();\n      if (!signal[kComposite]) {\n        resultSignal[kSourceSignals].add(new WeakRef(signal));\n        signal[kDependantSignals].add(resultSignalWeakRef);\n      } else if (!signal[kSourceSignals]) {\n        continue;\n      } else {\n        for (const sourceSignal of signal[kSourceSignals]) {\n          const sourceSignalRef = sourceSignal.deref();\n          if (!sourceSignalRef) {\n            continue;\n          }\n          assert(!sourceSignalRef.aborted);\n          assert(!sourceSignalRef[kComposite]);\n\n          if (resultSignal[kSourceSignals].has(sourceSignal)) {\n            continue;\n          }\n          resultSignal[kSourceSignals].add(sourceSignal);\n          sourceSignalRef[kDependantSignals].add(resultSignalWeakRef);\n        }\n      }\n    }\n    return resultSignal;\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    super[kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n    const isTimeoutOrNonEmptyCompositeSignal = this[kTimeout] || (this[kComposite] && this[kSourceSignals]?.size);\n    if (isTimeoutOrNonEmptyCompositeSignal &&\n        type === 'abort' &&\n        !this.aborted &&\n        !weak &&\n        size === 1) {\n      // If this is a timeout signal\x2C or a non-empty composite signal\x2C and we're adding a non-weak abort\n      // listener\x2C then we don't want it to be gc'd while the listener\n      // is attached and the timer still hasn't fired. So\x2C we retain a\n      // strong ref that is held for as long as the listener is registered.\n      gcPersistentSignals.add(this);\n    }\n  }\n\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {\n    super[kRemoveListener](size\x2C type\x2C listener\x2C capture);\n    const isTimeoutOrNonEmptyCompositeSignal = this[kTimeout] || (this[kComposite] && this[kSourceSignals]?.size);\n    if (isTimeoutOrNonEmptyCompositeSignal && type === 'abort' && size === 0) {\n      gcPersistentSignals.delete(this);\n    }\n  }\n\n  [kTransfer]() {\n    validateThisAbortSignal(this);\n    const aborted = this.aborted;\n    if (aborted) {\n      const reason = this.reason;\n      return {\n        data: { aborted\x2C reason }\x2C\n        deserializeInfo: 'internal/abort_controller:ClonedAbortSignal'\x2C\n      };\n    }\n\n    const { port1\x2C port2 } = this[kCloneData];\n    this[kCloneData] = undefined;\n\n    this.addEventListener('abort'\x2C () => {\n      port1.postMessage(this.reason);\n      port1.close();\n    }\x2C { once: true });\n\n    return {\n      data: { port: port2 }\x2C\n      deserializeInfo: 'internal/abort_controller:ClonedAbortSignal'\x2C\n    };\n  }\n\n  [kTransferList]() {\n    if (!this.aborted) {\n      const { port1\x2C port2 } = lazyMessageChannel();\n      port1.unref();\n      port2.unref();\n      this[kCloneData] = {\n        port1\x2C\n        port2\x2C\n      };\n      return [port2];\n    }\n    return [];\n  }\n\n  [kDeserialize]({ aborted\x2C reason\x2C port }) {\n    if (aborted) {\n      this[kAborted] = aborted;\n      this[kReason] = reason;\n      return;\n    }\n\n    port.onmessage = ({ data }) => {\n      abortSignal(this\x2C data);\n      port.close();\n      port.onmessage = undefined;\n    };\n    // The receiving port\x2C by itself\x2C should never keep the event loop open.\n    // The unref() has to be called *after* setting the onmessage handler.\n    port.unref();\n  }\n}\n\nfunction ClonedAbortSignal() {\n  return createAbortSignal({ transferable: true });\n}\nClonedAbortSignal.prototype[kDeserialize] = () => { };\n\nObjectDefineProperties(AbortSignal.prototype\x2C {\n  aborted: kEnumerableProperty\x2C\n});\n\nObjectDefineProperty(AbortSignal.prototype\x2C SymbolToStringTag\x2C {\n  __proto__: null\x2C\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'AbortSignal'\x2C\n});\n\ndefineEventHandler(AbortSignal.prototype\x2C 'abort');\n\n/**\n * @param {{\n *   aborted? : boolean\x2C\n *   reason? : any\x2C\n *   transferable? : boolean\x2C\n *   composite? : boolean\x2C\n * }} [init]\n * @returns {AbortSignal}\n */\nfunction createAbortSignal(init = kEmptyObject) {\n  const {\n    aborted = false\x2C\n    reason = undefined\x2C\n    transferable = false\x2C\n    composite = false\x2C\n  } = init;\n  const signal = new EventTarget();\n  ObjectSetPrototypeOf(signal\x2C AbortSignal.prototype);\n  signal[kAborted] = aborted;\n  signal[kReason] = reason;\n  signal[kComposite] = composite;\n  return transferable ? lazyMakeTransferable(signal) : signal;\n}\n\nfunction abortSignal(signal\x2C reason) {\n  if (signal[kAborted]) return;\n  signal[kAborted] = true;\n  signal[kReason] = reason;\n  const event = new Event('abort'\x2C {\n    [kTrustEvent]: true\x2C\n  });\n  signal.dispatchEvent(event);\n  signal[kDependantSignals]?.forEach((s) => {\n    const signalRef = s.deref();\n    if (signalRef) abortSignal(signalRef\x2C reason);\n  });\n}\n\n// TODO(joyeecheung): use private fields and we'll get invalid access\n// validation from V8 instead of throwing ERR_INVALID_THIS ourselves.\nconst kSignal = Symbol('signal');\n\nfunction validateAbortController(obj) {\n  if (obj?.[kSignal] === undefined)\n    throw new ERR_INVALID_THIS('AbortController');\n}\n\nclass AbortController {\n  constructor() {\n    this[kSignal] = createAbortSignal();\n  }\n\n  /**\n   * @type {AbortSignal}\n   */\n  get signal() {\n    validateAbortController(this);\n    return this[kSignal];\n  }\n\n  /**\n   * @param {any} [reason]\n   */\n  abort(reason = new DOMException('This operation was aborted'\x2C 'AbortError')) {\n    validateAbortController(this);\n    abortSignal(this[kSignal]\x2C reason);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    return customInspect(this\x2C {\n      signal: this.signal\x2C\n    }\x2C depth\x2C options);\n  }\n\n  static [kMakeTransferable]() {\n    const controller = new AbortController();\n    controller[kSignal] = transferableAbortSignal(controller[kSignal]);\n    return controller;\n  }\n}\n\n/**\n * Enables the AbortSignal to be transferable using structuredClone/postMessage.\n * @param {AbortSignal} signal\n * @returns {AbortSignal}\n */\nfunction transferableAbortSignal(signal) {\n  if (signal?.[kAborted] === undefined)\n    throw new ERR_INVALID_ARG_TYPE('signal'\x2C 'AbortSignal'\x2C signal);\n  return lazyMakeTransferable(signal);\n}\n\n/**\n * Creates an AbortController with a transferable AbortSignal\n */\nfunction transferableAbortController() {\n  return AbortController[kMakeTransferable]();\n}\n\n/**\n * @param {AbortSignal} signal\n * @param {any} resource\n * @returns {Promise<void>}\n */\nasync function aborted(signal\x2C resource) {\n  if (signal === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('signal'\x2C 'AbortSignal'\x2C signal);\n  }\n  validateAbortSignal(signal\x2C 'signal');\n  validateObject(resource\x2C 'resource'\x2C { nullable: false\x2C allowFunction: true\x2C allowArray: true });\n  if (signal.aborted)\n    return PromiseResolve();\n  const abortPromise = createDeferredPromise();\n  const opts = { __proto__: null\x2C [kWeakHandler]: resource\x2C once: true\x2C [kResistStopPropagation]: true };\n  signal.addEventListener('abort'\x2C abortPromise.resolve\x2C opts);\n  return abortPromise.promise;\n}\n\nObjectDefineProperties(AbortController.prototype\x2C {\n  signal: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n});\n\nObjectDefineProperty(AbortController.prototype\x2C SymbolToStringTag\x2C {\n  __proto__: null\x2C\n  writable: false\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  value: 'AbortController'\x2C\n});\n\nmodule.exports = {\n  AbortController\x2C\n  AbortSignal\x2C\n  ClonedAbortSignal\x2C\n  aborted\x2C\n  transferableAbortSignal\x2C\n  transferableAbortController\x2C\n};\n
code-source-info,0x287bc3b3da0,418,0,12781,C0O0C4O12781,,
code-creation,Function,10,73000,0x287bc3b56d8,1057, node:internal/abort_controller:1:1,0x287bc3b3d18,~
code-source-info,0x287bc3b56d8,418,0,12781,C0O0C198O155C204O171C209O197C215O221C220O245C226O263C231O291C237O302C242O312C247O333C253O510C261O510C267O370C272O392C278O407C284O416C290O431C296O447C302O466C308O492C314O643C322O643C328O554C334O579C339O602C345O618C350O689C358O689C364O677C370O828C378O828C384O828C390O746C396O775C402O801C408O956C416O956C422O867C428O890C434O918C440O936C446O1017C450O1017C456O999C462O1090C470O1090C476O1058C481O1074C487O1124C495O1124C499O1124C501O1300C505O1300C511O1193C516O1236C521O1281C526O1333C527O1333C529O1354C530O1354C532O1898C534O1898C539O1898C541O1970C545O1970C550O1970C552O2003C556O2003C560O2003C562O2039C566O2039C570O2039C572O2077C576O2077C580O2077C582O2116C586O2116C590O2116C592O2162C596O2162C600O2162C602O2210C606O2210C610O2210C612O2255C616O2255C620O2255C622O2307C626O2307C630O2307C642O3733C668O4166C698O6283C710O7055C720O7413C730O8024C740O8280C770O3707C772O8834C778O8844C782O8858C786O8872C790O8907C804O8931C808O8872C813O8957C817O8990C823O9001C832O8957C837O9132C841O9163C851O9132C856O10282C860O10282C864O10282C896O10842C908O10980C948O10431C950O12334C954O12373C968O12396C974O12426C978O12334C983O12452C987O12489C993O12500C1002O12452C1007O12635C1015O12656C1021O12675C1027O12690C1033O12711C1039O12722C1045O12749C1051O12650C1056O12780,,
code-creation,LazyCompile,10,73108,0x287bc3b7088,27,SafeFinalizationRegistry node:internal/per_context/primordials:440:16,0x23f41f788d70,~
code-source-info,0x287bc3b7088,12,12756,12801,C3O12776C7O12782C11O12776C26O12800,,
code-creation,LazyCompile,10,73171,0x287bc3b7440,57,defineEventHandler node:internal/event_target:1078:28,0x13800b1554e8,~
code-source-info,0x287bc3b7440,52,28522,29689,C0O28522C9O28609C21O28644C31O28679C39O28756C50O28609C56O29688,,
code-creation,Eval,10,73358,0x287bc3b7c40,5, node:internal/streams/end-of-stream:1:1,0x287bc3b78e8,~
script-source,419,node:internal/streams/end-of-stream,// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author\x2C Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst {\n  AbortError\x2C\n  codes\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_STREAM_PREMATURE_CLOSE\x2C\n} = codes;\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateObject\x2C\n  validateBoolean\x2C\n} = require('internal/validators');\n\nconst {\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  SymbolDispose\x2C\n} = primordials;\n\nconst {\n  isClosed\x2C\n  isReadable\x2C\n  isReadableNodeStream\x2C\n  isReadableStream\x2C\n  isReadableFinished\x2C\n  isReadableErrored\x2C\n  isWritable\x2C\n  isWritableNodeStream\x2C\n  isWritableStream\x2C\n  isWritableFinished\x2C\n  isWritableErrored\x2C\n  isNodeStream\x2C\n  willEmitClose: _willEmitClose\x2C\n  kIsClosedPromise\x2C\n} = require('internal/streams/utils');\nlet addAbortListener;\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nconst nop = () => {};\n\nfunction eos(stream\x2C options\x2C callback) {\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options\x2C 'options');\n  }\n  validateFunction(callback\x2C 'callback');\n  validateAbortSignal(options.signal\x2C 'options.signal');\n\n  callback = once(callback);\n\n  if (isReadableStream(stream) || isWritableStream(stream)) {\n    return eosWeb(stream\x2C options\x2C callback);\n  }\n\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream'\x2C ['ReadableStream'\x2C 'WritableStream'\x2C 'Stream']\x2C stream);\n  }\n\n  const readable = options.readable ?? isReadableNodeStream(stream);\n  const writable = options.writable ?? isWritableNodeStream(stream);\n\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = (\n    _willEmitClose(stream) &&\n    isReadableNodeStream(stream) === readable &&\n    isWritableNodeStream(stream) === writable\n  );\n\n  let writableFinished = isWritableFinished(stream\x2C false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n\n  let readableFinished = isReadableFinished(stream\x2C false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n\n  const onerror = (err) => {\n    callback.call(stream\x2C err);\n  };\n\n  let closed = isClosed(stream);\n\n  const onclose = () => {\n    closed = true;\n\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream\x2C errored);\n    }\n\n    if (readable && !readableFinished && isReadableNodeStream(stream\x2C true)) {\n      if (!isReadableFinished(stream\x2C false))\n        return callback.call(stream\x2C\n                             new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream\x2C false))\n        return callback.call(stream\x2C\n                             new ERR_STREAM_PREMATURE_CLOSE());\n    }\n\n    callback.call(stream);\n  };\n\n  const onclosed = () => {\n    closed = true;\n\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream\x2C errored);\n    }\n\n    callback.call(stream);\n  };\n\n  const onrequest = () => {\n    stream.req.on('finish'\x2C onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete'\x2C onfinish);\n    if (!willEmitClose) {\n      stream.on('abort'\x2C onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request'\x2C onrequest);\n    }\n  } else if (writable && !wState) { // legacy streams\n    stream.on('end'\x2C onlegacyfinish);\n    stream.on('close'\x2C onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted'\x2C onclose);\n  }\n\n  stream.on('end'\x2C onend);\n  stream.on('finish'\x2C onfinish);\n  if (options.error !== false) {\n    stream.on('error'\x2C onerror);\n  }\n  stream.on('close'\x2C onclose);\n\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState?.errorEmitted || rState?.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclosed);\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclosed);\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclosed);\n  } else if ((rState && stream.req && stream.aborted)) {\n    process.nextTick(onclosed);\n  }\n\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted'\x2C onclose);\n    stream.removeListener('complete'\x2C onfinish);\n    stream.removeListener('abort'\x2C onclose);\n    stream.removeListener('request'\x2C onrequest);\n    if (stream.req) stream.req.removeListener('finish'\x2C onfinish);\n    stream.removeListener('end'\x2C onlegacyfinish);\n    stream.removeListener('close'\x2C onlegacyfinish);\n    stream.removeListener('finish'\x2C onfinish);\n    stream.removeListener('end'\x2C onend);\n    stream.removeListener('error'\x2C onerror);\n    stream.removeListener('close'\x2C onclose);\n  };\n\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(\n        stream\x2C\n        new AbortError(undefined\x2C { cause: options.signal.reason }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener ??= require('events').addAbortListener;\n      const disposable = addAbortListener(options.signal\x2C abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream\x2C args);\n      });\n    }\n  }\n\n  return cleanup;\n}\n\nfunction eosWeb(stream\x2C options\x2C callback) {\n  let isAborted = false;\n  let abort = nop;\n  if (options.signal) {\n    abort = () => {\n      isAborted = true;\n      callback.call(stream\x2C new AbortError(undefined\x2C { cause: options.signal.reason }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      addAbortListener ??= require('events').addAbortListener;\n      const disposable = addAbortListener(options.signal\x2C abort);\n      const originalCallback = callback;\n      callback = once((...args) => {\n        disposable[SymbolDispose]();\n        originalCallback.apply(stream\x2C args);\n      });\n    }\n  }\n  const resolverFn = (...args) => {\n    if (!isAborted) {\n      process.nextTick(() => callback.apply(stream\x2C args));\n    }\n  };\n  PromisePrototypeThen(\n    stream[kIsClosedPromise].promise\x2C\n    resolverFn\x2C\n    resolverFn\x2C\n  );\n  return nop;\n}\n\nfunction finished(stream\x2C opts) {\n  let autoCleanup = false;\n  if (opts === null) {\n    opts = kEmptyObject;\n  }\n  if (opts?.cleanup) {\n    validateBoolean(opts.cleanup\x2C 'cleanup');\n    autoCleanup = opts.cleanup;\n  }\n  return new Promise((resolve\x2C reject) => {\n    const cleanup = eos(stream\x2C opts\x2C (err) => {\n      if (autoCleanup) {\n        cleanup();\n      }\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nmodule.exports = eos;\nmodule.exports.finished = finished;\n
code-source-info,0x287bc3b7c40,419,0,8360,C0O0C4O8360,,
code-creation,Function,10,73650,0x287bc3b7f80,353, node:internal/streams/end-of-stream:1:1,0x287bc3b7bb8,~
code-source-info,0x287bc3b7f80,419,0,8360,C0O0C120O172C126O172C131O147C137O161C142O210C148O234C154O309C160O309C165O283C171O299C177O427C183O427C188O345C194O368C200O388C206O406C212O470C218O481C224O505C230O833C236O833C241O548C247O560C253O574C259O598C265O618C271O640C277O661C283O675C289O699C295O719C301O741C307O762C313O793C319O811C325O872C326O872C328O1000C332O1000C334O8302C336O8317C340O8331C347O8348C352O8359,,
tick,0x7f6e650a37f0,73694,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3b1fca,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,73857,0x287bc3b9118,5, node:internal/streams/compose:1:1,0x287bc3b8ef0,~
script-source,420,node:internal/streams/compose,'use strict';\n\nconst { pipeline } = require('internal/streams/pipeline');\nconst Duplex = require('internal/streams/duplex');\nconst { destroyer } = require('internal/streams/destroy');\nconst {\n  isNodeStream\x2C\n  isReadable\x2C\n  isWritable\x2C\n  isWebStream\x2C\n  isTransformStream\x2C\n  isWritableStream\x2C\n  isReadableStream\x2C\n} = require('internal/streams/utils');\nconst {\n  AbortError\x2C\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\nconst eos = require('internal/streams/end-of-stream');\n\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  if (streams.length === 1) {\n    return Duplex.from(streams[0]);\n  }\n\n  const orgStreams = [...streams];\n\n  if (typeof streams[0] === 'function') {\n    streams[0] = Duplex.from(streams[0]);\n  }\n\n  if (typeof streams[streams.length - 1] === 'function') {\n    const idx = streams.length - 1;\n    streams[idx] = Duplex.from(streams[idx]);\n  }\n\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {\n      // TODO(ronag): Add checks for non streams.\n      continue;\n    }\n    if (\n      n < streams.length - 1 &&\n      !(\n        isReadable(streams[n]) ||\n        isReadableStream(streams[n]) ||\n        isTransformStream(streams[n])\n      )\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(\n        `streams[${n}]`\x2C\n        orgStreams[n]\x2C\n        'must be readable'\x2C\n      );\n    }\n    if (\n      n > 0 &&\n      !(\n        isWritable(streams[n]) ||\n        isWritableStream(streams[n]) ||\n        isTransformStream(streams[n])\n      )\n    ) {\n      throw new ERR_INVALID_ARG_VALUE(\n        `streams[${n}]`\x2C\n        orgStreams[n]\x2C\n        'must be writable'\x2C\n      );\n    }\n  }\n\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n\n  const head = streams[0];\n  const tail = pipeline(streams\x2C onfinished);\n\n  const writable = !!(\n    isWritable(head) ||\n    isWritableStream(head) ||\n    isTransformStream(head)\n  );\n  const readable = !!(\n    isReadable(tail) ||\n    isReadableStream(tail) ||\n    isTransformStream(tail)\n  );\n\n  // TODO(ronag): Avoid double buffering.\n  // Implement Writable/Readable/Duplex traits.\n  // See\x2C https://github.com/nodejs/node/pull/33515.\n  d = new Duplex({\n    // TODO (ronag): highWaterMark?\n    writableObjectMode: !!head?.writableObjectMode\x2C\n    readableObjectMode: !!tail?.readableObjectMode\x2C\n    writable\x2C\n    readable\x2C\n  });\n\n  if (writable) {\n    if (isNodeStream(head)) {\n      d._write = function(chunk\x2C encoding\x2C callback) {\n        if (head.write(chunk\x2C encoding)) {\n          callback();\n        } else {\n          ondrain = callback;\n        }\n      };\n\n      d._final = function(callback) {\n        head.end();\n        onfinish = callback;\n      };\n\n      head.on('drain'\x2C function() {\n        if (ondrain) {\n          const cb = ondrain;\n          ondrain = null;\n          cb();\n        }\n      });\n    } else if (isWebStream(head)) {\n      const writable = isTransformStream(head) ? head.writable : head;\n      const writer = writable.getWriter();\n\n      d._write = async function(chunk\x2C encoding\x2C callback) {\n        try {\n          await writer.ready;\n          writer.write(chunk).catch(() => {});\n          callback();\n        } catch (err) {\n          callback(err);\n        }\n      };\n\n      d._final = async function(callback) {\n        try {\n          await writer.ready;\n          writer.close().catch(() => {});\n          onfinish = callback;\n        } catch (err) {\n          callback(err);\n        }\n      };\n    }\n\n    const toRead = isTransformStream(tail) ? tail.readable : tail;\n\n    eos(toRead\x2C () => {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n\n  if (readable) {\n    if (isNodeStream(tail)) {\n      tail.on('readable'\x2C function() {\n        if (onreadable) {\n          const cb = onreadable;\n          onreadable = null;\n          cb();\n        }\n      });\n\n      tail.on('end'\x2C function() {\n        d.push(null);\n      });\n\n      d._read = function() {\n        while (true) {\n          const buf = tail.read();\n          if (buf === null) {\n            onreadable = d._read;\n            return;\n          }\n\n          if (!d.push(buf)) {\n            return;\n          }\n        }\n      };\n    } else if (isWebStream(tail)) {\n      const readable = isTransformStream(tail) ? tail.readable : tail;\n      const reader = readable.getReader();\n      d._read = async function() {\n        while (true) {\n          try {\n            const { value\x2C done } = await reader.read();\n\n            if (!d.push(value)) {\n              return;\n            }\n\n            if (done) {\n              d.push(null);\n              return;\n            }\n          } catch {\n            return;\n          }\n        }\n      };\n    }\n  }\n\n  d._destroy = function(err\x2C callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      if (isNodeStream(tail)) {\n        destroyer(tail\x2C err);\n      }\n    }\n  };\n\n  return d;\n};\n
code-source-info,0x287bc3b9118,420,0,5451,C0O0C4O5451,,
code-creation,Function,10,74044,0x287bc3b9310,184, node:internal/streams/compose:1:1,0x287bc3b9090,~
code-source-info,0x287bc3b9310,420,0,5451,C0O0C47O36C50O36C55O23C61O89C64O89C68O89C70O147C73O147C78O133C84O316C87O316C92O194C98O210C104O224C110O238C116O253C122O274C128O294C134O442C137O442C142O361C153O388C159O415C165O482C168O482C172O482C174O526C178O541C183O5450,,
code-creation,Eval,10,74284,0x287bc3ba498,5, node:internal/streams/pipeline:1:1,0x287bc3ba0e0,~
script-source,421,node:internal/streams/pipeline,// Ported from https://github.com/mafintosh/pump with\n// permission from the author\x2C Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Promise\x2C\n  SymbolAsyncIterator\x2C\n  SymbolDispose\x2C\n} = primordials;\n\nconst eos = require('internal/streams/end-of-stream');\nconst { once } = require('internal/util');\nconst destroyImpl = require('internal/streams/destroy');\nconst Duplex = require('internal/streams/duplex');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_RETURN_VALUE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_STREAM_DESTROYED\x2C\n    ERR_STREAM_PREMATURE_CLOSE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  validateFunction\x2C\n  validateAbortSignal\x2C\n} = require('internal/validators');\n\nconst {\n  isIterable\x2C\n  isReadable\x2C\n  isReadableNodeStream\x2C\n  isNodeStream\x2C\n  isTransformStream\x2C\n  isWebStream\x2C\n  isReadableStream\x2C\n  isReadableFinished\x2C\n} = require('internal/streams/utils');\nconst { AbortController } = require('internal/abort_controller');\n\nlet PassThrough;\nlet Readable;\nlet addAbortListener;\n\nfunction destroyer(stream\x2C reading\x2C writing) {\n  let finished = false;\n  stream.on('close'\x2C () => {\n    finished = true;\n  });\n\n  const cleanup = eos(stream\x2C { readable: reading\x2C writable: writing }\x2C (err) => {\n    finished = !err;\n  });\n\n  return {\n    destroy: (err) => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream\x2C err || new ERR_STREAM_DESTROYED('pipe'));\n    }\x2C\n    cleanup\x2C\n  };\n}\n\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1]\x2C 'streams[stream.length - 1]');\n  return streams.pop();\n}\n\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable']\x2C val);\n}\n\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('internal/streams/readable');\n  }\n\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\n\nasync function pumpToNode(iterable\x2C writable\x2C finish\x2C { end }) {\n  let error;\n  let onresolve = null;\n\n  const resume = (err) => {\n    if (err) {\n      error = err;\n    }\n\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n\n  const wait = () => new Promise((resolve\x2C reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n\n  writable.on('drain'\x2C resume);\n  const cleanup = eos(writable\x2C { readable: false }\x2C resume);\n\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n\n    if (end) {\n      writable.end();\n      await wait();\n    }\n\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error\x2C err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain'\x2C resume);\n  }\n}\n\nasync function pumpToWeb(readable\x2C writable\x2C finish\x2C { end }) {\n  if (isTransformStream(writable)) {\n    writable = writable.writable;\n  }\n  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure\n  const writer = writable.getWriter();\n  try {\n    for await (const chunk of readable) {\n      await writer.ready;\n      writer.write(chunk).catch(() => {});\n    }\n\n    await writer.ready;\n\n    if (end) {\n      await writer.close();\n    }\n\n    finish();\n  } catch (err) {\n    try {\n      await writer.abort(err);\n      finish(err);\n    } catch (err) {\n      finish(err);\n    }\n  }\n}\n\nfunction pipeline(...streams) {\n  return pipelineImpl(streams\x2C once(popCallback(streams)));\n}\n\nfunction pipelineImpl(streams\x2C callback\x2C opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts?.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n\n  validateAbortSignal(outerSignal\x2C 'options.signal');\n\n  function abort() {\n    finishImpl(new AbortError());\n  }\n\n  addAbortListener ??= require('events').addAbortListener;\n  let disposable;\n  if (outerSignal) {\n    disposable = addAbortListener(outerSignal\x2C abort);\n  }\n\n  let error;\n  let value;\n  const destroys = [];\n\n  let finishCount = 0;\n\n  function finish(err) {\n    finishImpl(err\x2C --finishCount === 0);\n  }\n\n  function finishImpl(err\x2C final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n\n    if (!error && !final) {\n      return;\n    }\n\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n\n    disposable?.[SymbolDispose]();\n    ac.abort();\n\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn());\n      }\n      process.nextTick(callback\x2C error\x2C value);\n    }\n  }\n\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || opts?.end !== false;\n    const isLastStream = i === streams.length - 1;\n\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy\x2C cleanup } = destroyer(stream\x2C reading\x2C writing);\n        destroys.push(destroy);\n\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (\n          err &&\n          err.name !== 'AbortError' &&\n          err.code !== 'ERR_STREAM_PREMATURE_CLOSE'\n        ) {\n          finish(err);\n        }\n      }\n      stream.on('error'\x2C onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error'\x2C onError);\n        });\n      }\n    }\n\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({ signal });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'Iterable\x2C AsyncIterable or Stream'\x2C 'source'\x2C ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      if (isTransformStream(ret)) {\n        ret = makeAsyncIterable(ret?.readable);\n      } else {\n        ret = makeAsyncIterable(ret);\n      }\n      ret = stream(ret\x2C { signal });\n\n      if (reading) {\n        if (!isIterable(ret\x2C true)) {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'AsyncIterable'\x2C `transform[${i - 1}]`\x2C ret);\n        }\n      } else {\n        if (!PassThrough) {\n          PassThrough = require('internal/streams/passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\x2C\n        });\n\n        // Handle Promises/A+ spec\x2C `then` could be a getter that throws on\n        // second use.\n        const then = ret?.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret\x2C\n                    (val) => {\n                      value = val;\n                      if (val != null) {\n                        pt.write(val);\n                      }\n                      if (end) {\n                        pt.end();\n                      }\n                      process.nextTick(finish);\n                    }\x2C (err) => {\n                      pt.destroy(err);\n                      process.nextTick(finish\x2C err);\n                    }\x2C\n          );\n        } else if (isIterable(ret\x2C true)) {\n          finishCount++;\n          pumpToNode(ret\x2C pt\x2C finish\x2C { end });\n        } else if (isReadableStream(ret) || isTransformStream(ret)) {\n          const toRead = ret.readable || ret;\n          finishCount++;\n          pumpToNode(toRead\x2C pt\x2C finish\x2C { end });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE(\n            'AsyncIterable or Promise'\x2C 'destination'\x2C ret);\n        }\n\n        ret = pt;\n\n        const { destroy\x2C cleanup } = destroyer(ret\x2C false\x2C true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret\x2C stream\x2C finish\x2C { end });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isTransformStream(ret) || isReadableStream(ret)) {\n        const toRead = ret.readable || ret;\n        finishCount++;\n        pumpToNode(toRead\x2C stream\x2C finish\x2C { end });\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pumpToNode(ret\x2C stream\x2C finish\x2C { end });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable'\x2C 'ReadableStream'\x2C 'TransformStream']\x2C ret);\n      }\n      ret = stream;\n    } else if (isWebStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount++;\n        pumpToWeb(makeAsyncIterable(ret)\x2C stream\x2C finish\x2C { end });\n      } else if (isReadableStream(ret) || isIterable(ret)) {\n        finishCount++;\n        pumpToWeb(ret\x2C stream\x2C finish\x2C { end });\n      } else if (isTransformStream(ret)) {\n        finishCount++;\n        pumpToWeb(ret.readable\x2C stream\x2C finish\x2C { end });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'val'\x2C ['Readable'\x2C 'Iterable'\x2C 'AsyncIterable'\x2C 'ReadableStream'\x2C 'TransformStream']\x2C ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n\n  if (signal?.aborted || outerSignal?.aborted) {\n    process.nextTick(abort);\n  }\n\n  return ret;\n}\n\nfunction pipe(src\x2C dst\x2C finish\x2C { end }) {\n  let ended = false;\n  dst.on('close'\x2C () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n\n  src.pipe(dst\x2C { end: false }); // If end is true we already will have a listener to end dst.\n\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but "secretly" don't close the underlying fd.\n\n    function endFn() {\n      ended = true;\n      dst.end();\n    }\n\n    if (isReadableFinished(src)) { // End the destination if the source has already ended.\n      process.nextTick(endFn);\n    } else {\n      src.once('end'\x2C endFn);\n    }\n  } else {\n    finish();\n  }\n\n  eos(src\x2C { readable: true\x2C writable: false }\x2C (err) => {\n    const rState = src._readableState;\n    if (\n      err &&\n      err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n      (rState && rState.ended && !rState.errored && !rState.errorEmitted)\n    ) {\n      // Some readable streams will emit 'close' before 'end'. However\x2C since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src\n        .once('end'\x2C finish)\n        .once('error'\x2C finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst\x2C { readable: false\x2C writable: true }\x2C finish);\n}\n\nmodule.exports = { pipelineImpl\x2C pipeline };\n
code-source-info,0x287bc3ba498,421,0,12326,C0O0C4O12326,,
code-creation,Function,10,74684,0x287bc3baa10,421, node:internal/streams/pipeline:1:1,0x287bc3ba410,~
code-source-info,0x287bc3baa10,421,0,12326,C0O0C153O138C159O154C165O165C171O188C177O233C183O233C187O233C189O293C195O293C200O284C206O339C212O339C216O339C218O391C224O391C228O391C230O627C236O627C241O437C252O472C258O498C264O528C270O550C276O576C282O611C288O711C294O711C299O666C305O686C311O902C317O902C322O754C328O768C334O782C340O806C346O822C352O843C358O858C364O878C370O965C376O965C381O945C387O1008C388O1008C390O1025C391O1025C393O1039C394O1039C396O12281C403O12300C409O12314C415O12296C420O12325,,
tick,0x7f6e64f83003,74730,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,74910,0x287bc3bc1c0,5, node:internal/streams/destroy:1:1,0x287bc3bbf38,~
script-source,422,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\nconst {\n  kIsDestroyed\x2C\n  isDestroyed\x2C\n  isFinished\x2C\n  isServerRequest\x2C\n} = require('internal/streams/utils');\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if (w?.destroyed || r?.destroyed) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    self._destroy(err || null\x2C onDestroy);\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n\n  if (w?.emitClose || r?.emitClose) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w?.errorEmitted || r?.errorEmitted) {\n    return;\n  }\n\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (w?.destroyed || r?.destroyed) {\n    return this;\n  }\n\n  if (r?.autoDestroy || w?.autoDestroy)\n    stream.destroy(err);\n  else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      stream.emit(kConstruct);\n    }\n  }\n\n  try {\n    stream._construct((err) => {\n      process.nextTick(onConstruct\x2C err);\n    });\n  } catch (err) {\n    process.nextTick(onConstruct\x2C err);\n  }\n}\n\nfunction isRequest(stream) {\n  return stream?.setHeader && typeof stream.abort === 'function';\n}\n\nfunction emitCloseLegacy(stream) {\n  stream.emit('close');\n}\n\nfunction emitErrorCloseLegacy(stream\x2C err) {\n  stream.emit('error'\x2C err);\n  process.nextTick(emitCloseLegacy\x2C stream);\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err);\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy\x2C stream\x2C err);\n  } else {\n    process.nextTick(emitCloseLegacy\x2C stream);\n  }\n\n  if (!stream.destroyed) {\n    stream[kIsDestroyed] = true;\n  }\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\x2C\n};\n
code-source-info,0x287bc3bc1c0,422,0,6743,C0O0C4O6743,,
code-creation,Function,10,75134,0x287bc3bc890,245, node:internal/streams/destroy:1:1,0x287bc3bc138,~
code-source-info,0x287bc3bc890,422,0,6743,C0O0C116O106C119O106C124O25C135O60C141O90C147O144C152O245C155O245C160O179C166O195C172O210C178O224C184O298C187O298C191O298C193O337C196O337C200O337C202O6653C209O6674C215O6687C221O6700C227O6711C233O6724C239O6668C244O6742,,
code-creation,Eval,10,75312,0x287bc3bdb18,5, node:internal/streams/duplex:1:1,0x287bc3bd960,~
script-source,423,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  const keys = ObjectKeys(Writable.prototype);\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i];\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this\x2C options);\n  Writable.call(this\x2C options);\n\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  } else {\n    this.allowHalfOpen = true;\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable') }\x2C\n  writableHighWaterMark:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark') }\x2C\n  writableObjectMode:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode') }\x2C\n  writableBuffer:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer') }\x2C\n  writableLength:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength') }\x2C\n  writableFinished:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished') }\x2C\n  writableCorked:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked') }\x2C\n  writableEnded:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded') }\x2C\n  writableNeedDrain:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain') }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\x2C\n  }\x2C\n});\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nDuplex.fromWeb = function(pair\x2C options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\n    pair\x2C\n    options);\n};\n\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0x287bc3bdb18,423,0,4938,C0O0C4O4938,,
code-creation,Function,10,75487,0x287bc3be190,603, node:internal/streams/duplex:1:1,0x287bc3bda90,~
code-source-info,0x287bc3be190,423,0,4938,C0O0C33O1383C38O1409C43O1443C48O1457C53O1497C55O1512C59O1540C65O1540C69O1540C71O1595C77O1595C81O1595C83O1634C86O1662C94O1682C99O1634C104O1694C110O1694C115O1752C118O1772C123O1752C128O1838C130O1850C134O1843C139O1884C141O1888C145O1897C148O1909C155O1918C160O1934C163O1941C171O1970C178O1979C181O1959C185O1859C190O1825C193O2665C196O2695C206O2724C214O2786C223O2746C242O2841C250O2903C259O2863C278O2968C286O3030C295O2990C314O3088C322O3150C331O3110C350O3204C358O3266C367O3226C386O3322C394O3384C403O3344C422O3440C430O3502C439O3462C458O3555C466O3617C475O3577C494O3673C502O3735C511O3695C530O3784C535O3811C543O4029C557O2665C562O4306C563O4306C565O4530C572O4545C576O4668C583O4681C587O4779C588O4779C590O4791C597O4803C602O4937,,
tick,0x1258130,75612,1,0xb795c0,2,0xdd1310,0x65c50a3,0x65c42db,0x287bc3be1d1,0x65c5168,0x65c42db,0x287bc3baaf0,0x65c5168,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
new,MemoryChunk,0x31bb26c0000,262144
code-creation,Eval,10,76213,0x287bc3bff78,5, node:internal/streams/readable:1:1,0x287bc3bf9f0,~
script-source,424,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  SymbolAsyncDispose\x2C\n  SymbolAsyncIterator\x2C\n  Symbol\x2C\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst BufferList = require('internal/streams/buffer_list');\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n} = require('internal/streams/state');\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst kPaused = Symbol('kPaused');\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nconst kObjectMode = 1 << 0;\nconst kEnded = 1 << 1;\nconst kEndEmitted = 1 << 2;\nconst kReading = 1 << 3;\nconst kConstructed = 1 << 4;\nconst kSync = 1 << 5;\nconst kNeedReadable = 1 << 6;\nconst kEmittedReadable = 1 << 7;\nconst kReadableListening = 1 << 8;\nconst kResumeScheduled = 1 << 9;\nconst kErrorEmitted = 1 << 10;\nconst kEmitClose = 1 << 11;\nconst kAutoDestroy = 1 << 12;\nconst kDestroyed = 1 << 13;\nconst kClosed = 1 << 14;\nconst kCloseEmitted = 1 << 15;\nconst kMultiAwaitDrain = 1 << 16;\nconst kReadingMore = 1 << 17;\nconst kDataEmitted = 1 << 18;\n\n// TODO(benjamingr) it is likely slower to do it this way than with free functions\nfunction makeBitMapDescriptor(bit) {\n  return {\n    enumerable: false\x2C\n    get() { return (this.state & bit) !== 0; }\x2C\n    set(value) {\n      if (value) this.state |= bit;\n      else this.state &= ~bit;\n    }\x2C\n  };\n}\nObjectDefineProperties(ReadableState.prototype\x2C {\n  objectMode: makeBitMapDescriptor(kObjectMode)\x2C\n  ended: makeBitMapDescriptor(kEnded)\x2C\n  endEmitted: makeBitMapDescriptor(kEndEmitted)\x2C\n  reading: makeBitMapDescriptor(kReading)\x2C\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  constructed: makeBitMapDescriptor(kConstructed)\x2C\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  sync: makeBitMapDescriptor(kSync)\x2C\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  needReadable: makeBitMapDescriptor(kNeedReadable)\x2C\n  emittedReadable: makeBitMapDescriptor(kEmittedReadable)\x2C\n  readableListening: makeBitMapDescriptor(kReadableListening)\x2C\n  resumeScheduled: makeBitMapDescriptor(kResumeScheduled)\x2C\n  // True if the error was already emitted and should not be thrown again.\n  errorEmitted: makeBitMapDescriptor(kErrorEmitted)\x2C\n  emitClose: makeBitMapDescriptor(kEmitClose)\x2C\n  autoDestroy: makeBitMapDescriptor(kAutoDestroy)\x2C\n  // Has it been destroyed.\n  destroyed: makeBitMapDescriptor(kDestroyed)\x2C\n  // Indicates whether the stream has finished destroying.\n  closed: makeBitMapDescriptor(kClosed)\x2C\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  closeEmitted: makeBitMapDescriptor(kCloseEmitted)\x2C\n  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain)\x2C\n  // If true\x2C a maybeReadMore has been scheduled.\n  readingMore: makeBitMapDescriptor(kReadingMore)\x2C\n  dataEmitted: makeBitMapDescriptor(kDataEmitted)\x2C\n});\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Bit map field to store ReadableState more effciently with 1 bit per field\n  // instead of a V8 slot per field.\n  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  if (options && options.objectMode) this.state |= kObjectMode;\n\n  if (isDuplex && options && options.readableObjectMode)\n    this.state |= kObjectMode;\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n\n  this[kPaused] = null;\n\n  // Should close be emitted on destroy. Defaults to true.\n  if (options && options.emitClose === false) this.state &= ~kEmitClose;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;\n\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor\x2C at least with V8 6.5.\n  const isDuplex = this instanceof Stream.Duplex;\n\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal && !isDuplex)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this\x2C this._readableState);\n    }\n  });\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nReadable.prototype[SymbolAsyncDispose] = function() {\n  let error;\n  if (!this.destroyed) {\n    error = this.readableEnded ? null : new AbortError();\n    this.destroy(error);\n  }\n  return new Promise((resolve\x2C reject) => eos(this\x2C (err) => (err && err !== error ? reject(err) : resolve(null))));\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\n};\n\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\n  debug('readableAddChunk'\x2C chunk);\n  const state = stream._readableState;\n\n  let err;\n  if ((state.state & kObjectMode) === 0) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk\x2C encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  if (err) {\n    errorOrDestroy(stream\x2C err);\n  } else if (chunk === null) {\n    state.state &= ~kReading;\n    onEofChunk(stream\x2C state);\n  } else if (((state.state & kObjectMode) !== 0) || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if ((state.state & kEndEmitted) !== 0)\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else if (state.destroyed || state.errored)\n        return false;\n      else\n        addChunk(stream\x2C state\x2C chunk\x2C true);\n    } else if (state.ended) {\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.state &= ~kReading;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream\x2C state\x2C chunk\x2C false);\n        else\n          maybeReadMore(stream\x2C state);\n      } else {\n        addChunk(stream\x2C state\x2C chunk\x2C false);\n      }\n    }\n  } else if (!addToFront) {\n    state.state &= ~kReading;\n    maybeReadMore(stream\x2C state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return !state.ended &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync &&\n      stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if ((state.state & kMultiAwaitDrain) !== 0) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state.dataEmitted = true;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if ((state.state & kNeedReadable) !== 0)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '')\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if ((state.state & kObjectMode) !== 0)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state.state &= ~kEmittedReadable;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       state.ended)) {\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = (state.state & kNeedReadable) !== 0;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if (state.ended || state.reading || state.destroyed || state.errored ||\n      !state.constructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.state |= kReading | kSync;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state.state |= kNeedReadable;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this\x2C err);\n    }\n    state.state &= ~kSync;\n\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  if (state.sync) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable'\x2C state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state.needReadable =\n    !state.flowing &&\n    !state.ended &&\n    state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended &&\n         (state.length < state.highWaterMark ||\n          (state.flowing && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\x2C\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    pause();\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable'\x2C state.length\x2C state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this\x2C state);\n  }\n  state[kPaused] = false;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow'\x2C state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable'\x2C next);\n\n  let error;\n  const cleanup = eos(stream\x2C { writable: false }\x2C (err) => {\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error\x2C err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream\x2C null);\n    } else {\n      stream.off('readable'\x2C next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    __proto__: null\x2C\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\x2C\n  }\x2C\n\n  readableDidRead: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\x2C\n  }\x2C\n\n  readableAborted: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    }\x2C\n  }\x2C\n\n  readableHighWaterMark: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\x2C\n  }\x2C\n\n  readableBuffer: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\x2C\n  }\x2C\n\n  readableFlowing: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\x2C\n  }\x2C\n\n  readableLength: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\x2C\n  }\x2C\n\n  readableObjectMode: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\x2C\n  }\x2C\n\n  readableEncoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\x2C\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    }\x2C\n  }\x2C\n\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    }\x2C\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\x2C\n  }\x2C\n\n  readableEnded: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\x2C\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null\x2C\n    get() {\n      return this.pipes.length;\n    }\x2C\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null\x2C\n    get() {\n      return this[kPaused] !== false;\n    }\x2C\n    set(value) {\n      this[kPaused] = !!value;\n    }\x2C\n  }\x2C\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n\x2C state.decoder);\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable'\x2C state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted &&\n      !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream\x2C options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream\x2C\n    options);\n};\n\nReadable.toWeb = function(streamReadable\x2C options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(\n    streamReadable\x2C\n    options);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\x2C\n  }).wrap(src);\n};\n
code-source-info,0x287bc3bff78,424,0,43613,C0O0C4O43613,,
code-creation,Function,10,77545,0x31bb26c3bb8,2118, node:internal/streams/readable:1:1,0x287bc3bfef0,~
code-source-info,0x31bb26c3bb8,424,0,43613,C0O0C288O1159C294O1184C300O1203C306O1218C312O1236C317O1262C323O1276C328O1300C334O1311C340O1322C345O1344C350O1367C355O1393C357O1408C361O1420C367O1443C371O1472C379O1472C384O1527C392O1527C398O1499C404O1507C410O1582C418O1582C424O1571C430O1632C438O1632C444O1612C450O1690C458O1690C462O1690C464O1746C472O1746C478O1779C494O1780C500O1746C502O1846C510O1846C514O1846C516O1907C524O1907C528O1907C530O2003C538O2003C544O1954C550O1974C556O2254C564O2254C570O2049C582O2084C588O2110C594O2142C600O2164C606O2195C612O2238C618O2309C626O2309C632O2290C638O2358C642O2358C646O2358C648O2404C656O2404C662O2386C668O2444C676O2444C680O2444C682O2479C686O2509C696O2527C702O2479C707O2539C715O2539C720O2591C724O2591C726O2629C730O2610C736O2663C738O2663C740O2686C743O2714C745O2714C747O2739C749O2739C751O2768C753O2768C755O2790C757O2790C759O2820C761O2820C763O2853C767O2853C769O2888C774O2921C779O2951C784O2979C788O2979C790O3009C794O3009C796O3037C801O3062C806O3093C813O3127C819O3127C821O3157C828O3187C835O3497C839O3534C855O3561C863O3605C875O3649C887O3695C899O3924C911O4237C923O4392C935O4448C943O4509C951O4570C959O4701C971O4751C983O4800C991O4877C999O4980C1007O5119C1019O5175C1027O5280C1035O5331C1043O3497C1048O8879C1052O8888C1062O8920C1066O8906C1070O8929C1074O8938C1084O8973C1088O8959C1092O8984C1096O8993C1106O9012C1110O9049C1114O9058C1120O9071C1130O9095C1134O9138C1138O9147C1144O9157C1148O9177C1152O9638C1156O9647C1166O9662C1170O9817C1174O9826C1184O9844C1188O13105C1192O13114C1202O13133C1206O13278C1210O13287C1220O13309C1224O13921C1230O13921C1232O14879C1236O14888C1246O14903C1250O23979C1254O23988C1264O24004C1268O24075C1272O24084C1282O24099C1286O29197C1290O29206C1300O29223C1304O30028C1308O30037C1318O30050C1322O30961C1326O30970C1336O31003C1342O31013C1346O30992C1350O31018C1354O31027C1364O31052C1368O31621C1372O31630C1382O31655C1388O31665C1392O31644C1396O31682C1400O31691C1410O31720C1414O33045C1418O33054C1428O33071C1432O33806C1436O33815C1446O33831C1450O34408C1454O34417C1464O34432C1468O35458C1472O35467C1478O35477C1482O35498C1486O35555C1490O35564C1500O35583C1504O37193C1508O37225C1520O37250C1526O37277C1534O37672C1548O37829C1554O37884C1568O37975C1574O38030C1588O38271C1597O38326C1619O38418C1628O38473C1650O38582C1659O38637C1671O38708C1693O38843C1702O38893C1724O38977C1733O39027C1755O39143C1764O39193C1786O39297C1795O39347C1817O39449C1826O39476C1848O39581C1857O39631C1869O39724C1891O40038C1900O40088C1922O37193C1932O40189C1936O40226C1951O40290C1960O40317C1982O40415C1991O40442C2003O40499C2025O40189C2035O40598C2041O40617C2049O42725C2057O42739C2065O42817C2066O42817C2068O43041C2076O43058C2084O43197C2092O43212C2100O43351C2108O43365C2117O43612,,
tick,0x7f6e64f82f76,77618,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3be1d1,0x65c5168,0x65c42db,0x287bc3baaf0,0x65c5168,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
tick,0x133fc54,77743,1,0xb795c0,6,0xdd1310,0x65c50a3,0x65c42db,0x287bc3be1d1,0x65c5168,0x65c42db,0x287bc3baaf0,0x65c5168,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,77834,0x31bb26c80d0,5, node:internal/streams/legacy:1:1,0x31bb26c7f58,~
script-source,425,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0x31bb26c80d0,425,0,2934,C0O0C4O2934,,
code-creation,Function,10,77929,0x31bb26c8358,106, node:internal/streams/legacy:1:1,0x31bb26c8048,~
code-source-info,0x31bb26c8358,425,0,2934,C0O0C22O25C28O41C33O92C36O92C40O92C42O189C50O203C55O161C60O215C63O215C68O257C77O272C81O2888C88O2907C94O2915C100O2903C105O2933,,
code-creation,Eval,10,78034,0x31bb26c8b98,5, node:internal/streams/add-abort-signal:1:1,0x31bb26c89a0,~
script-source,426,node:internal/streams/add-abort-signal,'use strict';\n\nconst {\n  SymbolDispose\x2C\n} = primordials;\n\nconst {\n  AbortError\x2C\n  codes\x2C\n} = require('internal/errors');\n\nconst {\n  isNodeStream\x2C\n  isWebStream\x2C\n  kControllerErrorFunction\x2C\n} = require('internal/streams/utils');\n\nconst eos = require('internal/streams/end-of-stream');\nconst { ERR_INVALID_ARG_TYPE } = codes;\nlet addAbortListener;\n\n// This method is inlined here for readable-stream\n// It also does not allow for signal to not exist on the stream\n// https://github.com/nodejs/node/pull/36061#discussion_r533718029\nconst validateAbortSignal = (signal\x2C name) => {\n  if (typeof signal !== 'object' ||\n       !('aborted' in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n};\n\nmodule.exports.addAbortSignal = function addAbortSignal(signal\x2C stream) {\n  validateAbortSignal(signal\x2C 'signal');\n  if (!isNodeStream(stream) && !isWebStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE('stream'\x2C ['ReadableStream'\x2C 'WritableStream'\x2C 'Stream']\x2C stream);\n  }\n  return module.exports.addAbortSignalNoValidate(signal\x2C stream);\n};\n\nmodule.exports.addAbortSignalNoValidate = function(signal\x2C stream) {\n  if (typeof signal !== 'object' || !('aborted' in signal)) {\n    return stream;\n  }\n  const onAbort = isNodeStream(stream) ?\n    () => {\n      stream.destroy(new AbortError(undefined\x2C { cause: signal.reason }));\n    } :\n    () => {\n      stream[kControllerErrorFunction](new AbortError(undefined\x2C { cause: signal.reason }));\n    };\n  if (signal.aborted) {\n    onAbort();\n  } else {\n    addAbortListener ??= require('events').addAbortListener;\n    const disposable = addAbortListener(signal\x2C onAbort);\n    eos(stream\x2C disposable[SymbolDispose]);\n  }\n  return stream;\n};\n
code-source-info,0x31bb26c8b98,426,0,1704,C0O0C4O1704,,
code-creation,Function,10,78094,0x31bb26c8e08,158, node:internal/streams/add-abort-signal:1:1,0x31bb26c8b10,~
code-source-info,0x31bb26c8e08,426,0,1704,C0O0C40O25C46O93C52O93C57O68C63O82C68O193C74O193C79O132C85O148C91O163C97O241C103O241C107O241C109O292C115O328C116O328C118O557C122O557C124O719C127O726C136O749C140O1065C143O1072C152O1105C157O1703,,
code-creation,Eval,10,78266,0x31bb26c9590,5, node:internal/streams/buffer_list:1:1,0x31bb26c93f8,~
script-source,427,node:internal/streams/buffer_list,'use strict';\n\nconst {\n  StringPrototypeSlice\x2C\n  SymbolIterator\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { inspect } = require('internal/util/inspect');\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v\x2C next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v\x2C next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while ((p = p.next) !== null)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n\x2C hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0\x2C n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n\n  first() {\n    return this.head.data;\n  }\n\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str\x2C n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\n                                 retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\x2C\n    });\n  }\n};\n
code-source-info,0x31bb26c9590,427,0,4060,C0O0C4O4060,,
code-creation,Function,10,78388,0x31bb26ca078,176, node:internal/streams/buffer_list:1:1,0x31bb26c9508,~
code-source-info,0x31bb26ca078,427,0,4060,C0O0C20O25C26O49C31O67C37O93C43O142C46O142C51O131C57O181C60O181C65O169C71O216C120O2055C143O3869C147O3869C170O231C175O4059,,
code-creation,Eval,10,78492,0x31bb26cac80,5, node:internal/streams/state:1:1,0x31bb26caab8,~
script-source,428,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\nconst { validateInteger } = require('internal/validators');\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nlet defaultHighWaterMarkBytes = 16 * 1024;\nlet defaultHighWaterMarkObjectMode = 16;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;\n}\n\nfunction setDefaultHighWaterMark(objectMode\x2C value) {\n  validateInteger(value\x2C 'value'\x2C 0);\n  if (objectMode) {\n    defaultHighWaterMarkObjectMode = value;\n  } else {\n    defaultHighWaterMarkBytes = value;\n  }\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n  setDefaultHighWaterMark\x2C\n};\n
code-source-info,0x31bb26cac80,428,0,1332,C0O0C4O1332,,
code-creation,Function,10,78538,0x31bb26caf08,131, node:internal/streams/state:1:1,0x31bb26cabf8,~
code-source-info,0x31bb26caf08,428,0,1332,C0O0C45O25C51O38C57O100C60O100C65O80C71O167C74O167C79O193C84O141C90O234C94O234C96O282C98O282C100O1236C107O1257C113O1277C119O1304C125O1251C130O1331,,
code-creation,Eval,10,78646,0x31bb26cb550,5, node:internal/streams/from:1:1,0x31bb26cb398,~
script-source,429,node:internal/streams/from,'use strict';\n\nconst {\n  PromisePrototypeThen\x2C\n  SymbolAsyncIterator\x2C\n  SymbolIterator\x2C\n} = primordials;\nconst { Buffer } = require('buffer');\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n} = require('internal/errors').codes;\n\nfunction from(Readable\x2C iterable\x2C opts) {\n  let iterator;\n  if (typeof iterable === 'string' || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true\x2C\n      ...opts\x2C\n      read() {\n        this.push(iterable);\n        this.push(null);\n      }\x2C\n    });\n  }\n\n  let isAsync;\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true;\n    iterator = iterable[SymbolAsyncIterator]();\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false;\n    iterator = iterable[SymbolIterator]();\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('iterable'\x2C ['Iterable']\x2C iterable);\n  }\n\n  const readable = new Readable({\n    objectMode: true\x2C\n    highWaterMark: 1\x2C\n    // TODO(ronag): What options should be allowed?\n    ...opts\x2C\n  });\n\n  // Flag to protect against _read\n  // being called before last iteration completion.\n  let reading = false;\n\n  readable._read = function() {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n\n  readable._destroy = function(error\x2C cb) {\n    PromisePrototypeThen(\n      close(error)\x2C\n      () => process.nextTick(cb\x2C error)\x2C // nextTick is here in case cb throws\n      (e) => process.nextTick(cb\x2C e || error)\x2C\n    );\n  };\n\n  async function close(error) {\n    const hadError = (error !== undefined) && (error !== null);\n    const hasThrow = typeof iterator.throw === 'function';\n    if (hadError && hasThrow) {\n      const { value\x2C done } = await iterator.throw(error);\n      await value;\n      if (done) {\n        return;\n      }\n    }\n    if (typeof iterator.return === 'function') {\n      const { value } = await iterator.return();\n      await value;\n    }\n  }\n\n  async function next() {\n    for (;;) {\n      try {\n        const { value\x2C done } = isAsync ?\n          await iterator.next() :\n          iterator.next();\n\n        if (done) {\n          readable.push(null);\n        } else {\n          const res = (value &&\n            typeof value.then === 'function') ?\n            await value :\n            value;\n          if (res === null) {\n            reading = false;\n            throw new ERR_STREAM_NULL_VALUES();\n          } else if (readable.push(res)) {\n            continue;\n          } else {\n            reading = false;\n          }\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n      break;\n    }\n  }\n  return readable;\n}\n\nmodule.exports = from;\n
code-source-info,0x31bb26cb550,429,0,2614,C0O0C4O2614,,
code-creation,Function,10,78730,0x31bb26cb6b8,97, node:internal/streams/from:1:1,0x31bb26cb4c8,~
code-source-info,0x31bb26cb6b8,429,0,2614,C0O0C32O25C38O49C44O72C50O124C53O124C58O113C64O206C67O206C72O232C77O154C83O178C89O2591C91O2606C96O2613,,
tick,0x11eb935,78814,0,0x0,2,0x12da7b0,0x31bb26c3f0f,0x65c5168,0x65c42db,0x287bc3be1d1,0x65c5168,0x65c42db,0x287bc3baaf0,0x65c5168,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,78875,0x31bb26cbd68,33,makeBitMapDescriptor node:internal/streams/readable:106:30,0x287bc3bffa8,~
code-source-info,0x31bb26cbd68,424,3309,3496,C0O3309C9O3319C14O3355C22O3403C32O3494,,
code-creation,Eval,10,79319,0x31bb26d0020,5, node:internal/streams/writable:1:1,0x31bb26cfc18,~
script-source,430,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\x2C\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\x2C\n} = require('internal/errors').codes;\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinished = Symbol('kOnFinished');\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream\x2C\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.writableObjectMode);\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // if _final has been called.\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // At the start of calling end()\n  this.ending = false;\n  // When end() has been called\x2C and returned.\n  this.ended = false;\n  // When 'finish' is emitted.\n  this.finished = false;\n\n  // Has it been destroyed\n  this.destroyed = false;\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  this.writecb = null;\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  this[kOnFinished] = [];\n}\n\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  __proto__: null\x2C\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\x2C\n});\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes\x2C too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false\x2C as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor\x2C at least with V8 6.5.\n  const isDuplex = (this instanceof Stream.Duplex);\n\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    const state = this._writableState;\n\n    if (!state.writing) {\n      clearBuffer(this\x2C state);\n    }\n\n    finishMaybe(this\x2C state);\n  });\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== 'function')\n      cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark;\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state.sync = false;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null &&\n          state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\n    state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n\n  finishMaybe(stream\x2C state);\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk\x2C callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n  }\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));\n  }\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if (state.corked ||\n      state.bufferProcessing ||\n      state.destroyed ||\n      !state.constructed) {\n    return;\n  }\n\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = state.allBuffers;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && !state.writing);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true;\n    finishMaybe(this\x2C state\x2C true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb\x2C err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (state.ending &&\n          !state.destroyed &&\n          state.constructed &&\n          state.length === 0 &&\n          !state.errored &&\n          state.buffered.length === 0 &&\n          !state.finished &&\n          !state.writing &&\n          !state.errorEmitted &&\n          !state.closeEmitted);\n}\n\nfunction callFinal(stream\x2C state) {\n  let called = false;\n\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream\x2C err\x2C state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++;\n      process.nextTick(finish\x2C stream\x2C state);\n    }\n  }\n\n  state.sync = true;\n  state.pendingcb++;\n\n  try {\n    stream._final(onFinish);\n  } catch (err) {\n    onFinish(err);\n  }\n\n  state.sync = false;\n}\n\nfunction prefinish(stream\x2C state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream\x2C state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++;\n        process.nextTick((stream\x2C state) => {\n          if (needFinish(state)) {\n            finish(stream\x2C state);\n          } else {\n            state.pendingcb--;\n          }\n        }\x2C stream\x2C state);\n      } else if (needFinish(state)) {\n        state.pendingcb++;\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state.finished = true;\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n\n  stream.emit('finish');\n\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.closed : false;\n    }\x2C\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\x2C\n  }\x2C\n\n  writable: {\n    __proto__: null\x2C\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\n        !w.ending && !w.ended;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\x2C\n  }\x2C\n\n  writableFinished: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\x2C\n  }\x2C\n\n  writableObjectMode: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\x2C\n  }\x2C\n\n  writableBuffer: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\x2C\n  }\x2C\n\n  writableEnded: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\x2C\n  }\x2C\n\n  writableNeedDrain: {\n    __proto__: null\x2C\n    get() {\n      const wState = this._writableState;\n      if (!wState) return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\x2C\n  }\x2C\n\n  writableHighWaterMark: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\x2C\n  }\x2C\n\n  writableCorked: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\x2C\n  }\x2C\n\n  writableLength: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.length;\n    }\x2C\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._writableState ? this._writableState.errored : null;\n    }\x2C\n  }\x2C\n\n  writableAborted: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      );\n    }\x2C\n  }\x2C\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if (!state.destroyed &&\n    (state.bufferedIndex < state.buffered.length ||\n      state[kOnFinished].length)) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream\x2C options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream\x2C\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n
code-source-info,0x31bb26d0020,430,0,26009,C0O0C4O26009,,
code-creation,Function,10,80078,0x31bb26d1af0,1060, node:internal/streams/writable:1:1,0x31bb26cff98,~
code-source-info,0x31bb26d1af0,430,0,26009,C0O0C196O1316C202O1339C208O1348C214O1386C219O1410C224O1436C229O1460C235O1490C240O1500C245O1537C247O1552C251O1564C256O1587C260O1616C266O1616C271O1650C277O1650C282O1684C286O1650C288O1712C294O1712C299O1701C305O1751C311O1751C315O1751C317O1819C323O1819C328O1799C334O1925C340O1925C345O1876C351O1896C357O2212C363O2212C368O2238C373O1970C379O1994C385O2024C391O2049C397O2075C403O2099C409O2130C415O2156C421O2186C427O2274C430O2255C436O2288C439O2318C447O2336C452O2288C457O2348C463O2348C468O2428C471O2428C475O2428C477O7111C480O7125C489O7145C493O7239C496O7274C509O7332C517O7239C522O8934C525O8965C530O9014C541O8934C546O9293C549O9302C558O9317C562O10736C565O10745C574O10761C578O10852C581O10861C590O10876C594O10927C597O10936C606O10953C610O11113C613O11122C622O11151C626O17798C629O17807C638O17824C642O17998C645O18007C651O18025C655O18034C658O18043C667O18057C671O22224C674O22256C684O22280C689O22307C703O22412C708O22439C716O22532C730O22734C735O22761C743O23159C757O23321C762O23348C776O23464C781O23491C795O23605C800O23632C814O23739C819O23766C833O23879C838O23906C852O24097C857O24124C871O24234C876O24261C890O24367C895O24394C909O24490C914O24540C928O24651C933O24706C947O22224C952O24940C955O24952C959O24940C961O24961C964O24970C973O24988C977O25290C980O25299C988O25334C992O25320C996O25345C999O25354C1008O25373C1012O25410C1015O25419C1020O25432C1029O25456C1033O25503C1034O25503C1036O25727C1043O25744C1047O25883C1054O25898C1059O26008,,
tick,0x7f6e64f83003,80138,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3be1dd,0x65c5168,0x65c42db,0x287bc3baaf0,0x65c5168,0x65c42db,0x287bc3b9342,0x65c5168,0x65c42db,0x287bc3b1fd8,0x65c5168,0x65c42db,0x287bc3aff5d,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,80394,0x31bb26d52b0,5, node:stream/promises:1:1,0x31bb26d5108,~
script-source,431,node:stream/promises,'use strict';\n\nconst {\n  ArrayPrototypePop\x2C\n  Promise\x2C\n} = primordials;\n\nconst {\n  isIterable\x2C\n  isNodeStream\x2C\n  isWebStream\x2C\n} = require('internal/streams/utils');\n\nconst { pipelineImpl: pl } = require('internal/streams/pipeline');\nconst { finished } = require('internal/streams/end-of-stream');\n\nrequire('stream');\n\nfunction pipeline(...streams) {\n  return new Promise((resolve\x2C reject) => {\n    let signal;\n    let end;\n    const lastArg = streams[streams.length - 1];\n    if (lastArg && typeof lastArg === 'object' &&\n        !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {\n      const options = ArrayPrototypePop(streams);\n      signal = options.signal;\n      end = options.end;\n    }\n\n    pl(streams\x2C (err\x2C value) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(value);\n      }\n    }\x2C { signal\x2C end });\n  });\n}\n\nmodule.exports = {\n  finished\x2C\n  pipeline\x2C\n};\n
code-source-info,0x31bb26d52b0,431,0,917,C0O0C4O917,,
code-creation,Function,10,80433,0x31bb26d5430,125, node:stream/promises:1:1,0x31bb26d5228,~
code-source-info,0x31bb26d5430,431,0,917,C0O0C28O25C34O46C40O130C43O130C48O83C54O97C60O113C66O195C69O195C74O188C80O254C83O254C88O241C93O298C96O298C100O871C107O892C113O904C119O886C124O916,,
code-creation,Eval,10,80618,0x31bb26d5c30,5, node:internal/streams/transform:1:1,0x31bb26d5a78,~
script-source,432,node:internal/streams/transform,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a "filter"\x2C\n// but that's not a great name for it\x2C since that implies a thing where\n// some bits pass through\x2C and others are simply ignored.  (That would\n// be a valid example of a transform\x2C of course.)\n//\n// While the output is causally related to the input\x2C it's not a\n// necessarily symmetric or synchronous transformation.  For example\x2C\n// a zlib stream might take multiple plain-text writes()\x2C and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk)\x2C that calls _write(chunk\x2Ccb)\n// internally\x2C and returns false if there's a lot of pending writes\n// buffered up.  When you call read()\x2C that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream\x2C the written data is placed in a buffer.  When\n// _read(n) is called\x2C it transforms the queued up data\x2C calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks\x2C then the first\n// outputted bit calls the readcb\x2C and subsequent chunks just go into\n// the read buffer\x2C and will cause it to emit 'readable' if necessary.\n//\n// This way\x2C back-pressure is actually determined by the reading side\x2C\n// since _read has to be called to start processing a new chunk.  However\x2C\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example\x2C imagine a stream where every byte of input is\n// interpreted as an integer from 0-255\x2C and then results in that many\n// bytes of output.  Writing the 4 bytes {ff\x2Cff\x2Cff\x2Cff} would result in\n// 1kb of data being output.  In this case\x2C you could write a very small\n// amount of input\x2C and end up with a very large amount of output.  In\n// such a pathological inflating mechanism\x2C there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However\x2C even in such a pathological case\x2C only a single written chunk\n// would be consumed\x2C and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nmodule.exports = Transform;\nconst {\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n} = require('internal/errors').codes;\nconst Duplex = require('internal/streams/duplex');\nconst { getHighWaterMark } = require('internal/streams/state');\nObjectSetPrototypeOf(Transform.prototype\x2C Duplex.prototype);\nObjectSetPrototypeOf(Transform\x2C Duplex);\n\nconst kCallback = Symbol('kCallback');\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  // TODO (ronag): This should preferably always be\n  // applied but would be semver-major. Or even better;\n  // make Transform a Readable with the Writable interface.\n  const readableHighWaterMark = options ? getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C true) : null;\n  if (readableHighWaterMark === 0) {\n    // A Duplex will buffer both on the writable and readable side while\n    // a Transform just wants to buffer hwm number of elements. To avoid\n    // buffering twice we disable buffering on the writable side.\n    options = {\n      ...options\x2C\n      highWaterMark: null\x2C\n      readableHighWaterMark\x2C\n      // TODO (ronag): 0 is not optimal since we have\n      // a "bug" where we check needDrain before calling _write and not after.\n      // Refs: https://github.com/nodejs/node/pull/32887\n      // Refs: https://github.com/nodejs/node/pull/35941\n      writableHighWaterMark: options.writableHighWaterMark || 0\x2C\n    };\n  }\n\n  Duplex.call(this\x2C options);\n\n  // We have implemented the _read method\x2C and done the other things\n  // that Readable wants before the first _read call\x2C so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this[kCallback] = null;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes\x2C then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish'\x2C prefinish);\n}\n\nfunction final(cb) {\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    this._flush((er\x2C data) => {\n      if (er) {\n        if (cb) {\n          cb(er);\n        } else {\n          this.destroy(er);\n        }\n        return;\n      }\n\n      if (data != null) {\n        this.push(data);\n      }\n      this.push(null);\n      if (cb) {\n        cb();\n      }\n    });\n  } else {\n    this.push(null);\n    if (cb) {\n      cb();\n    }\n  }\n}\n\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this);\n  }\n}\n\nTransform.prototype._final = final;\n\nTransform.prototype._transform = function(chunk\x2C encoding\x2C callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()');\n};\n\nTransform.prototype._write = function(chunk\x2C encoding\x2C callback) {\n  const rState = this._readableState;\n  const wState = this._writableState;\n  const length = rState.length;\n\n  this._transform(chunk\x2C encoding\x2C (err\x2C val) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (val != null) {\n      this.push(val);\n    }\n\n    if (\n      wState.ended || // Backwards compat.\n      length === rState.length || // Backwards compat.\n      rState.length < rState.highWaterMark\n    ) {\n      callback();\n    } else {\n      this[kCallback] = callback;\n    }\n  });\n};\n\nTransform.prototype._read = function() {\n  if (this[kCallback]) {\n    const callback = this[kCallback];\n    this[kCallback] = null;\n    callback();\n  }\n};\n
code-source-info,0x31bb26d5c30,432,0,7176,C0O0C4O7176,,
code-creation,Function,10,80821,0x31bb26d5fe8,198, node:internal/streams/transform:1:1,0x31bb26d5ba8,~
code-source-info,0x31bb26d5fe8,432,0,7176,C0O0C35O3508C40O3532C45O3558C47O3573C51O3628C54O3628C59O3654C64O3596C70O3677C73O3677C77O3677C79O3742C82O3742C87O3721C93O3777C96O3808C104O3826C109O3777C114O3838C120O3838C125O3898C128O3898C132O3898C134O6278C137O6288C144O6305C148O6315C151O6325C160O6346C164O6446C167O6456C176O6473C180O7021C183O7031C192O7047C197O7175,,
code-creation,Eval,10,80907,0x31bb26d6bc8,5, node:internal/streams/passthrough:1:1,0x31bb26d6a60,~
script-source,433,node:internal/streams/passthrough,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = PassThrough;\n\nconst Transform = require('internal/streams/transform');\nObjectSetPrototypeOf(PassThrough.prototype\x2C Transform.prototype);\nObjectSetPrototypeOf(PassThrough\x2C Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this\x2C options);\n}\n\nPassThrough.prototype._transform = function(chunk\x2C encoding\x2C cb) {\n  cb(null\x2C chunk);\n};\n
code-source-info,0x31bb26d6bc8,433,0,1762,C0O0C4O1762,,
code-creation,Function,10,81024,0x31bb26d6d60,84, node:internal/streams/passthrough:1:1,0x31bb26d6b40,~
code-source-info,0x31bb26d6d60,433,0,1762,C0O0C14O1288C19O1328C21O1343C25O1377C28O1377C32O1377C34O1416C37O1449C45O1470C50O1416C55O1482C61O1482C66O1673C69O1685C78O1706C83O1761,,
tick,0x7f6e64f82f76,81065,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3b028c,0x65c5168,0x65c42db,0x287bc3a8aa5,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,81365,0x31bb26da4c8,5, node:internal/stream_base_commons:1:1,0x31bb26da190,~
script-source,434,node:internal/stream_base_commons,'use strict';\n\nconst {\n  Array\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { FastBuffer } = require('internal/buffer');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kBytesWritten\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\x2C\n} = internalBinding('stream_wrap');\nconst { UV_EOF } = internalBinding('uv');\nconst {\n  errnoException\x2C\n} = require('internal/errors');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst {\n  kTimeout\x2C\n  setUnrefTimeout\x2C\n  getTimerDuration\x2C\n} = require('internal/timers');\nconst { isUint8Array } = require('internal/util/types');\nconst { clearTimeout } = require('timers');\nconst { validateFunction } = require('internal/validators');\n\nconst kMaybeDestroy = Symbol('kMaybeDestroy');\nconst kUpdateTimer = Symbol('kUpdateTimer');\nconst kAfterAsyncWrite = Symbol('kAfterAsyncWrite');\nconst kHandle = Symbol('kHandle');\nconst kSession = Symbol('kSession');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst kBuffer = Symbol('kBuffer');\nconst kBufferGen = Symbol('kBufferGen');\nconst kBufferCb = Symbol('kBufferCb');\n\nfunction handleWriteReq(req\x2C data\x2C encoding) {\n  const { handle } = req;\n\n  switch (encoding) {\n    case 'buffer':\n    {\n      const ret = handle.writeBuffer(req\x2C data);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = data;\n      return ret;\n    }\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req\x2C data);\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req\x2C data);\n    case 'ascii':\n      return handle.writeAsciiString(req\x2C data);\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req\x2C data);\n    default:\n    {\n      const buffer = Buffer.from(data\x2C encoding);\n      const ret = handle.writeBuffer(req\x2C buffer);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = buffer;\n      return ret;\n    }\n  }\n}\n\nfunction onWriteComplete(status) {\n  debug('onWriteComplete'\x2C status\x2C this.error);\n\n  const stream = this.handle[owner_symbol];\n\n  if (stream.destroyed) {\n    if (typeof this.callback === 'function')\n      this.callback(null);\n    return;\n  }\n\n  // TODO (ronag): This should be moved before if(stream.destroyed)\n  // in order to avoid swallowing error.\n  if (status < 0) {\n    const ex = errnoException(status\x2C 'write'\x2C this.error);\n    if (typeof this.callback === 'function')\n      this.callback(ex);\n    else\n      stream.destroy(ex);\n    return;\n  }\n\n  stream[kUpdateTimer]();\n  stream[kAfterAsyncWrite](this);\n\n  if (typeof this.callback === 'function')\n    this.callback(null);\n}\n\nfunction createWriteWrap(handle\x2C callback) {\n  const req = new WriteWrap();\n\n  req.handle = handle;\n  req.oncomplete = onWriteComplete;\n  req.async = false;\n  req.bytes = 0;\n  req.buffer = null;\n  req.callback = callback;\n\n  return req;\n}\n\nfunction writevGeneric(self\x2C data\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const allBuffers = data.allBuffers;\n  let chunks;\n  if (allBuffers) {\n    chunks = data;\n    for (let i = 0; i < data.length; i++)\n      data[i] = data[i].chunk;\n  } else {\n    chunks = new Array(data.length << 1);\n    for (let i = 0; i < data.length; i++) {\n      const entry = data[i];\n      chunks[i * 2] = entry.chunk;\n      chunks[i * 2 + 1] = entry.encoding;\n    }\n  }\n  const err = req.handle.writev(req\x2C chunks\x2C allBuffers);\n\n  // Retain chunks\n  if (err === 0) req._chunks = chunks;\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction writeGeneric(self\x2C data\x2C encoding\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const err = handleWriteReq(req\x2C data\x2C encoding);\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction afterWriteDispatched(req\x2C err\x2C cb) {\n  req.bytes = streamBaseState[kBytesWritten];\n  req.async = !!streamBaseState[kLastWriteWasAsync];\n\n  if (err !== 0)\n    return cb(errnoException(err\x2C 'write'\x2C req.error));\n\n  if (!req.async && typeof req.callback === 'function') {\n    req.callback();\n  }\n}\n\nfunction onStreamRead(arrayBuffer) {\n  const nread = streamBaseState[kReadBytesOrError];\n\n  const handle = this;\n  const stream = this[owner_symbol];\n\n  stream[kUpdateTimer]();\n\n  if (nread > 0 && !stream.destroyed) {\n    let ret;\n    let result;\n    const userBuf = stream[kBuffer];\n    if (userBuf) {\n      result = (stream[kBufferCb](nread\x2C userBuf) !== false);\n      const bufGen = stream[kBufferGen];\n      if (bufGen !== null) {\n        const nextBuf = bufGen();\n        if (isUint8Array(nextBuf))\n          stream[kBuffer] = ret = nextBuf;\n      }\n    } else {\n      const offset = streamBaseState[kArrayBufferOffset];\n      const buf = new FastBuffer(arrayBuffer\x2C offset\x2C nread);\n      result = stream.push(buf);\n    }\n    if (!result) {\n      handle.reading = false;\n      if (!stream.destroyed) {\n        const err = handle.readStop();\n        if (err)\n          stream.destroy(errnoException(err\x2C 'read'));\n      }\n    }\n\n    return ret;\n  }\n\n  if (nread === 0) {\n    return;\n  }\n\n  // After seeing EOF\x2C most streams will be closed permanently\x2C\n  // and will not deliver any more read events after this point.\n  // (equivalently\x2C it should have called readStop on itself already).\n  // Some streams may be reset and explicitly started again with a call\n  // to readStart\x2C such as TTY.\n\n  if (nread !== UV_EOF) {\n    // CallJSOnreadMethod expects the return value to be a buffer.\n    // Ref: https://github.com/nodejs/node/pull/34375\n    stream.destroy(errnoException(nread\x2C 'read'));\n    return;\n  }\n\n  // Defer this until we actually emit end\n  if (stream._readableState.endEmitted) {\n    if (stream[kMaybeDestroy])\n      stream[kMaybeDestroy]();\n  } else {\n    if (stream[kMaybeDestroy])\n      stream.on('end'\x2C stream[kMaybeDestroy]);\n\n    // Push a null to signal the end of data.\n    // Do it before `maybeDestroy` for correct order of events:\n    // `end` -> `close`\n    stream.push(null);\n    stream.read(0);\n  }\n}\n\nfunction setStreamTimeout(msecs\x2C callback) {\n  if (this.destroyed)\n    return this;\n\n  this.timeout = msecs;\n\n  // Type checking identical to timers.enroll()\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n\n  // Attempt to clear an existing timer in both cases -\n  //  even if it will be rescheduled we don't want to leak an existing timer.\n  clearTimeout(this[kTimeout]);\n\n  if (msecs === 0) {\n    if (callback !== undefined) {\n      validateFunction(callback\x2C 'callback');\n      this.removeListener('timeout'\x2C callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this)\x2C msecs);\n    if (this[kSession]) this[kSession][kUpdateTimer]();\n\n    if (callback !== undefined) {\n      validateFunction(callback\x2C 'callback');\n      this.once('timeout'\x2C callback);\n    }\n  }\n  return this;\n}\n\nmodule.exports = {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kMaybeDestroy\x2C\n  kUpdateTimer\x2C\n  kHandle\x2C\n  kSession\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\x2C\n};\n
code-source-info,0x31bb26da4c8,434,0,7041,C0O0C4O7041,,
code-creation,Function,10,81570,0x31bb26daab0,514, node:internal/stream_base_commons:1:1,0x31bb26da440,~
code-source-info,0x31bb26daab0,434,0,7041,C0O0C130O25C136O34C141O79C144O79C149O68C155O121C158O121C163O106C169O275C172O275C177O159C183O172C189O193C195O215C201O232C207O254C213O326C216O326C221O315C227O379C230O379C235O359C241O432C244O432C249O463C254O415C260O536C263O536C268O483C274O495C280O514C286O589C289O589C294O572C300O646C303O646C308O629C314O694C317O694C322O673C328O749C331O749C335O749C337O795C340O795C344O795C346O844C349O844C353O844C355O888C358O888C362O888C364O924C367O924C371O924C373O957C376O957C381O990C394O991C400O957C402O1054C405O1054C409O1054C411O1092C414O1092C418O1092C420O1132C423O1132C427O1132C429O6836C436O6857C442O6874C448O6890C454O6906C460O6926C466O6943C472O6959C478O6970C484O6982C490O7002C496O7013C502O7026C508O6851C513O7040,,
code-creation,Eval,10,81690,0x31bb26dbca0,5, node:internal/dtrace:1:1,0x31bb26dbb58,~
script-source,435,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\x2C\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\x2C\n};\n
code-source-info,0x31bb26dbca0,435,0,570,C0O0C4O570,,
code-creation,Function,10,81718,0x31bb26dc178,140, node:internal/dtrace:1:1,0x31bb26dbc18,~
code-source-info,0x31bb26dc178,435,0,570,C0O30C3O30C8O323C17O335C25O68C36O109C47O151C58O192C69O234C80O277C91O369C98O390C104O420C110O451C116O481C122O512C128O544C134O384C139O569,,
tick,0x103edc0,82013,1,0xb795c0,3,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a8db6,0x65c5168,0x65c42db,0x287bc3a169c,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,82077,0x31bb26dd7e8,5, node:internal/perf/observe:1:1,0x31bb26dd120,~
script-source,436,node:internal/perf/observe,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  ObjectDefineProperties\x2C\n  ObjectFreeze\x2C\n  ObjectKeys\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  constants: {\n    NODE_PERFORMANCE_ENTRY_TYPE_GC\x2C\n    NODE_PERFORMANCE_ENTRY_TYPE_HTTP2\x2C\n    NODE_PERFORMANCE_ENTRY_TYPE_HTTP\x2C\n    NODE_PERFORMANCE_ENTRY_TYPE_NET\x2C\n    NODE_PERFORMANCE_ENTRY_TYPE_DNS\x2C\n  }\x2C\n  installGarbageCollectionTracking\x2C\n  observerCounts\x2C\n  removeGarbageCollectionTracking\x2C\n  setupObservers\x2C\n} = internalBinding('performance');\n\nconst {\n  InternalPerformanceEntry\x2C\n  isPerformanceEntry\x2C\n} = require('internal/perf/performance_entry');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateFunction\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n  deprecate\x2C\n  lazyDOMException\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\n\nconst {\n  setImmediate\x2C\n} = require('timers');\n\nconst { inspect } = require('util');\n\nconst { now } = require('internal/perf/utils');\nconst { convertToInt } = require('internal/webidl');\n\nconst kDispatch = Symbol('kDispatch');\nconst kMaybeBuffer = Symbol('kMaybeBuffer');\nconst kDeprecatedFields = Symbol('kDeprecatedFields');\n\nconst kDeprecationMessage =\n  'Custom PerformanceEntry accessors are deprecated. ' +\n  'Please use the detail property.';\n\nconst kTypeSingle = 0;\nconst kTypeMultiple = 1;\n\nlet gcTrackingInstalled = false;\n\nconst kSupportedEntryTypes = ObjectFreeze([\n  'dns'\x2C\n  'function'\x2C\n  'gc'\x2C\n  'http'\x2C\n  'http2'\x2C\n  'mark'\x2C\n  'measure'\x2C\n  'net'\x2C\n  'resource'\x2C\n]);\n\n// Performance timeline entry Buffers\nlet markEntryBuffer = [];\nlet measureEntryBuffer = [];\nlet resourceTimingBuffer = [];\nlet resourceTimingSecondaryBuffer = [];\nconst kPerformanceEntryBufferWarnSize = 1e6;\n// https://www.w3.org/TR/timing-entrytypes-registry/#registry\n// Default buffer limit for resource timing entries.\nlet resourceTimingBufferSizeLimit = 250;\nlet dispatchBufferFull;\nlet resourceTimingBufferFullPending = false;\n\nconst kClearPerformanceEntryBuffers = ObjectFreeze({\n  'mark': 'performance.clearMarks'\x2C\n  'measure': 'performance.clearMeasures'\x2C\n});\nconst kWarnedEntryTypes = new SafeMap();\n\nconst kObservers = new SafeSet();\nconst kPending = new SafeSet();\nlet isPending = false;\n\nfunction queuePending() {\n  if (isPending) return;\n  isPending = true;\n  setImmediate(() => {\n    isPending = false;\n    const pendings = ArrayFrom(kPending.values());\n    kPending.clear();\n    for (const pending of pendings)\n      pending[kDispatch]();\n  });\n}\n\nfunction getObserverType(type) {\n  switch (type) {\n    case 'gc': return NODE_PERFORMANCE_ENTRY_TYPE_GC;\n    case 'http2': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP2;\n    case 'http': return NODE_PERFORMANCE_ENTRY_TYPE_HTTP;\n    case 'net': return NODE_PERFORMANCE_ENTRY_TYPE_NET;\n    case 'dns': return NODE_PERFORMANCE_ENTRY_TYPE_DNS;\n  }\n}\n\nfunction maybeDecrementObserverCounts(entryTypes) {\n  for (const type of entryTypes) {\n    const observerType = getObserverType(type);\n\n    if (observerType !== undefined) {\n      observerCounts[observerType]--;\n\n      if (observerType === NODE_PERFORMANCE_ENTRY_TYPE_GC &&\n          observerCounts[observerType] === 0) {\n        removeGarbageCollectionTracking();\n        gcTrackingInstalled = false;\n      }\n    }\n  }\n}\n\nfunction maybeIncrementObserverCount(type) {\n  const observerType = getObserverType(type);\n\n  if (observerType !== undefined) {\n    observerCounts[observerType]++;\n    if (!gcTrackingInstalled &&\n        observerType === NODE_PERFORMANCE_ENTRY_TYPE_GC) {\n      installGarbageCollectionTracking();\n      gcTrackingInstalled = true;\n    }\n  }\n}\n\nclass PerformanceObserverEntryList {\n  #buffer = [];\n\n  constructor(entries) {\n    this.#buffer = ArrayPrototypeSort(entries\x2C (first\x2C second) => {\n      return first.startTime - second.startTime;\n    });\n  }\n\n  getEntries() {\n    return ArrayPrototypeSlice(this.#buffer);\n  }\n\n  getEntriesByType(type) {\n    type = `${type}`;\n    return ArrayPrototypeFilter(\n      this.#buffer\x2C\n      (entry) => entry.entryType === type);\n  }\n\n  getEntriesByName(name\x2C type) {\n    name = `${name}`;\n    if (type != null /** not nullish */) {\n      return ArrayPrototypeFilter(\n        this.#buffer\x2C\n        (entry) => entry.name === name && entry.entryType === type);\n    }\n    return ArrayPrototypeFilter(\n      this.#buffer\x2C\n      (entry) => entry.name === name);\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `PerformanceObserverEntryList ${inspect(this.#buffer\x2C opts)}`;\n  }\n}\n\nclass PerformanceObserver {\n  #buffer = [];\n  #entryTypes = new SafeSet();\n  #type;\n  #callback;\n\n  constructor(callback) {\n    validateFunction(callback\x2C 'callback');\n    this.#callback = callback;\n  }\n\n  observe(options = kEmptyObject) {\n    validateObject(options\x2C 'options');\n    const {\n      entryTypes\x2C\n      type\x2C\n      buffered\x2C\n    } = { ...options };\n    if (entryTypes === undefined && type === undefined)\n      throw new ERR_MISSING_ARGS('options.entryTypes'\x2C 'options.type');\n    if (entryTypes != null && type != null)\n      throw new ERR_INVALID_ARG_VALUE('options.entryTypes'\x2C\n                                      entryTypes\x2C\n                                      'options.entryTypes can not set with ' +\n                                      'options.type together');\n\n    switch (this.#type) {\n      case undefined:\n        if (entryTypes !== undefined) this.#type = kTypeMultiple;\n        if (type !== undefined) this.#type = kTypeSingle;\n        break;\n      case kTypeSingle:\n        if (entryTypes !== undefined)\n          throw lazyDOMException(\n            'PerformanceObserver can not change to multiple observations'\x2C\n            'InvalidModificationError');\n        break;\n      case kTypeMultiple:\n        if (type !== undefined)\n          throw lazyDOMException(\n            'PerformanceObserver can not change to single observation'\x2C\n            'InvalidModificationError');\n        break;\n    }\n\n    if (this.#type === kTypeMultiple) {\n      if (!ArrayIsArray(entryTypes)) {\n        throw new ERR_INVALID_ARG_TYPE(\n          'options.entryTypes'\x2C\n          'string[]'\x2C\n          entryTypes);\n      }\n      maybeDecrementObserverCounts(this.#entryTypes);\n      this.#entryTypes.clear();\n      for (let n = 0; n < entryTypes.length; n++) {\n        if (ArrayPrototypeIncludes(kSupportedEntryTypes\x2C entryTypes[n])) {\n          this.#entryTypes.add(entryTypes[n]);\n          maybeIncrementObserverCount(entryTypes[n]);\n        }\n      }\n    } else {\n      if (!ArrayPrototypeIncludes(kSupportedEntryTypes\x2C type))\n        return;\n      this.#entryTypes.add(type);\n      maybeIncrementObserverCount(type);\n      if (buffered) {\n        const entries = filterBufferMapByNameAndType(undefined\x2C type);\n        ArrayPrototypePushApply(this.#buffer\x2C entries);\n        kPending.add(this);\n        if (kPending.size)\n          queuePending();\n      }\n    }\n\n    if (this.#entryTypes.size)\n      kObservers.add(this);\n    else\n      this.disconnect();\n  }\n\n  disconnect() {\n    maybeDecrementObserverCounts(this.#entryTypes);\n    kObservers.delete(this);\n    kPending.delete(this);\n    this.#buffer = [];\n    this.#entryTypes.clear();\n    this.#type = undefined;\n  }\n\n  takeRecords() {\n    const list = this.#buffer;\n    this.#buffer = [];\n    return list;\n  }\n\n  static get supportedEntryTypes() {\n    return kSupportedEntryTypes;\n  }\n\n  [kMaybeBuffer](entry) {\n    if (!this.#entryTypes.has(entry.entryType))\n      return;\n    ArrayPrototypePush(this.#buffer\x2C entry);\n    kPending.add(this);\n    if (kPending.size)\n      queuePending();\n  }\n\n  [kDispatch]() {\n    this.#callback(new PerformanceObserverEntryList(this.takeRecords())\x2C\n                   this);\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `PerformanceObserver ${inspect({\n      connected: kObservers.has(this)\x2C\n      pending: kPending.has(this)\x2C\n      entryTypes: ArrayFrom(this.#entryTypes)\x2C\n      buffer: this.#buffer\x2C\n    }\x2C opts)}`;\n  }\n}\n\n/**\n * https://www.w3.org/TR/performance-timeline/#dfn-queue-a-performanceentry\n *\n * Add the performance entry to the interested performance observer's queue.\n */\nfunction enqueue(entry) {\n  if (!isPerformanceEntry(entry))\n    throw new ERR_INVALID_ARG_TYPE('entry'\x2C 'PerformanceEntry'\x2C entry);\n\n  for (const obs of kObservers) {\n    obs[kMaybeBuffer](entry);\n  }\n}\n\n/**\n * Add the user timing entry to the global buffer.\n */\nfunction bufferUserTiming(entry) {\n  const entryType = entry.entryType;\n  let buffer;\n  if (entryType === 'mark') {\n    buffer = markEntryBuffer;\n  } else if (entryType === 'measure') {\n    buffer = measureEntryBuffer;\n  } else {\n    return;\n  }\n\n  ArrayPrototypePush(buffer\x2C entry);\n  const count = buffer.length;\n\n  if (count > kPerformanceEntryBufferWarnSize &&\n    !kWarnedEntryTypes.has(entryType)) {\n    kWarnedEntryTypes.set(entryType\x2C true);\n    // No error code for this since it is a Warning\n    // eslint-disable-next-line no-restricted-syntax\n    const w = new Error('Possible perf_hooks memory leak detected. ' +\n                        `${count} ${entryType} entries added to the global ` +\n                        'performance entry buffer. Use ' +\n                        `${kClearPerformanceEntryBuffers[entryType]} to ` +\n                        'clear the buffer.');\n    w.name = 'MaxPerformanceEntryBufferExceededWarning';\n    w.entryType = entryType;\n    w.count = count;\n    process.emitWarning(w);\n  }\n}\n\n/**\n * Add the resource timing entry to the global buffer if the buffer size is not\n * exceeding the buffer limit\x2C or dispatch a buffer full event on the global\n * performance object.\n *\n * See also https://www.w3.org/TR/resource-timing-2/#dfn-add-a-performanceresourcetiming-entry\n */\nfunction bufferResourceTiming(entry) {\n  if (resourceTimingBuffer.length < resourceTimingBufferSizeLimit && !resourceTimingBufferFullPending) {\n    ArrayPrototypePush(resourceTimingBuffer\x2C entry);\n    return;\n  }\n\n  if (!resourceTimingBufferFullPending) {\n    resourceTimingBufferFullPending = true;\n    setImmediate(() => {\n      while (resourceTimingSecondaryBuffer.length > 0) {\n        const excessNumberBefore = resourceTimingSecondaryBuffer.length;\n        dispatchBufferFull('resourcetimingbufferfull');\n\n        // Calculate the number of items to be pushed to the global buffer.\n        const numbersToPreserve = MathMax(\n          MathMin(resourceTimingBufferSizeLimit - resourceTimingBuffer.length\x2C resourceTimingSecondaryBuffer.length)\x2C\n          0\x2C\n        );\n        const excessNumberAfter = resourceTimingSecondaryBuffer.length - numbersToPreserve;\n        for (let idx = 0; idx < numbersToPreserve; idx++) {\n          ArrayPrototypePush(resourceTimingBuffer\x2C resourceTimingSecondaryBuffer[idx]);\n        }\n\n        if (excessNumberBefore <= excessNumberAfter) {\n          resourceTimingSecondaryBuffer = [];\n        }\n      }\n      resourceTimingBufferFullPending = false;\n    });\n  }\n\n  ArrayPrototypePush(resourceTimingSecondaryBuffer\x2C entry);\n}\n\n// https://w3c.github.io/resource-timing/#dom-performance-setresourcetimingbuffersize\nfunction setResourceTimingBufferSize(maxSize) {\n  // unsigned long\n  maxSize = convertToInt('maxSize'\x2C maxSize\x2C 32);\n  // If the maxSize parameter is less than resource timing buffer current\n  // size\x2C no PerformanceResourceTiming objects are to be removed from the\n  // performance entry buffer.\n  resourceTimingBufferSizeLimit = maxSize;\n}\n\nfunction setDispatchBufferFull(fn) {\n  dispatchBufferFull = fn;\n}\n\nfunction clearEntriesFromBuffer(type\x2C name) {\n  if (type !== 'mark' && type !== 'measure' && type !== 'resource') {\n    return;\n  }\n\n  if (type === 'mark') {\n    markEntryBuffer = name === undefined ?\n      [] : ArrayPrototypeFilter(markEntryBuffer\x2C (entry) => entry.name !== name);\n  } else if (type === 'measure') {\n    measureEntryBuffer = name === undefined ?\n      [] : ArrayPrototypeFilter(measureEntryBuffer\x2C (entry) => entry.name !== name);\n  } else {\n    resourceTimingBuffer = name === undefined ?\n      [] : ArrayPrototypeFilter(resourceTimingBuffer\x2C (entry) => entry.name !== name);\n  }\n}\n\nfunction filterBufferMapByNameAndType(name\x2C type) {\n  let bufferList;\n  if (type === 'mark') {\n    bufferList = markEntryBuffer;\n  } else if (type === 'measure') {\n    bufferList = measureEntryBuffer;\n  } else if (type === 'resource') {\n    bufferList = resourceTimingBuffer;\n  } else if (type !== undefined) {\n    // Unrecognized type;\n    return [];\n  } else {\n    bufferList = [];\n    ArrayPrototypePushApply(bufferList\x2C markEntryBuffer);\n    ArrayPrototypePushApply(bufferList\x2C measureEntryBuffer);\n    ArrayPrototypePushApply(bufferList\x2C resourceTimingBuffer);\n  }\n  if (name !== undefined) {\n    bufferList = ArrayPrototypeFilter(bufferList\x2C (buffer) => buffer.name === name);\n  } else if (type !== undefined) {\n    bufferList = ArrayPrototypeSlice(bufferList);\n  }\n\n  return ArrayPrototypeSort(bufferList\x2C (first\x2C second) => {\n    return first.startTime - second.startTime;\n  });\n}\n\nfunction observerCallback(name\x2C type\x2C startTime\x2C duration\x2C details) {\n  const entry =\n    new InternalPerformanceEntry(\n      name\x2C\n      type\x2C\n      startTime\x2C\n      duration\x2C\n      details);\n\n  if (details !== undefined) {\n    // GC\x2C HTTP2\x2C and HTTP PerformanceEntry used additional\n    // properties directly off the entry. Those have been\n    // moved into the details property. The existing accessors\n    // are still included but are deprecated.\n    entry[kDeprecatedFields] = new SafeMap();\n\n    const detailKeys = ObjectKeys(details);\n    const props = {};\n    for (let n = 0; n < detailKeys.length; n++) {\n      const key = detailKeys[n];\n      entry[kDeprecatedFields].set(key\x2C details[key]);\n      props[key] = {\n        configurable: true\x2C\n        enumerable: true\x2C\n        get: deprecate(() => {\n          return entry[kDeprecatedFields].get(key);\n        }\x2C kDeprecationMessage\x2C 'DEP0152')\x2C\n        set: deprecate((value) => {\n          entry[kDeprecatedFields].set(key\x2C value);\n        }\x2C kDeprecationMessage\x2C 'DEP0152')\x2C\n      };\n    }\n    ObjectDefineProperties(entry\x2C props);\n  }\n\n  enqueue(entry);\n}\n\nsetupObservers(observerCallback);\n\nfunction hasObserver(type) {\n  const observerType = getObserverType(type);\n  return observerCounts[observerType] > 0;\n}\n\n\nfunction startPerf(target\x2C key\x2C context = {}) {\n  target[key] = {\n    ...context\x2C\n    startTime: now()\x2C\n  };\n}\n\nfunction stopPerf(target\x2C key\x2C context = {}) {\n  const ctx = target[key];\n  if (!ctx) {\n    return;\n  }\n  const startTime = ctx.startTime;\n  const entry = new InternalPerformanceEntry(\n    ctx.name\x2C\n    ctx.type\x2C\n    startTime\x2C\n    now() - startTime\x2C\n    { ...ctx.detail\x2C ...context.detail }\x2C\n  );\n  enqueue(entry);\n}\n\nmodule.exports = {\n  PerformanceObserver\x2C\n  PerformanceObserverEntryList\x2C\n  enqueue\x2C\n  hasObserver\x2C\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n  startPerf\x2C\n  stopPerf\x2C\n\n  bufferUserTiming\x2C\n  bufferResourceTiming\x2C\n  setResourceTimingBufferSize\x2C\n  setDispatchBufferFull\x2C\n};\n
code-source-info,0x31bb26dd7e8,436,0,15460,C0O0C4O15460,,
code-creation,Function,10,82514,0x31bb26ded10,1081, node:internal/perf/observe:1:1,0x31bb26dd760,~
code-source-info,0x31bb26ded10,436,0,15460,C0O0C267O25C273O38C279O54C285O78C291O104C297O126C303O153C309O176C315O198C321O207C327O218C333O229C339O255C344O271C350O285C356O296C362O307C367O659C371O659C376O659C382O360C388O396C394O435C400O473C406O510C412O550C418O586C424O604C430O639C435O754C439O754C444O702C450O730C456O902C460O902C465O902C471O822C477O849C483O875C489O981C493O981C498O941C504O961C510O1108C514O1108C519O1045C524O1057C530O1070C536O1090C542O1163C546O1163C551O1145C557O1203C561O1203C566O1191C572O1237C576O1237C581O1229C587O1294C591O1294C596O1277C602O1341C606O1341C610O1341C612O1383C616O1383C620O1383C622O1433C626O1433C630O1433C632O1493C637O1546C640O1493C642O1606C643O1606C645O1631C647O1631C649O1661C650O1661C652O1698C658O1698C662O1698C664O1876C666O1876C668O1905C670O1905C672O1936C674O1936C676O1976C678O1976C680O2020C686O2020C688O2176C692O2176C694O2185C695O2185C697O2243C698O2243C700O2289C706O2289C710O2289C712O2412C715O2412C720O2412C722O2447C725O2447C730O2447C732O2479C735O2479C740O2479C742O2510C743O2510C793O4648C829O3890C932O7756C944O7963C954O8085C991O14585C995O15173C1003O15194C1009O15217C1015O15249C1021O15260C1027O15275C1033O15301C1039O15333C1045O15346C1051O15359C1057O15379C1063O15403C1069O15434C1075O15188C1080O15459,,
code-creation,Function,10,82538,0x31bb26df378,46,<instance_members_initializer> node:internal/perf/observe:213:1,0x31bb26de138,~
code-source-info,0x31bb26df378,436,4898,8468,C3O4938C12O4958C19O4958C32O4975C40O4984C45O8468,,
code-creation,Function,10,82544,0x31bb26df420,11,<instance_members_initializer> node:internal/perf/observe:169:1,0x31bb26dde58,~
code-source-info,0x31bb26df420,436,3890,4896,C3O3939C10O4896,,
code-creation,Eval,10,82700,0x31bb26e0d78,5, node:internal/perf/performance_entry:1:1,0x31bb26e0bc0,~
script-source,437,node:internal/perf/performance_entry,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('util');\n\nconst kName = Symbol('kName');\nconst kType = Symbol('kType');\nconst kStart = Symbol('kStart');\nconst kDuration = Symbol('kDuration');\nconst kDetail = Symbol('kDetail');\n\nfunction isPerformanceEntry(obj) {\n  return obj?.[kName] !== undefined;\n}\n\nclass PerformanceEntry {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  get name() { return this[kName]; }\n\n  get entryType() { return this[kType]; }\n\n  get startTime() { return this[kStart]; }\n\n  get duration() { return this[kDuration]; }\n\n  get detail() { return this[kDetail]; }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\x2C\n    };\n\n    return `${this.constructor.name} ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  toJSON() {\n    return {\n      name: this.name\x2C\n      entryType: this.entryType\x2C\n      startTime: this.startTime\x2C\n      duration: this.duration\x2C\n      detail: this.detail\x2C\n    };\n  }\n}\n\nclass InternalPerformanceEntry {\n  constructor(name\x2C type\x2C start\x2C duration\x2C detail) {\n    this[kName] = name;\n    this[kType] = type;\n    this[kStart] = start;\n    this[kDuration] = duration;\n    this[kDetail] = detail;\n  }\n}\n\nInternalPerformanceEntry.prototype.constructor = PerformanceEntry;\nObjectSetPrototypeOf(\n  InternalPerformanceEntry.prototype\x2C\n  PerformanceEntry.prototype);\n\nmodule.exports = {\n  InternalPerformanceEntry\x2C\n  PerformanceEntry\x2C\n  isPerformanceEntry\x2C\n};\n
code-source-info,0x31bb26e0d78,437,0,1731,C0O0C4O1731,,
code-creation,Function,10,82759,0x31bb26e1818,274, node:internal/perf/performance_entry:1:1,0x31bb26e0cf0,~
code-source-info,0x31bb26e1818,437,0,1731,C0O0C31O25C36O49C41O132C44O132C49O132C54O98C60O206C63O206C68O192C73O253C76O253C81O241C87O285C90O285C94O285C96O316C99O316C103O316C105O348C108O348C112O348C114O384C117O384C121O384C123O421C126O421C130O421C166O821C197O516C217O1505C224O1527C228O1596C233O1626C238O1547C243O1639C250O1660C256O1688C262O1708C268O1654C273O1730,,
code-creation,LazyCompile,10,82972,0x31bb26e25f0,34,protoGetter node:net:876:21,0x287bc3a5768,~
code-source-info,0x31bb26e25f0,415,23143,23305,C0O23164C8O23192C13O23203C20O23288C27O23164C33O23304,,
tick,0xa977a0,83079,1,0xb795c0,5,0xdd1310,0x65c50a3,0x65c42db,0x287bc3a16dc,0x65c5168,0x65c42db,0x287bc3a0918,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,Eval,10,83190,0x31bb26e8448,5, node:internal/tty:1:1,0x31bb26e81f0,~
script-source,438,node:internal/tty,// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\n// of this software and associated documentation files (the "Software")\x2C to deal\n// in the Software without restriction\x2C including without limitation the rights\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\n// copies of the Software\x2C and to permit persons to whom the Software is\n// furnished to do so\x2C subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome\x2C\n  RegExpPrototypeExec\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors\x2C but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\n// distribution of this file\x2C with or without modification\x2C are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16\x2C\n  'cons25': COLORS_16\x2C\n  'console': COLORS_16\x2C\n  'cygwin': COLORS_16\x2C\n  'dtterm': COLORS_16\x2C\n  'gnome': COLORS_16\x2C\n  'hurd': COLORS_16\x2C\n  'jfbterm': COLORS_16\x2C\n  'konsole': COLORS_16\x2C\n  'kterm': COLORS_16\x2C\n  'mlterm': COLORS_16\x2C\n  'mosh': COLORS_16m\x2C\n  'putty': COLORS_16\x2C\n  'st': COLORS_16\x2C\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m\x2C\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m\x2C\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/\x2C\n  /color/\x2C\n  /linux/\x2C\n  /^con[0-9]*x[0-9]/\x2C\n  /^rxvt/\x2C\n  /^screen/\x2C\n  /^xterm/\x2C\n  /^vt100/\x2C\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += "' and '";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\n      'Warning'\x2C\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color\x2C\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ([\n      'APPVEYOR'\x2C\n      'BUILDKITE'\x2C\n      'CIRCLECI'\x2C\n      'DRONE'\x2C\n      'GITHUB_ACTIONS'\x2C\n      'GITLAB_CI'\x2C\n      'TRAVIS'\x2C\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeExec(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) !== null ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeExec(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION) !== null\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeExec(/^xterm-256/\x2C env.TERM) !== null) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\n                           (term) => RegExpPrototypeExec(term\x2C termEnv) !== null)) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count\x2C env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count\x2C 'count'\x2C 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth\x2C\n  hasColors\x2C\n};\n
code-source-info,0x31bb26e8448,438,0,6485,C0O0C4O6485,,
code-creation,Function,10,83377,0x31bb26e88a8,358, node:internal/tty:1:1,0x31bb26e83c0,~
code-source-info,0x31bb26e88a8,438,0,6485,C0O0C69O1186C75O1208C81O1231C87O1255C93O1329C99O1329C104O1309C110O1366C111O1366C113O1395C115O1395C117O1416C119O1416C121O1438C123O1438C125O1460C127O1460C129O1877C136O1890C142O1913C148O1937C154O1960C160O1983C166O2005C172O2026C178O2050C184O2074C190O2096C196O2119C202O2140C208O2163C214O2182C220O2287C226O2379C232O1877C234O2421C328O2421C330O2542C331O2542C333O6433C340O6454C346O6471C352O6448C357O6484,,
code-creation,LazyCompile,10,83511,0x31bb26e9928,192,WriteStream node:tty:84:21,0x287bc3a1048,~
code-source-info,0x31bb26e9928,414,2501,3453,C0O2510C2O2521C7O2550C12O2557C17O2577C18O2580C20O2587C26O2592C32O2605C37O2614C44O2620C49O2614C50O2659C52O2677C65O2677C71O2705C77O2731C84O2737C89O2731C90O2774C95O2778C100O2785C112O2840C116O2785C122O3264C127O3272C134O3272C139O3310C149O3310C155O3343C160O3351C165O3351C171O3377C173O3393C174O3415C177O3406C181O3424C183O3443C186O3434C191O3452,,
code-creation,LazyCompile,10,83635,0x31bb26ea530,919,Socket node:net:366:16,0x287bc3a55d8,~
code-source-info,0x31bb26ea530,415,9595,14123,C0O9609C2O9620C7O9640C12O9647C17O9667C18O9670C25O9681C34O9701C42O9776C52O9707C57O9701C58O9830C65O9841C81O9872C90O9900C98O9967C115O10056C121O10086C131O9906C136O9900C137O10145C144O10163C155O10210C167O10239C178O10210C183O10321C189O10343C194O10356C195O10386C199O10404C200O10420C204O10624C206O10629C211O10646C215O10654C216O10669C220O10680C222O10685C226O10694C230O10704C231O10717C235O10727C236O10738C240O10748C242O10753C246O10774C250O10781C252O10786C256O10796C260O10806C262O10811C266O10820C270O10830C272O10835C276O10846C280O10856C282O10861C286O10873C290O10883C291O10913C295O10925C301O10962C308O10978C319O11021C325O11100C327O11124C330O11140C335O11124C339O11122C343O11214C344O11232C348O11243C349O11263C353O11303C354O11325C358O11336C363O11343C368O11350C373O11350C379O11386C385O11423C389O11413C393O11446C395O11451C401O11489C406O11470C410O11468C416O11520C422O11552C427O11576C429O11694C434O11709C439O11707C443O11750C448O11758C453O11758C459O12015C461O12030C469O12036C474O12030C475O12070C477O12075C480O12099C485O12107C490O12107C494O12092C498O12126C500O12134C507O12146C512O12170C519O12189C521O12178C528O12198C532O12280C537O12288C544O12288C550O12313C552O12330C560O12336C565O12330C566O12379C567O12392C571O12406C573O12420C576O12420C580O12418C584O12611C589O12637C602O12611C607O12769C612O12779C622O12839C625O12859C630O12839C636O12884C644O12930C652O12979C660O13010C662O13015C666O13024C670O13038C672O13043C675O13064C679O13055C685O13091C687O13096C690O13114C694O13105C698O13132C700O13137C703O13157C707O13148C711O13174C713O13179C718O13194C721O13210C726O13194C730O13192C734O13222C736O13227C741O13244C744O13260C749O13244C753O13242C757O13274C759O13279C762O13319C766O13341C772O13309C774O13308C776O13306C780O13413C791O13413C797O13448C800O13448C804O13475C805O13493C809O13503C811O13525C815O13666C821O13685C827O13694C832O13723C838O13810C844O13826C848O13846C853O13854C858O13854C862O13872C863O13893C869O13926C875O13952C882O13952C887O13998C888O14010C892O14020C893O14033C897O14073C899O14078C903O14090C907O14097C909O14102C913O14117C918O14122,,
code-creation,LazyCompile,10,83705,0x31bb26eac68,169,Duplex node:internal/streams/duplex:54:16,0x287bc3bdb48,~
code-source-info,0x31bb26eac68,423,2011,2663,C0O2025C2O2036C7O2060C12O2067C17O2087C18O2091C23O2100C28O2100C34O2123C39O2132C44O2132C50O2156C54O2204C60O2218C64O2194C68O2246C74O2255C79O2279C85O2303C89O2323C95O2344C99O2363C105O2389C109O2420C115O2429C120O2453C126O2477C130O2497C136O2519C140O2538C146O2559C150O2578C156O2602C162O2631C163O2650C168O2662,,
code-creation,LazyCompile,10,83747,0x31bb26eb3f0,220,Readable node:internal/streams/readable:221:18,0x31bb26c11a0,~
code-source-info,0x31bb26eb3f0,424,8006,8877,C0O8006C9O8020C16O8031C21O8057C28O8064C33O8086C34O8241C41O8257C44O8264C48O8246C52O8275C71O8297C76O8295C80O8344C84O8382C92O8409C95O8430C99O8420C103O8460C111O8490C114O8514C118O8504C122O8547C130O8579C133O8605C137O8595C141O8633C149O8644C151O8660C158O8683C166O8660C171O8705C178O8712C186O8712C192O8736C199O8748C212O8748C219O8876,,
code-creation,LazyCompile,10,83772,0x31bb26eb640,18,Stream node:internal/streams/legacy:10:16,0x31bb26c8100,~
code-source-info,0x31bb26eb640,425,127,160,C0O138C5O141C10O141C17O159,,
code-creation,LazyCompile,10,83911,0x31bb26ebd58,340,ReadableState node:internal/streams/readable:154:23,0x31bb26c1150,~
code-source-info,0x31bb26ebd58,424,5394,7986,C0O5732C6O5771C8O5800C11O5807C15O5789C20O5934C22O5947C27O5960C29O5958C35O5975C37O5973C43O5990C45O5988C48O5945C52O6121C56O6144C62O6156C69O6170C74O6167C78O6186C84O6202C86O6221C92O6245C99O6259C104O6256C108O6417C113O6438C117O6452C132O6452C141O6525C146O6525C150O6436C154O6728C156O6746C159O6742C164O6740C168O6762C169O6774C173O6781C175O6792C179O6800C180O6813C184O6824C186O6829C190O6838C194O6908C198O6931C204O6941C209O6952C216O6967C218O6966C223O6963C227O7055C231O7078C237O7090C242O7101C249O7116C251O7115C256O7112C260O7375C261O7388C265O7595C270O7619C272O7638C280O7616C284O7771C285O7794C289O7805C290O7818C294O7828C295O7842C299O7852C303O7875C309O7891C311O7910C314O7932C321O7906C326O7904C330O7971C334O7961C339O7985,,
code-creation,LazyCompile,10,83966,0x31bb26ec0f8,98,getHighWaterMark node:internal/streams/state:32:26,0x31bb26cada0,~
code-source-info,0x31bb26ec0f8,428,826,1234,C0O880C12O880C18O931C21O954C26O959C33O987C38O1013C47O1035C56O1080C69O1086C74O1080C75O1134C80O1141C84O1156C85O1183C88O1220C93O1190C97O1232,,
code-creation,LazyCompile,10,83991,0x31bb26ec408,26,highWaterMarkFrom node:internal/streams/state:14:27,0x31bb26cacb0,~
code-source-info,0x31bb26ec408,428,313,454,C0O363C7O395C15O415C19O433C25O452,,
code-creation,LazyCompile,10,84018,0x31bb26ec510,17,BufferList node:internal/streams/buffer_list:14:14,0x31bb26c95c0,~
code-source-info,0x31bb26ec510,427,265,338,C0O274C1O284C5O296C6O306C10O318C11O330C16O337,,
code-creation,LazyCompile,10,84085,0x31bb26ecc48,98,construct node:internal/streams/destroy:219:19,0x287bc3bc4c0,~
code-source-info,0x31bb26ecc48,422,4433,4821,C0O4468C8O4501C9O4508C10O4533C15O4568C20O4587C24O4600C25O4614C29O4629C33O4642C34O4656C38O4679C45O4684C48O4679C54O4715C61O4729C64O4715C72O4741C77O4766C78O4773C79O4781C82O4789C90O4789C97O4820,,
tick,0x7f6e64fa56b5,84146,0,0x0,2,0x12da7b0,0x31bb26eac94,0x31bb26ea6a5,0x31bb26e999c,0x287bc3a0924,0x287bc39f9c1,0x287bc39f7c1,0x287bc39f6a0,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,84194,0x31bb26ed948,266,Writable node:internal/streams/writable:220:18,0x31bb26d0140,~
code-source-info,0x31bb26ed948,430,7421,8932,C0O7421C9O7995C16O8012C19O8019C23O8001C27O8031C33O8049C44O8049C51O8105C58O8112C63O8134C64O8138C83O8160C88O8158C92O8207C96O8245C104O8273C107O8295C111O8285C115O8326C123O8355C126O8378C130O8368C134O8410C142O8440C145O8464C149O8454C153O8497C161O8525C164O8547C168O8537C172O8578C180O8610C183O8636C187O8626C191O8664C197O8678C204O8701C212O8678C217O8723C224O8730C232O8730C238O8754C245O8766C258O8766C265O8931,,
code-creation,LazyCompile,10,84264,0x31bb26efaf8,341,WritableState node:internal/streams/writable:77:23,0x31bb26d00a0,~
code-source-info,0x31bb26efaf8,430,2474,6975,C0O2808C6O2847C8O2876C11O2883C15O2865C20O2991C25O3012C27O3031C33O3007C37O3047C41O3088C52O3111C54O3130C60O3081C64O3339C69O3360C73O3374C88O3374C97O3447C102O3447C106O3358C110O3514C111O3531C115O3566C116O3581C120O3627C121O3639C125O3697C126O3708C130O3750C131O3764C135O3803C136O3818C140O4017C144O4039C150O4053C156O4067C158O4089C159O4086C163O4297C168O4321C170O4340C178O4318C182O4518C183O4530C187O4594C188O4607C192O4684C193O4696C197O4960C198O4970C202O5173C203O5195C207O5261C210O5284C217O5284C223O5274C227O5384C228O5397C232O5469C233O5483C237O5598C238O5622C242O5633C245O5633C249O5760C250O5775C254O5965C255O5982C259O6120C260O6137C264O6224C265O6242C269O6313C271O6331C277O6350C283O6360C287O6328C291O6447C293O6467C299O6486C305O6498C309O6464C313O6721C314O6734C318O6804C319O6816C323O6920C324O6938C328O6950C330O6955C335O6968C340O6974,,
code-creation,LazyCompile,10,84301,0x31bb26efe88,15,getDefaultHighWaterMark node:internal/streams/state:19:33,0x31bb26cad00,~
code-source-info,0x31bb26efe88,428,488,586,C0O505C6O525C12O558C14O584,,
code-creation,LazyCompile,10,84339,0x31bb26eff88,23,resetBuffer node:internal/streams/writable:202:21,0x31bb26d00f0,~
code-source-info,0x31bb26eff88,430,6997,7109,C0O7009C2O7024C6O7032C7O7052C11O7059C12O7076C16O7086C17O7100C22O7108,,
code-creation,LazyCompile,10,84377,0x31bb26f0080,14,set node:net:2249:6,0x287bc3a7820,~
code-source-info,0x31bb26f0080,415,62543,62576,C0O62549C2O62561C7O62570C13O62574,,
code-creation,LazyCompile,10,84395,0x31bb26f0168,8,get node:net:2248:6,0x287bc3a77d0,~
code-source-info,0x31bb26f0168,415,62508,62536,C0O62513C2O62525C4O62524C7O62534,,
code-creation,LazyCompile,10,84412,0x31bb26f0250,32,getNewAsyncId node:net:197:23,0x287bc3a5268,~
code-source-info,0x31bb26f0250,415,5454,5570,C0O5467C4O5500C14O5533C17O5533C22O5555C27O5555C31O5568,,
code-creation,LazyCompile,10,84461,0x31bb26f0400,196,Readable.on node:internal/streams/readable:927:33,0x31bb26c2038,~
code-source-info,0x31bb26f0400,424,30060,30959,C0O30085C5O30092C10O30102C15O30105C29O30105C35O30146C40O30165C42O30172C47O30354C55O30354C62O30380C65O30347C69O30473C75O30481C80O30503C85O30503C91O30522C93O30529C98O30562C104O30583C110O30610C112O30655C118O30634C122O30669C123O30683C127O30698C128O30720C132O30735C140O30762C145O30776C150O30735C155O30802C161O30820C164O30820C170O30864C176O30883C179O30891C187O30891C193O30946C195O30957,,
code-creation,LazyCompile,10,84508,0x31bb26f0678,135,initSocketHandle node:net:322:26,0x287bc3a5538,~
code-source-info,0x31bb26f0678,415,8408,8986,C0O8424C5O8424C9O8440C10O8455C14O8541C20O8561C27O8569C32O8583C36O8600C43O8617C45O8615C49O8635C51O8640C57O8678C62O8659C66O8657C70O8707C72O8712C74O8711C78O8726C80O8762C82O8767C84O8766C88O8786C90O8827C94O8845C99O8850C105O8883C106O8890C107O8899C109O8904C114O8913C118O8943C123O8951C128O8951C134O8985,,
code-creation,LazyCompile,10,84545,0x31bb26f08b0,160,undestroy node:internal/streams/destroy:154:19,0x287bc3bc420,~
code-source-info,0x31bb26f08b0,422,2820,3492,C0O2842C5O2875C10O2894C14O2907C15O2921C19O2933C20O2942C24O2955C25O2970C29O2983C30O2995C34O3008C35O3018C39O3030C40O3045C44O3058C45O3068C49O3093C55O3102C58O3089C62O3134C68O3143C71O3130C75O3161C79O3174C80O3188C84O3200C85O3212C89O3225C90O3234C94O3247C95O3262C99O3275C100O3285C104O3297C105O3312C109O3325C110O3339C114O3352C115O3366C119O3391C125O3400C128O3387C132O3428C138O3437C141O3424C145O3467C151O3476C154O3463C159O3491,,
code-creation,LazyCompile,10,84570,0x31bb26f0aa8,38,set node:internal/streams/readable:110:8,0x31bb26cbc58,~
code-source-info,0x31bb26f0aa8,424,3406,3488,C0O3422C4O3433C11O3447C14O3444C20O3463C27O3477C32O3474C37O3487,,
code-creation,LazyCompile,10,84668,0x31bb26f10a8,21,addCleanup node:internal/bootstrap/switches/is_main_thread:142:20,0x13800b15e450,~
code-source-info,0x31bb26f10a8,56,3657,3729,C0O3666C5O3670C10O3698C15O3698C20O3728,,
code-creation,LazyCompile,10,84703,0x31bb26f11f0,81,value node:internal/console/constructor:320:20,0x13800b149400,~
code-source-info,0x31bb26f11f0,50,9640,10042,C0O9669C2O9674C4O9673C8O9693C10O9703C15O9725C18O9733C22O9749C27O9750C33O9805C38O9816C43O9816C49O9833C51O9868C57O9902C59O9917C63O9944C65O9959C66O9975C72O9990C78O10013C80O10036,,
code-creation,LazyCompile,10,84724,0x31bb26f1380,32,lazyUtilColors node:internal/console/constructor:84:24,0x13800b147d70,~
code-source-info,0x31bb26f1380,50,1914,1991,C0O1921C14O1936C21O1932C27O1971C31O1989,,
code-creation,Eval,10,84781,0x31bb26f1690,5, node:internal/util/colors:1:1,0x31bb26f14f8,~
script-source,439,node:internal/util/colors,'use strict';\n\nlet internalTTy;\nfunction lazyInternalTTY() {\n  internalTTy ??= require('internal/tty');\n  return internalTTy;\n}\n\nmodule.exports = {\n  blue: ''\x2C\n  green: ''\x2C\n  white: ''\x2C\n  red: ''\x2C\n  gray: ''\x2C\n  clear: ''\x2C\n  hasColors: false\x2C\n  shouldColorize(stream) {\n    if (process.env.FORCE_COLOR !== undefined) {\n      return lazyInternalTTY().getColorDepth() > 2;\n    }\n    return stream?.isTTY && (\n      typeof stream.getColorDepth === 'function' ?\n        stream.getColorDepth() > 2 : true);\n  }\x2C\n  refresh() {\n    if (process.stderr.isTTY) {\n      const hasColors = module.exports.shouldColorize(process.stderr);\n      module.exports.blue = hasColors ? '\\u001b[34m' : '';\n      module.exports.green = hasColors ? '\\u001b[32m' : '';\n      module.exports.white = hasColors ? '\\u001b[39m' : '';\n      module.exports.yellow = hasColors ? '\\u001b[33m' : '';\n      module.exports.red = hasColors ? '\\u001b[31m' : '';\n      module.exports.gray = hasColors ? '\\u001b[90m' : '';\n      module.exports.clear = hasColors ? '\\u001bc' : '';\n      module.exports.hasColors = hasColors;\n    }\n  }\x2C\n};\n\nmodule.exports.refresh();\n
code-source-info,0x31bb26f1690,439,0,1122,C0O0C4O1122,,
code-creation,Function,10,84822,0x31bb26f18e0,78, node:internal/util/colors:1:1,0x31bb26f1608,~
code-source-info,0x31bb26f18e0,439,0,1122,C0O0C26O19C27O19C29O129C37O244C45O508C55O144C59O1096C62O1103C67O1111C72O1111C77O1121,,
code-creation,LazyCompile,10,84890,0x31bb26f1da0,211,refresh node:internal/util/colors:25:10,0x31bb26f1760,~
code-source-info,0x31bb26f1da0,439,515,1090,C0O524C3O536C8O543C14O576C17O583C22O591C30O614C35O591C41O629C44O636C51O651C59O649C63O688C66O695C73O711C81O709C85O748C88O755C95O771C103O769C107O808C110O815C117O832C125O830C129O869C132O876C139O890C147O888C151O927C154O934C161O949C169O947C173O986C176O993C183O1009C191O1007C195O1043C198O1050C205O1068C210O1089,,
code-creation,LazyCompile,10,84930,0x31bb26f21b8,125,getStderr node:internal/bootstrap/switches/is_main_thread:170:19,0x13800b15e518,~
code-source-info,0x31bb26f21b8,56,4443,5116,C0O4450C6O4462C10O4476C11O4479C17O4488C24O4486C30O4520C37O4541C40O4548C44O4539C48O4559C53O4582C60O4573C66O4658C73O4674C77O4692C82O4703C88O4716C91O4724C102O4724C108O4771C116O4771C120O5100C124O5114,,
code-creation,LazyCompile,10,85069,0x31bb26f2468,19,_getMaxListeners node:events:418:26,0x28d42e2b0b78,~
script-source,29,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n  SymbolDispose\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nconst { kEmptyObject } = require('internal/util');\n\nconst {\n  inspect\x2C\n  identicalSequenceRange\x2C\n} = require('internal/util/inspect');\n\nlet spliceOne;\nlet kResistStopPropagation;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\x2C\n  }\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource\x2C\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number\x2C\n       *   requireManualDestroy?: boolean\x2C\n       * }} [options]\n       */\n      constructor(ee\x2C type\x2C options) {\n        super(type\x2C options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string\x2C\n         *   triggerAsyncId?: number\x2C\n         *   requireManualDestroy?: boolean\x2C\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name\x2C 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\n        }\n\n        /**\n         * @param {symbol\x2Cstring} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event\x2C ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.addAbortListener = addAbortListener;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\nmodule.exports.getMaxListeners = getMaxListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  __proto__: null\x2C\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\x2C\n});\n\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: lazyEventEmitterAsyncResource\x2C\n  set: undefined\x2C\n  configurable: true\x2C\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  __proto__: null\x2C\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\x2C\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\x2C\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition\x2C please also update any\n// re-definitions\x2C such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { len\x2C offset } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C offset + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          __proto__: null\x2C\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\x2C\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target\x2C { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`\x2C\n        { name: 'MaxListenersExceededWarning'\x2C emitter: target\x2C type: type\x2C count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {number}\n */\nfunction listenerCount(type\x2C listener) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      if (listener != null) {\n        return listener === evlistener || listener === evlistener.listener ? 1 : 0;\n      }\n\n      return 1;\n    } else if (evlistener !== undefined) {\n      if (listener != null) {\n        let matching = 0;\n\n        for (let i = 0\x2C l = evlistener.length; i < l; i++) {\n          if (evlistener[i] === listener || evlistener[i].listener === listener) {\n            matching++;\n          }\n        }\n\n        return matching;\n      }\n\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Returns the max listeners set.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @returns {number}\n */\nfunction getMaxListeners(emitterOrTarget) {\n  if (typeof emitterOrTarget?.getMaxListeners === 'function') {\n    return _getMaxListeners(emitterOrTarget);\n  } else if (emitterOrTarget?.[kMaxEventTargetListeners]) {\n    return emitterOrTarget[kMaxEventTargetListeners];\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    const opts = { __proto__: null\x2C once: true\x2C [kResistStopPropagation]: true };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C opts);\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters\x2C we listen to `error` events only on EventEmitters.\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { __proto__: null\x2C once: true\x2C [kResistStopPropagation]: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    emitter.addEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\x2C\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { __proto__: null\x2C once: true\x2C [kResistStopPropagation]: true });\n  }\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n  return iterator;\n}\n\nlet queueMicrotask;\n\nfunction addAbortListener(signal\x2C listener) {\n  if (signal === undefined) {\n    throw new ERR_INVALID_ARG_TYPE('signal'\x2C 'AbortSignal'\x2C signal);\n  }\n  validateAbortSignal(signal\x2C 'signal');\n  validateFunction(listener\x2C 'listener');\n\n  let removeEventListener;\n  if (signal.aborted) {\n    queueMicrotask ??= require('internal/process/task_queues').queueMicrotask;\n    queueMicrotask(() => listener());\n  } else {\n    kResistStopPropagation ??= require('internal/event_target').kResistStopPropagation;\n    // TODO(atlowChemi) add { subscription: true } and return directly\n    signal.addEventListener('abort'\x2C listener\x2C { __proto__: null\x2C once: true\x2C [kResistStopPropagation]: true });\n    removeEventListener = () => {\n      signal.removeEventListener('abort'\x2C listener);\n    };\n  }\n  return {\n    __proto__: null\x2C\n    [SymbolDispose]() {\n      removeEventListener?.();\n    }\x2C\n  };\n}\n
code-source-info,0x31bb26f2468,29,12186,12310,C0O12206C6O12239C9O12259C13O12279C14O12294C18O12308,,
tick,0x7f6e653749e1,86166,0,0x0,3,0x12da7b0,0x28d42e2b11f6,0x28d42e2b162e,0x31bb26f221e,0x31bb26f1da3,0x31bb26f1928,0x65c5168,0x65c42db,0x31bb26f138e,0x31bb26f1202,0x287bc39f6a5,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,86176,0x31bb26f4ac0,5,get node:events:276:16,0x28d42e2b0640,~
code-source-info,0x31bb26f4ac0,29,8053,8093,C0O8062C4O8089,,
code-creation,LazyCompile,10,86211,0x31bb26f4bb8,80,shouldColorize node:internal/util/colors:17:17,0x31bb26f1710,~
code-source-info,0x31bb26f4bb8,439,258,504,C0O273C3O285C8O289C14O324C17O331C21O348C26O349C33O365C36O369C37O380C44O393C53O426C61O472C66O472C73O488C79O500,,
tick,0x12931c0,86275,0,0x0,2,0x12da7b0,0x31bb26f4bfa,0x31bb26f1dc3,0x31bb26f1928,0x65c5168,0x65c42db,0x31bb26f138e,0x31bb26f1202,0x287bc39f6a5,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,86345,0x31bb26f5298,762,getColorDepth node:internal/tty:106:23,0x31bb26e84c8,~
code-source-info,0x31bb26f5298,438,3182,6156,C0O3182C17O3197C27O3329C30O3337C36O3370C39O3382C81O3455C89O3455C93O3493C99O3510C100O3535C108O3535C112O3573C118O3591C119O3616C127O3616C131O3654C137O3672C138O3696C144O3712C145O3726C148O3734C157O3816C166O4046C173O4051C178O4069C184O4085C185O4093C190O4105C197O4114C202O4175C210O4232C218O4232C223O4220C228O4253C235O4286C242O4265C252O4263C260O4485C268O4499C271O4489C276O4503C281O4532C290O4542C293O4532C296O4553C300O4563C305O4581C311O4599C312O4606C316O4616C321O4634C327O4652C328O4664C334O4681C335O4689C338O4697C344O4709C350O4727C351O4735C354O4743C360O4753C365O4894C375O4894C385O4929C392O4937C397O4961C403O4979C404O4990C410O5006C411O5014C416O5037C421O5051C436O5115C441O5058C452O5150C460O5162C462O5171C463O5179C466O5191C501O5235C504O5244C514O5276C525O5312C530O5276C537O5361C543O5379C544O5394C550O5412C551O5461C557O5479C558O5513C564O5531C565O5539C568O5547C575O5557C583O5580C590O5590C595O5609C601O5627C602O5635C605O5643C618O5655C635O5697C640O5659C647O5721C653O5739C654O5767C666O5798C671O5767C675O5767C677O5810C686O5823C691O5842C700O5858C703O5868C704O5879C715O5902C723O5883C730O6012C736O6029C739O6089C742O6097C748O6114C754O6131C755O6138C761O6154,,
code-creation,LazyCompile,10,86507,0x31bb26f5fd8,38,formatWithOptions node:internal/util/inspect:2139:27,0x28d42e2a53c0,~
script-source,26,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  MathTrunc\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeToString\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeSymbolSplit\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplaceAll\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  constants: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\x2C\n    kPending\x2C\n    kRejected\x2C\n  }\x2C\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\x2C\n} = require('internal/util');\n\nconst {\n  isStackOverflowError\x2C\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { BuiltinModule } = require('internal/bootstrap/realm');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\nlet internalUrl;\n\nfunction pathToFileUrlHref(filepath) {\n  internalUrl ??= require('internal/url');\n  return internalUrl.pathToFileURL(filepath).href;\n}\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeExec(/^[A-Z][a-zA-Z0-9]+$/\x2C e) !== null\x2C\n  )\x2C\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\x2C\n  numericSeparator: false\x2C\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    numericSeparator: ctx.numericSeparator\x2C\n    ...ctx.userOptions\x2C\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n * @param {any} value The value to print out.\n * @param {object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\x2C\n    numericSeparator: inspectDefaultOptions.numericSeparator\x2C\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  __proto__: null\x2C\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\x2C\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = {\n  __proto__: null\x2C\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n};\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    __proto__: null\x2C\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\x2C\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nfunction escapeFn(str) {\n  const charCode = StringPrototypeCharCodeAt(str);\n  return meta.length > charCode ? meta[charCode] : `\\\\u${NumberPrototypeToString(charCode\x2C 16)}`;\n}\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && RegExpPrototypeExec(escapeTest\x2C str) === null)\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = RegExpPrototypeSymbolReplace(escapeReplace\x2C str\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  for (let i = 0; i < str.length; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = StringPrototypeCharCodeAt(str\x2C i + 1);\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n      result += `${StringPrototypeSlice(str\x2C last\x2C i)}\\\\u${NumberPrototypeToString(point\x2C 16)}`;\n      last = i + 1;\n    }\n  }\n\n  if (last !== str.length) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return String(descriptor.value.name);\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\x2C\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (proxy === null || proxy[0] === null) {\n      return ctx.stylize('<Revoked Proxy>'\x2C 'special');\n    }\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C\n        context\x2C\n        depth\x2C\n        getUserOptions(ctx\x2C isCrossContext)\x2C\n        inspect\x2C\n      );\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return StringPrototypeReplaceAll(ret\x2C '\\n'\x2C `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\x2C\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (SymbolIterator in value || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        FunctionPrototypeBind(formatSet\x2C null\x2C value) :\n        FunctionPrototypeBind(formatSet\x2C null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        FunctionPrototypeBind(formatMap\x2C null\x2C value) :\n        FunctionPrototypeBind(formatMap\x2C null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = FunctionPrototypeBind(formatTypedArray\x2C null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = FunctionPrototypeBind(formatIterator\x2C null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = FunctionPrototypeBind(formatIterator\x2C null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\x2C\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength\x2C false)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = FunctionPrototypeBind(formatNamespaceObject\x2C null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = StringPrototypeSlice(getCtxStyle(value\x2C constructor\x2C tag)\x2C 0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ArrayPrototypePush(ctx.seen\x2C value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      ArrayPrototypePush(\n        output\x2C\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType)\x2C\n      );\n    }\n    if (protoProps !== undefined) {\n      ArrayPrototypePushApply(output\x2C protoProps);\n    }\n  } catch (err) {\n    const constructorName = StringPrototypeSlice(getCtxStyle(value\x2C constructor\x2C tag)\x2C 0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ArrayPrototypePop(ctx.seen);\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      ArrayPrototypeSort(output\x2C comparator);\n    } else if (keys.length > 1) {\n      const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(output\x2C output.length - keys.length)\x2C comparator);\n      ArrayPrototypeUnshift(sorted\x2C output\x2C output.length - keys.length\x2C keys.length);\n      ReflectApply(ArrayPrototypeSplice\x2C null\x2C sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (StringPrototypeStartsWith(stringified\x2C 'class') && StringPrototypeEndsWith(stringified\x2C '}')) {\n    const slice = StringPrototypeSlice(stringified\x2C 5\x2C -1);\n    const bracketIndex = StringPrototypeIndexOf(slice\x2C '{');\n    if (bracketIndex !== -1 &&\n        (!StringPrototypeIncludes(StringPrototypeSlice(slice\x2C 0\x2C bracketIndex)\x2C '(') ||\n        // Slow path to guarantee that it's indeed a class.\n        RegExpPrototypeExec(classRegExp\x2C RegExpPrototypeSymbolReplace(stripCommentsRegExp\x2C slice)) !== null)\n    ) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return { len\x2C offset: i };\n        }\n      }\n    }\n  }\n\n  return { len: 0\x2C offset: 0 };\n}\n\nfunction getStackString(error) {\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\n}\n\nfunction getStackFrames(ctx\x2C err\x2C stack) {\n  const frames = StringPrototypeSplit(stack\x2C '\\n');\n\n  let cause;\n  try {\n    ({ cause } = err);\n  } catch {\n    // If 'cause' is a getter that throws\x2C ignore it.\n  }\n\n  // Remove stack frames identical to frames in cause.\n  if (cause != null && isError(cause)) {\n    const causeStack = getStackString(cause);\n    const causeStackStart = StringPrototypeIndexOf(causeStack\x2C '\\n    at');\n    if (causeStackStart !== -1) {\n      const causeFrames = StringPrototypeSplit(StringPrototypeSlice(causeStack\x2C causeStackStart + 1)\x2C '\\n');\n      const { len\x2C offset } = identicalSequenceRange(frames\x2C causeFrames);\n      if (len > 0) {\n        const skipped = len - 2;\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\n        frames.splice(offset + 1\x2C skipped\x2C ctx.stylize(msg\x2C 'undefined'));\n      }\n    }\n  }\n  return frames;\n}\n\nfunction improveStack(stack\x2C constructor\x2C name\x2C tag) {\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  let len = name.length;\n\n  if (constructor === null ||\n      (StringPrototypeEndsWith(name\x2C 'Error') &&\n      StringPrototypeStartsWith(stack\x2C name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = RegExpPrototypeExec(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/\x2C stack) ||\n      RegExpPrototypeExec(/^([a-z_A-Z0-9-]*Error)$/\x2C stack);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = StringPrototypeSlice(getPrefix(constructor\x2C tag\x2C fallback)\x2C 0\x2C -1);\n    if (name !== prefix) {\n      if (StringPrototypeIncludes(prefix\x2C name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${StringPrototypeSlice(stack\x2C len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${StringPrototypeSlice(stack\x2C len)}`;\n      }\n    }\n  }\n  return stack;\n}\n\nfunction removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack) {\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = ArrayPrototypeIndexOf(keys\x2C name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && StringPrototypeIncludes(stack\x2C err[name])) {\n        ArrayPrototypeSplice(keys\x2C index\x2C 1);\n      }\n    }\n  }\n}\n\nfunction markNodeModules(ctx\x2C line) {\n  let tempLine = '';\n  let nodeModule;\n  let pos = 0;\n  while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\n    // '/node_modules/'.length === 14\n    tempLine += StringPrototypeSlice(line\x2C pos\x2C nodeModule.index + 14);\n    tempLine += ctx.stylize(nodeModule[1]\x2C 'module');\n    pos = nodeModule.index + nodeModule[0].length;\n  }\n  if (pos !== 0) {\n    line = tempLine + StringPrototypeSlice(line\x2C pos);\n  }\n  return line;\n}\n\nfunction markCwd(ctx\x2C line\x2C workingDirectory) {\n  let cwdStartPos = StringPrototypeIndexOf(line\x2C workingDirectory);\n  let tempLine = '';\n  let cwdLength = workingDirectory.length;\n  if (cwdStartPos !== -1) {\n    if (StringPrototypeSlice(line\x2C cwdStartPos - 7\x2C cwdStartPos) === 'file://') {\n      cwdLength += 7;\n      cwdStartPos -= 7;\n    }\n    const start = line[cwdStartPos - 1] === '(' ? cwdStartPos - 1 : cwdStartPos;\n    const end = start !== cwdStartPos && StringPrototypeEndsWith(line\x2C ')') ? -1 : line.length;\n    const workingDirectoryEndPos = cwdStartPos + cwdLength + 1;\n    const cwdSlice = StringPrototypeSlice(line\x2C start\x2C workingDirectoryEndPos);\n\n    tempLine += StringPrototypeSlice(line\x2C 0\x2C start);\n    tempLine += ctx.stylize(cwdSlice\x2C 'undefined');\n    tempLine += StringPrototypeSlice(line\x2C workingDirectoryEndPos\x2C end);\n    if (end === -1) {\n      tempLine += ctx.stylize(')'\x2C 'undefined');\n    }\n  } else {\n    tempLine += line;\n  }\n  return tempLine;\n}\n\nfunction safeGetCWD() {\n  let workingDirectory;\n  try {\n    workingDirectory = process.cwd();\n  } catch {\n    return;\n  }\n  return workingDirectory;\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let stack = getStackString(err);\n\n  removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack);\n\n  if ('cause' in err &&\n      (keys.length === 0 || !ArrayPrototypeIncludes(keys\x2C 'cause'))) {\n    ArrayPrototypePush(keys\x2C 'cause');\n  }\n\n  // Print errors aggregated into AggregateError\n  if (ArrayIsArray(err.errors) &&\n      (keys.length === 0 || !ArrayPrototypeIncludes(keys\x2C 'errors'))) {\n    ArrayPrototypePush(keys\x2C 'errors');\n  }\n\n  stack = improveStack(stack\x2C constructor\x2C name\x2C tag);\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && StringPrototypeIndexOf(stack\x2C err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = StringPrototypeIndexOf(stack\x2C '\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else {\n    let newStack = StringPrototypeSlice(stack\x2C 0\x2C stackStart);\n    const stackFramePart = StringPrototypeSlice(stack\x2C stackStart + 1);\n    const lines = getStackFrames(ctx\x2C err\x2C stackFramePart);\n    if (ctx.colors) {\n      // Highlight userland code and node modules.\n      const workingDirectory = safeGetCWD();\n      let esmWorkingDirectory;\n      for (let line of lines) {\n        const core = RegExpPrototypeExec(coreModuleRegExp\x2C line);\n        if (core !== null && BuiltinModule.exists(core[1])) {\n          newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n        } else {\n          newStack += '\\n';\n\n          line = markNodeModules(ctx\x2C line);\n          if (workingDirectory !== undefined) {\n            let newLine = markCwd(ctx\x2C line\x2C workingDirectory);\n            if (newLine === line) {\n              esmWorkingDirectory ??= pathToFileUrlHref(workingDirectory);\n              newLine = markCwd(ctx\x2C line\x2C esmWorkingDirectory);\n            }\n            line = newLine;\n          }\n\n          newStack += line;\n        }\n      }\n    } else {\n      newStack += `\\n${ArrayPrototypeJoin(lines\x2C '\\n')}`;\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n    stack = StringPrototypeReplaceAll(stack\x2C '\\n'\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\x2C\n        ) / biasedMax\x2C\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\x2C\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ArrayPrototypePop(ctx.seen);\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\x2C\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction addNumericSeparator(integerString) {\n  let result = '';\n  let i = integerString.length;\n  const start = StringPrototypeStartsWith(integerString\x2C '-') ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    result = `_${StringPrototypeSlice(integerString\x2C i - 3\x2C i)}${result}`;\n  }\n  return i === integerString.length ?\n    integerString :\n    `${StringPrototypeSlice(integerString\x2C 0\x2C i)}${result}`;\n}\n\nfunction addNumericSeparatorEnd(integerString) {\n  let result = '';\n  let i = 0;\n  for (; i < integerString.length - 3; i += 3) {\n    result += `${StringPrototypeSlice(integerString\x2C i\x2C i + 3)}_`;\n  }\n  return i === 0 ?\n    integerString :\n    `${result}${StringPrototypeSlice(integerString\x2C i)}`;\n}\n\nfunction formatNumber(fn\x2C number\x2C numericSeparator) {\n  if (!numericSeparator) {\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\n    if (ObjectIs(number\x2C -0)) {\n      return fn('-0'\x2C 'number');\n    }\n    return fn(`${number}`\x2C 'number');\n  }\n  const integer = MathTrunc(number);\n  const string = String(integer);\n  if (integer === number) {\n    if (!NumberIsFinite(number) || StringPrototypeIncludes(string\x2C 'e')) {\n      return fn(string\x2C 'number');\n    }\n    return fn(`${addNumericSeparator(string)}`\x2C 'number');\n  }\n  if (NumberIsNaN(number)) {\n    return fn(string\x2C 'number');\n  }\n  return fn(`${\n    addNumericSeparator(string)\n  }.${\n    addNumericSeparatorEnd(\n      StringPrototypeSlice(String(number)\x2C string.length + 1)\x2C\n    )\n  }`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C bigint\x2C numericSeparator) {\n  const string = String(bigint);\n  if (!numericSeparator) {\n    return fn(`${string}n`\x2C 'bigint');\n  }\n  return fn(`${addNumericSeparator(string)}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = StringPrototypeSlice(value\x2C 0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // We do not support handling unicode characters width with\n        // the readline getStringWidth function as there are\n        // performance implications.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return ArrayPrototypeJoin(\n        ArrayPrototypeMap(\n          RegExpPrototypeSymbolSplit(/(?<=\\n)/\x2C value)\x2C\n          (line) => fn(strEscape(line)\x2C 'string')\x2C\n        )\x2C\n        ` +\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl + 2)}`\x2C\n      ) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = StringPrototypeLastIndexOf(output[i]\x2C ' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = StringPrototypeSlice(output[i]\x2C 0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (RegExpPrototypeExec(numberRegExp\x2C key) === null) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      ArrayPrototypePush(output\x2C ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    ArrayPrototypePush(output\x2C formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      ArrayPrototypePush(output\x2C ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    ArrayPrototypePush(output\x2C `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    '$1 '\x2C\n  ));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    ArrayPrototypePush(output\x2C formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]\x2C ctx.numericSeparator);\n  }\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    ArrayPrototypePush(\n      output\x2C\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\x2C\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  const output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      ArrayPrototypeSort(output);\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = RegExpPrototypeSymbolReplace(/ Iterator] {$/\x2C braces[0]\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer\x2C\n      SymbolPrototypeToString(key)\x2C\n      escapeFn\x2C\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer\x2C\n      key\x2C\n      escapeFn\x2C\n    );\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeExec(keyStrRegExp\x2C key) !== null) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          const joinedOutput = join(output\x2C '\x2C ');\n          if (!StringPrototypeIncludes(joinedOutput\x2C '\\n')) {\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\n              ` ${braces[1]}`;\n          }\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    if (proxyTarget === null) {\n      return true;\n    }\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) => StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {};\n        a.a = a;\n        JSONStringify(a);\n      } catch (circularError) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  validateObject(inspectOptions\x2C 'inspectOptions'\x2C { allowArray: true });\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatNumberNoColor(number\x2C options) {\n  return formatNumber(\n    stylizeNoColor\x2C\n    number\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\x2C\n  );\n}\n\nfunction formatBigIntNoColor(bigint\x2C options) {\n  return formatBigInt(\n    stylizeNoColor\x2C\n    bigint\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\x2C\n  );\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: { // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumberNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = formatBigIntNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\x2C\n                });\n              }\n              break;\n            }\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: { // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = formatBigIntNoColor(tempNum\x2C inspectOptions);\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(Number(tempNum)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\x2C\n              });\n              break;\n            case 105: { // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = formatBigIntNoColor(tempInteger\x2C inspectOptions);\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseInt(tempInteger)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 102: { // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseFloat(tempFloat)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nfunction isZeroWidthCodePoint(code) {\n  return code <= 0x1F || // C0 control codes\n    (code >= 0x7F && code <= 0x9F) || // C1 control codes\n    (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n    (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n    // Combining Diacritical Marks for Symbols\n    (code >= 0x20D0 && code <= 0x20FF) ||\n    (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n    (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n    (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars) {\n      str = stripVTControlCharacters(str);\n    }\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = StringPrototypeCharCodeAt(str\x2C i);\n      if (code >= 127) {\n        width += icu.getStringWidth(StringPrototypeNormalize(StringPrototypeSlice(str\x2C i)\x2C 'NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return RegExpPrototypeSymbolReplace(ansi\x2C str\x2C '');\n}\n\nmodule.exports = {\n  identicalSequenceRange\x2C\n  inspect\x2C\n  inspectDefaultOptions\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  stripVTControlCharacters\x2C\n  isZeroWidthCodePoint\x2C\n};\n
code-source-info,0x31bb26f5fd8,26,72214,72375,C0O72214C8O72244C16O72259C24O72244C29O72318C32O72325C37O72373,,
tick,0x7f6e64f82f76,88705,0,0x0,3,0x12da7b0,0x287bc39f6c4,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
tick,0x7f6e65374b2d,88711,0,0x0,3,0x12da7b0,0x287bc39f6c4,0x287bc39f580,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,88811,0x31bb26faeb0,763,formatWithOptionsInternal node:internal/util/inspect:2160:35,0x28d42e2a54b0,~
code-source-info,0x31bb26faeb0,26,72779,76769,C0O72820C1O72824C5O72839C7O72854C10O72871C13O72878C19O72924C26O72931C31O72946C33O72959C34O72974C36O73001C38O73022C40O73035C44O73042C47O73027C52O73060C57O73064C65O73100C70O73142C77O73168C80O73142C86O73189C88O73195C92O73208C96O73199C101O73228C169O73309C174O73313C178O73334C182O73385C185O73395C193O73462C199O73513C202O73523C210O73590C223O73696C229O73743C234O73753C241O73809C244O73859C252O73902C257O73931C262O73963C266O73819C272O74016C274O74080C279O74103C282O74107C286O74090C291O74129C293O74197C298O74201C302O74222C306O74273C309O74283C317O74350C323O74401C328O74457C333O74487C336O74487C341O74467C347O74551C349O74614C354O74632C357O74636C361O74624C367O74674C369O74724C374O74742C377O74746C381O74774C388O74818C393O74851C399O74880C403O74734C409O74915C411O74987C416O74991C420O75012C424O75067C427O75077C435O75148C441O75203C446O75259C451O75308C454O75308C459O75269C465O75384C467O75468C472O75472C476O75493C480O75546C485O75602C490O75651C493O75651C498O75612C504O75727C506O75790C512O75812C515O75840C517O75889C519O75896C531O75896C543O75951C545O75963C549O75982C551O76079C553O76111C555O76129C558O76123C563O76148C565O76155C570O76194C581O76155C593O76222C595O76229C602O76248C604O76260C610O76280C612O76293C617O76313C619O76320C631O76320C643O76371C645O76383C649O73048C654O73009C660O76416C661O76428C666O76443C671O76454C674O76492C678O76484C683O76510C685O76517C688O76517C700O76592C704O76585C709O76620C711O76624C715O76633C717O76640C724O76650C736O76685C745O76718C749O76729C752O76745C757O76576C760O76756C762O76767,,
code-creation,LazyCompile,10,88884,0x31bb26fb590,269,value node:internal/console/constructor:277:20,0x13800b149378,~
code-source-info,0x31bb26fb590,50,8093,9537,C0O8150C5O8191C7O8196C9O8195C13O8236C15O8253C17O8249C21O8286C23O8303C29O8318C34O8354C38O8379C44O8406C49O8450C55O8457C60O8474C68O8478C75O8529C90O8587C98O8538C105O8621C107O8642C112O8666C122O8689C123O8706C128O8731C133O8731C138O8745C145O9062C153O9062C160O9085C165O9109C176O9109C182O9146C187O9146C206O9342C216O9346C222O9381C224O9381C238O9486C239O9493C250O9493C268O9536,,
code-creation,LazyCompile,10,88932,0x31bb26fb838,126,listenerCount node:events:845:23,0x28d42e2b1a70,~
code-source-info,0x31bb26fb838,29,24319,25002,C0O24360C5O24372C7O24423C9O24429C13O24442C17O24488C22O24520C24O24536C29O24578C33O24563C43O24595C44O24611C46O24620C47O24632C51O24670C56O24717C58O24742C60O24760C65O24770C67O24770C72O24792C74O24806C80O24810C87O24836C91O24840C98O24849C103O24877C108O24776C113O24729C116O24920C118O24936C119O24970C123O24977C124O24991C125O25000,,
code-creation,LazyCompile,10,88957,0x31bb26fb9e0,39,once node:events:650:44,0x28d42e2b17b0,~
code-source-info,0x31bb26fb9e0,29,19040,19153,C0O19061C3O19061C7O19094C24O19103C30O19094C36O19139C38O19151,,
code-creation,LazyCompile,10,88983,0x31bb26fbbc0,60,_onceWrap node:events:636:19,0x28d42e2b1760,~
code-source-info,0x31bb26fbbc0,29,18613,18836,C0O18656C6O18680C12O18691C18O18699C24O18705C31O18735C34O18747C39O18747C45O18762C47O18779C51O18793C53O18806C57O18819C59O18834,,
code-creation,LazyCompile,10,89022,0x31bb26fbd80,26,Writable.write node:internal/streams/writable:336:36,0x31bb26d0818,~
code-source-info,0x31bb26fbd80,430,10771,10849,C0O10797C15O10804C22O10838C25O10847,,
code-creation,LazyCompile,10,89080,0x31bb26fbf70,338,_write node:internal/streams/writable:286:16,0x31bb26d0190,~
code-source-info,0x31bb26fbf70,430,9405,10734,C0O9460C5O9479C11O9521C14O9557C22O9589C26O9627C34O9653C36O9666C43O9683C46O9690C51O9690C58O9718C65O9724C70O9718C71O9764C77O9800C81O9817C85O9843C90O9849C95O9843C96O9899C102O9917C108O9966C114O9980C119O10001C124O10016C129O10016C137O10047C143O10087C145O10108C147O10097C152O10124C158O10156C163O10167C168O10167C175O10197C180O10212C185O10212C192O10246C198O10286C216O10292C221O10286C222O10396C224O10413C230O10427C235O10433C243O10486C249O10503C259O10509C265O10551C269O10566C272O10574C277O10574C283O10597C296O10597C301O10636C303O10647C304O10654C310O10669C314O10675C332O10682C337O10732,,
code-creation,LazyCompile,10,89136,0x31bb26fc340,217,writeOrBuffer node:internal/streams/writable:368:23,0x31bb26d01e0,~
code-source-info,0x31bb26fc340,430,11690,12681,C0O11755C10O11778C15O11789C22O11805C25O11802C29O11870C34O11885C38O11877C42O11974C44O11988C45O12004C49O12025C55O12042C61O12058C67O12076C73O12101C78O12110C90O12117C96O12124C102O12134C106O12110C111O12161C119O12184C124O12206C125O12223C129O12252C137O12272C142O12289C143O12303C149O12333C151O12348C155O12359C157O12373C161O12389C162O12403C166O12415C167O12426C171O12445C176O12475C190O12445C195O12489C196O12500C200O12630C204O12651C211O12669C216O12679,,
code-creation,LazyCompile,10,89166,0x31bb26fc578,26,Socket._write node:net:973:35,0x287bc3a6f68,~
code-source-info,0x31bb26fc578,415,25474,25547,C0O25504C19O25504C25O25546,,
code-creation,LazyCompile,10,89206,0x31bb26fc818,217,Socket._writeGeneric node:net:931:42,0x287bc3a6e20,~
code-source-info,0x31bb26fc818,415,24433,25337,C0O24433C21O24635C37O24653C41O24671C45O24683C49O24705C53O24726C66O24726C72O24952C83O24952C89O24980C90O24987C91O24994C92O25012C96O25022C98O25044C102O25063C108O25078C115O25085C118O25081C124O25078C128O25111C129O25124C130O25137C135O25137C139O25159C141O25166C145O25182C161O25188C169O25230C188O25236C194O25286C200O25297C204O25302C207O25329C211O25323C216O25336,,
code-creation,LazyCompile,10,89237,0x31bb26fca90,45,_unrefTimer node:net:514:52,0x287bc3a5fe0,~
code-source-info,0x31bb26fca90,415,14316,14426,C0O14336C5O14344C9O14375C11O14381C13O14380C18O14398C20O14400C22O14399C26O14410C31O14410C35O14360C40O14323C44O14425,,
code-creation,LazyCompile,10,89272,0x31bb26fcbb0,55,writeGeneric node:internal/stream_base_commons:147:22,0x31bb26da638,~
code-source-info,0x31bb26fcbb0,434,3600,3784,C0O3643C5O3664C7O3663C11O3643C17O3693C29O3693C35O3733C47O3733C52O3771C54O3782,,
code-creation,LazyCompile,10,89294,0x31bb26fd5d8,47,createWriteWrap node:internal/stream_base_commons:109:25,0x31bb26da598,~
code-source-info,0x31bb26fd5d8,434,2722,2936,C0O2757C5O2757C11O2777C13O2788C17O2800C19O2815C23O2836C24O2846C28O2857C29O2867C33O2874C34O2885C38O2895C40O2908C44O2923C46O2934,,
code-creation,LazyCompile,10,89345,0x31bb26fd810,215,handleWriteReq node:internal/stream_base_commons:45:24,0x31bb26da4f8,~
code-source-info,0x31bb26fd810,434,1177,2009,C0O1211C5O1230C80O1300C85O1300C92O1330C99O1350C101O1349C106O1379C108O1390C112O1404C114O1415C115O1480C120O1480C126O1509C127O1565C132O1565C138O1592C139O1631C144O1631C150O1659C151O1756C156O1756C162O1783C163O1824C168O1831C173O1831C180O1878C185O1878C192O1910C199O1930C201O1929C206O1959C208O1970C212O1986C214O1997,,
code-creation,LazyCompile,10,89406,0x31bb26fda58,92,afterWriteDispatched node:internal/stream_base_commons:155:30,0x31bb26da688,~
code-source-info,0x31bb26fda58,434,3815,4089,C0O3834C2O3846C7O3862C9O3861C12O3844C16O3880C18O3894C23O3910C25O3909C30O3890C34O3934C35O3942C40O3953C42O3963C48O3996C56O3963C62O3960C66O4004C67O4017C73O4037C81O4072C86O4072C91O4088,,
code-creation,LazyCompile,10,89496,0x31bb26fdcb0,323,onwrite node:internal/streams/writable:428:17,0x31bb26d02d0,~
code-source-info,0x31bb26fdcb0,430,13466,15089,C0O13504C5O13541C10O13566C15O13578C19O13614C26O13641C29O13637C35O13614C40O13671C41O13678C42O13686C43O13700C47O13711C48O13725C52O13735C57O13757C64O13748C68O13769C69O13784C73O13792C77O13896C81O13964C87O13981C89O13995C93O14113C99O14139C104O14154C110O14178C117O14201C121O14218C125O14236C128O14244C148O14244C155O14310C170O14310C177O14378C182O14387C187O14402C191O14394C196O14425C199O14425C204O14464C208O14745C214O14792C219O14811C226O14814C231O14838C242O14862C248O14889C255O14928C261O14932C267O14940C273O14914C277O14957C280O14965C288O14996C293O14965C301O15044C316O15044C322O15088,,
tick,0x1043081,89539,0,0x0,3,0x12da7b0,0x31bb26fdaae,0x31bb26fcbdf,0x31bb26fc8d4,0x31bb26fc58b,0x31bb26fc3fe,0x31bb26fc0bc,0x31bb26fbd8f,0x31bb26fb64b,0x287bc39f586,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,89601,0x31bb26fe100,372,nextTick node:internal/process/task_queues:103:18,0x32bbd7452708,~
script-source,34,node:internal/process/task_queues,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land\x2C\n  // and to avoid unnecessary calls into JS land.\n  tickInfo\x2C\n  // Used to run V8's micro task queue.\n  runMicrotasks\x2C\n  setTickCallback\x2C\n  enqueueMicrotask\x2C\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn\x2C\n  hasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n  symbols: { async_id_symbol\x2C trigger_async_id_symbol }\x2C\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId\x2C tock[trigger_async_id_symbol]\x2C tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0]\x2C args[1]); break;\n            case 3: callback(args[0]\x2C args[1]\x2C args[2]); break;\n            case 4: callback(args[0]\x2C args[1]\x2C args[2]\x2C args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1]\x2C arguments[2]]; break;\n    case 4: args = [arguments[1]\x2C arguments[2]\x2C arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId\x2C\n    [trigger_async_id_symbol]: triggerAsyncId\x2C\n    callback\x2C\n    args\x2C\n  };\n  if (initHooksExist())\n    emitInit(asyncId\x2C 'TickObject'\x2C triggerAsyncId\x2C tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask'\x2C\n    defaultMicrotaskResourceOpts\x2C\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask\x2C asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick\x2C\n      runNextTicks\x2C\n    };\n  }\x2C\n  queueMicrotask\x2C\n};\n
code-source-info,0x31bb26fe100,34,2585,3442,C0O2585C2O2600C10O2600C15O2643C18O2655C24O2669C25O2676C26O2684C28O2710C63O2732C65O2751C74O2768C86O2774C88O2793C97O2810C109O2824C121O2830C123O2849C132O2866C144O2880C156O2894C168O2900C170O2926C175O2953C179O2960C185O2933C191O2985C194O3002C198O2990C203O3023C205O3030C211O3046C214O3035C218O3011C223O2972C226O3058C231O3068C236O3068C242O3083C247O3083C251O3128C256O3128C260O3167C265O3167C269O3216C276O3223C282O3241C289O3255C295O3281C305O3301C315O3315C323O3328C328O3332C333O3354C350O3354C355O3417C360O3423C365O3423C371O3441,,
code-creation,LazyCompile,10,89746,0x31bb26fe970,16,get node:internal/bootstrap/node:91:8,0x23f41f7a69a0,~
code-source-info,0x31bb26fe970,17,3724,3783,C0O3735C6O3767C12O3771C15O3777,,
code-creation,LazyCompile,10,89769,0x31bb26fea60,15,isEmpty node:internal/fixed_queue:95:10,0x32bbd7457620,~
script-source,36,node:internal/fixed_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// Currently optimal queue size\x2C tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or\x2C if there is only one circular buffer\x2C it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one\x2C removing means\n// moving `bottom` forward by one. After reaching the end\x2C the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue\x2C sets the old queue's `.next` to it\x2C\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue\x2C it forms the new tail.\n      this.tail = tail.next;\n      tail.next = null;\n    }\n    return next;\n  }\n};\n
code-source-info,0x31bb26fea60,36,3637,3677,C0O3658C5O3663C10O3663C14O3673,,
code-creation,LazyCompile,10,89893,0x31bb26fef18,13,isEmpty node:internal/fixed_queue:67:10,0x32bbd7457370,~
code-source-info,0x31bb26fef18,36,3084,3129,C0O3105C5O3118C9O3109C12O3125,,
code-creation,LazyCompile,10,89911,0x31bb26ff008,25,setHasTickScheduled node:internal/process/task_queues:51:29,0x32bbd7452618,~
code-source-info,0x31bb26ff008,34,1087,1145,C0O1099C7O1108C12O1129C19O1127C24O1144,,
new,MemoryChunk,0x2dd43b940000,262144
code-creation,LazyCompile,10,90006,0x31bb26ff108,23,newAsyncId node:internal/async_hooks:415:20,0x23f41f7b7798,~
script-source,19,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\x2C\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\x2C\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\x2C\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: name\x2C\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  registerDestroyHook(promise\x2C asyncId);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  const promiseHooks = require('internal/promise_hooks');\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook\x2C\n    before: promiseBeforeHook\x2C\n    after: promiseAfterHook\x2C\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\x2C\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\x2C\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\x2C\n  }\x2C\n  asyncWrap: {\n    Providers: async_wrap.Providers\x2C\n  }\x2C\n};\n
code-source-info,0x31bb26ff108,19,14479,14530,C0O14486C7O14511C16O14526C22O14528,,
code-creation,LazyCompile,10,90550,0x2dd43b9425a8,35,getDefaultTriggerAsyncId node:internal/async_hooks:431:34,0x23f41f7b7838,~
code-source-info,0x2dd43b9425a8,19,14938,15195,C0O14975C7O14991C9O14990C13O15084C14O15110C19O15119C26O15142C28O15141C31O15161C32O15164C34O15193,,
tick,0x119b770,90589,0,0x0,0,0x12f0940,0x31bb26fe21a,0x31bb26fddd5,0x31bb26fdaae,0x31bb26fcbdf,0x31bb26fc8d4,0x31bb26fc58b,0x31bb26fc3fe,0x31bb26fc0bc,0x31bb26fbd8f,0x31bb26fb64b,0x287bc39f586,0xcb3150,0x287bc39e763,0x16cb317,0xb507d0,0x287bc38c674,0x16c843f
code-creation,LazyCompile,10,90601,0x2dd43b9426b8,13,initHooksExist node:internal/async_hooks:476:24,0x23f41f7b79c8,~
code-source-info,0x2dd43b9426b8,19,16156,16188,C0O16163C5O16179C8O16170C12O16186,,
code-creation,LazyCompile,10,90622,0x2dd43b9427a0,16,hasHooks node:internal/async_hooks:468:18,0x23f41f7b7928,~
code-source-info,0x2dd43b9427a0,19,16024,16070,C0O16034C7O16058C12O16064C15O16068,,
code-creation,LazyCompile,10,90644,0x2dd43b9428a8,59,push node:internal/fixed_queue:99:7,0x32bbd7457670,~
code-source-info,0x2dd43b9428a8,36,3685,3945,C0O3707C5O3712C10O3712C16O3871C23O3887C26O3883C32O3881C38O3864C42O3925C47O3930C52O3930C58O3944,,
code-creation,LazyCompile,10,90662,0x2dd43b9429e8,24,isFull node:internal/fixed_queue:71:9,0x32bbd74573c0,~
code-source-info,0x2dd43b9429e8,36,3139,3200,C0O3162C4O3166C10O3173C12O3171C16O3189C20O3180C23O3196,,
code-creation,LazyCompile,10,90679,0x2dd43b942af0,37,push node:internal/fixed_queue:75:7,0x32bbd7457410,~
code-source-info,0x2dd43b942af0,36,3208,3291,C0O3226C5O3236C12O3241C16O3270C20O3274C26O3281C28O3279C31O3262C36O3290,,
code-creation,LazyCompile,10,90710,0x2dd43b942c20,62,Readable.removeListener node:internal/streams/readable:957:45,0x31bb26c20c0,~
code-source-info,0x2dd43b942c20,424,31062,31619,C0O31087C5O31094C10O31104C15O31119C29O31119C35O31193C37O31200C42O31550C45O31558C53O31558C59O31606C61O31617,,
code-creation,LazyCompile,10,90767,0x2dd43b942d98,307,removeListener node:events:679:28,0x28d42e2b1850,~
code-source-info,0x2dd43b942d98,29,19786,21057,C0O19811C3O19811C7O19863C12O19878C14O19912C16O19924C17O19945C19O19951C23O19965C25O19997C27O20009C28O20017C30O20026C35O20047C42O20056C47O20080C54O20091C59O20104C64O20121C66O20136C71O20136C75O20134C81O20181C83O20195C85O20223C91O20256C99O20290C114O20256C121O20336C127O20393C130O20424C134O20431C138O20438C139O20438C144O20461C146O20469C152O20473C159O20493C163O20497C170O20506C175O20534C180O20560C182O20445C187O20406C190O20598C191O20611C196O20626C198O20638C199O20648C200O20661C205O20683C210O20683C216O20717C222O20758C228O20770C233O20794C240O20768C246O20816C251O20816C256O20871C263O20878C268O20895C269O20914C272O20908C276O20939C282O20984C299O20984C304O21039C306O21051,,
code-creation,LazyCompile,10,90832,0x2dd43b9430f0,64,stopListeningIfSignal node:internal/process/signal:43:31,0x13800b160448,~
script-source,58,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\x2C\n};\n
code-source-info,0x2dd43b9430f0,58,936,1101,C0O960C5O972C10O972C16O985C21O1019C26O1019C33O1039C38O1057C43O1057C47O1070C52O1082C57O1088C63O1100,,
code-creation,LazyCompile,10,90923,0x2dd43b943490,318,processTicksAndRejections node:internal/process/task_queues:67:35,0x32bbd74526b8,~
code-source-info,0x2dd43b943490,34,1479,2424,C0O1490C2O1537C7O1528C12O1528C19O1571C21O1576C23O1575C27O1600C34O1625C36O1624C46O1600C54O1701C59O1728C65O1760C70O1817C75O1846C110O1876C111O1889C115O1876C119O1895C121O1922C122O1935C128O1944C132O1922C137O1950C139O1977C140O1990C146O1999C152O2008C156O1977C161O2014C163O2041C164O2054C170O2063C176O2072C182O2081C186O2041C191O2087C193O2115C198O2115C215O2182C220O2186C225O2217C230O2217C245O2254C250O2254C256O2284C261O2284C264O2329C269O2319C274O2319C282O2332C285O2332C290O1498C296O2363C301O2363C305O2393C312O2393C317O2423,,
code-creation,LazyCompile,10,90955,0x2dd43b943760,48,shift node:internal/fixed_queue:108:8,0x32bbd74576c0,~
code-source-info,0x2dd43b943760,36,3954,4204,C0O3981C5O4009C10O4009C15O4031C20O4031C26O4049C32O4148C36O4141C40O4160C41O4170C45O4188C47O4200,,
code-creation,LazyCompile,10,90977,0x2dd43b9438a8,54,shift node:internal/fixed_queue:80:8,0x32bbd7457460,~
code-source-info,0x2dd43b9438a8,36,3300,3510,C0O3331C5O3341C9O3335C13O3354C15O3388C16O3400C17O3410C22O3420C28O3428C32O3465C36O3472C42O3479C44O3477C47O3457C51O3490C53O3506,,
code-creation,LazyCompile,10,91001,0x2dd43b9439e0,42,emitBeforeScript node:internal/async_hooks:507:26,0x23f41f7b7b58,~
code-source-info,0x2dd43b9439e0,19,16826,16977,C0O16866C12O16866C17O16922C22O16935C25O16926C31O16949C36O16949C41O16976,,
code-creation,LazyCompile,10,91029,0x2dd43b943b38,180,pushAsyncContext node:internal/async_hooks:537:26,0x23f41f7b7c98,~
code-source-info,0x2dd43b943b38,19,17470,18015,C0O17525C7O17543C9O17542C13O17560C20O17594C24O17608C26O17619C32O17626C35O17637C40O17653C44O17623C49O17665C54O17672C59O17715C60O17718C65O17729C72O17752C78O17759C83O17775C85O17774C88O17757C92O17797C97O17808C104O17831C107O17835C113O17842C118O17858C120O17857C123O17840C127O17878C134O17896C142O17909C146O17915C153O17931C158O17950C162O17963C169O17979C174O17996C179O18014,,
code-creation,LazyCompile,10,91063,0x2dd43b943d40,46,afterWriteTick node:internal/streams/writable:485:24,0x31bb26d0320,~
code-source-info,0x2dd43b943d40,430,15114,15230,C0O15117C5O15125C10O15132C15O15139C20O15149C21O15174C25O15184C40O15191C45O15228,,
code-creation,LazyCompile,10,91095,0x2dd43b943e98,104,afterWrite node:internal/streams/writable:490:20,0x31bb26d0370,~
code-source-info,0x2dd43b943e98,430,15251,15607,C0O15307C7O15325C14O15344C20O15351C25O15370C30O15383C32O15404C33O15420C37O15440C45O15440C50O15477C60O15477C65O15488C71O15503C75O15511C78O15462C81O15534C87O15551C90O15551C94O15578C97O15578C103O15606,,
code-creation,LazyCompile,10,91120,0x2dd43b944020,35,get node:internal/streams/duplex:103:8,0x287bc3bdbe8,~
code-source-info,0x2dd43b944020,423,3814,4023,C0O3834C6O3879C12O3919C13O3932C14O3959C19O3974C25O3992C30O4007C34O4017,,
code-creation,LazyCompile,10,91137,0x2dd43b944128,17,get node:internal/streams/readable:109:8,0x31bb26cbc08,~
code-source-info,0x2dd43b944128,424,3358,3397,C0O3376C7O3382C12O3389C16O3395,,
code-creation,LazyCompile,10,91164,0x2dd43b944250,87, node:internal/console/constructor:359:10,0x3a1b5d3112e0,~
code-source-info,0x2dd43b944250,50,10746,11564,C0O10963C7O10980C9O10976C17O11008C26O11027C31O11040C35O11068C40O11083C46O11479C54O11479C61O11502C66O11526C79O11526C86O11563,,
code-creation,LazyCompile,10,91207,0x2dd43b944400,97,finishMaybe node:internal/streams/writable:718:21,0x31bb26d0578,~
code-source-info,0x2dd43b944400,430,21015,21494,C0O21041C3O21045C9O21070C12O21070C17O21110C23O21120C28O21135C32O21155C38O21170C42O21182C45O21190C61O21190C68O21392C71O21396C77O21425C83O21440C87O21452C90O21452C96O21493,,
code-creation,LazyCompile,10,91232,0x2dd43b9445e0,80,needFinish node:internal/streams/writable:653:20,0x31bb26d0460,~
code-source-info,0x2dd43b9445e0,430,19417,19738,C0O19443C6O19470C13O19499C19O19530C25O19537C30O19563C37O19590C42O19599C48O19606C53O19632C60O19661C67O19689C74O19722C79O19736,,
code-creation,LazyCompile,10,91252,0x2dd43b944728,13,destroyHooksExist node:internal/async_hooks:484:27,0x23f41f7b7a68,~
code-source-info,0x2dd43b944728,19,16275,16310,C0O16282C5O16298C8O16289C12O16308,,
code-creation,LazyCompile,10,91268,0x2dd43b944818,32,emitAfterScript node:internal/async_hooks:515:25,0x23f41f7b7ba8,~
code-source-info,0x2dd43b944818,19,17004,17100,C0O17018C5O17031C8O17022C14O17044C19O17044C23O17073C26O17073C31O17099,,
code-creation,LazyCompile,10,91299,0x2dd43b944980,167,popAsyncContext node:internal/async_hooks:551:25,0x23f41f7b7ce8,~
code-source-info,0x2dd43b944980,19,18104,18691,C0O18138C7O18156C9O18155C13O18173C14O18189C19O18196C20O18209C21O18213C24O18217C31O18240C36O18256C38O18255C44O18275C49O18357C54O18364C58O18390C59O18413C61O18425C65O18432C72O18448C77O18469C80O18480C87O18498C90O18495C93O18467C97O18511C104O18527C109O18546C112O18557C119O18575C122O18584C125O18572C128O18544C132O18592C137O18618C142O18618C146O18627C153O18645C158O18659C162O18671C163O18685C166O18689,,
code-creation,LazyCompile,10,91318,0x2dd43b944b60,13,enabledHooksExist node:internal/async_hooks:472:27,0x23f41f7b7978,~
code-source-info,0x2dd43b944b60,19,16098,16131,C0O16105C5O16121C8O16112C12O16129,,
code-creation,LazyCompile,10,91419,0x2dd43b944e28,627,processPromiseRejections node:internal/process/promises:220:34,0x32bbd7455ce8,~
script-source,35,node:internal/process/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeWeakMap\x2C\n} = primordials;\n\nconst {\n  tickInfo\x2C\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler\x2C\n    kPromiseHandlerAddedAfterReject\x2C\n    kPromiseResolveAfterResolved\x2C\n    kPromiseRejectAfterResolved\x2C\n  }\x2C\n  setPromiseRejectCallback\x2C\n} = internalBinding('task_queue');\n\nconst { deprecate } = require('internal/util');\n\nconst {\n  noSideEffectsToString\x2C\n  triggerUncaughtException\x2C\n} = internalBinding('errors');\n\nconst {\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  symbols: {\n    async_id_symbol: kAsyncIdSymbol\x2C\n    trigger_async_id_symbol: kTriggerAsyncIdSymbol\x2C\n  }\x2C\n} = require('internal/async_hooks');\nconst { isErrorStackTraceLimitWritable } = require('internal/errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection'\x2C but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection'\x2C then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\n// Otherwise\x2C emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled\x2C emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'UnhandledPromiseRejectionWarning'\x2C then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction isErrorLike(o) {\n  return typeof o === 'object' &&\n         o !== null &&\n         ObjectPrototypeHasOwnProperty(o\x2C 'stack');\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type\x2C promise\x2C reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise\x2C reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve'\x2C promise\x2C reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject'\x2C promise\x2C reason);\n      break;\n  }\n}\n\nconst multipleResolvesDeprecate = deprecate(\n  () => {}\x2C\n  'The multipleResolves event has been deprecated.'\x2C\n  'DEP0160'\x2C\n);\nfunction resolveError(type\x2C promise\x2C reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    if (process.emit('multipleResolves'\x2C type\x2C promise\x2C reason)) {\n      multipleResolvesDeprecate();\n    }\n  });\n}\n\nfunction unhandledRejection(promise\x2C reason) {\n  const emit = (reason\x2C promise\x2C promiseInfo) => {\n    if (promiseInfo.domain) {\n      return promiseInfo.domain.emit('error'\x2C reason);\n    }\n    return process.emit('unhandledRejection'\x2C reason\x2C promise);\n  };\n\n  maybeUnhandledPromises.set(promise\x2C {\n    reason\x2C\n    uid: ++lastPromiseId\x2C\n    warned: false\x2C\n    domain: process.domain\x2C\n    emit\x2C\n  });\n  // This causes the promise to be referenced at least for one tick.\n  ArrayPrototypePush(pendingUnhandledRejections\x2C promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections\x2C { promise\x2C warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid\x2C reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName\x2C\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block\x2C ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection\x2C use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\x2C\n  );\n  try {\n    if (isErrorLike(reason)) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack\x2C unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    }\n  } catch {\n    try {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    } catch {\n      // Ignore.\n    }\n  }\n\n  process.emitWarning(warning);\n}\n\n// If this method returns true\x2C we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise\x2C warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit('rejectionHandled'\x2C promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason\x2C uid\x2C emit } = promiseInfo;\n\n    let needPop = true;\n    const {\n      [kAsyncIdSymbol]: promiseAsyncId\x2C\n      [kTriggerAsyncIdSymbol]: promiseTriggerAsyncId\x2C\n    } = promise;\n    // We need to check if async_hooks are enabled\n    // don't use enabledHooksExist as a Promise could\n    // come from a vm.* context and not have an async id\n    if (typeof promiseAsyncId !== 'undefined') {\n      pushAsyncContext(\n        promiseAsyncId\x2C\n        promiseTriggerAsyncId\x2C\n        promise\x2C\n      );\n    }\n    try {\n      switch (unhandledRejectionsMode) {\n        case kStrictUnhandledRejections: {\n          const err = isErrorLike(reason) ?\n            reason : generateUnhandledRejectionError(reason);\n          // This destroys the async stack\x2C don't clear it after\n          triggerUncaughtException(err\x2C true /* fromPromise */);\n          if (typeof promiseAsyncId !== 'undefined') {\n            pushAsyncContext(\n              promise[kAsyncIdSymbol]\x2C\n              promise[kTriggerAsyncIdSymbol]\x2C\n              promise\x2C\n            );\n          }\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kIgnoreUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          break;\n        }\n        case kAlwaysWarnUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kThrowUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            const err = isErrorLike(reason) ?\n              reason : generateUnhandledRejectionError(reason);\n              // This destroys the async stack\x2C don't clear it after\n            triggerUncaughtException(err\x2C true /* fromPromise */);\n            needPop = false;\n          }\n          break;\n        }\n        case kWarnWithErrorCodeUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            emitUnhandledRejectionWarning(uid\x2C reason);\n            process.exitCode = 1;\n          }\n          break;\n        }\n      }\n    } finally {\n      if (needPop) {\n        if (typeof promiseAsyncId !== 'undefined') {\n          popAsyncContext(promiseAsyncId);\n        }\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name\x2C message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: name\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\x2C\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block\x2C ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `"${noSideEffectsToString(reason)}".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection'\x2C message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn\x2C\n  setHasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n};\n
code-source-info,0x2dd43b944e28,35,6669,9797,C0O6714C6O6737C13O6744C17O6789C23O6782C30O6789C35O6829C43O6849C47O6829C53O6808C58O6817C64O6878C68O6891C78O6891C86O6934C90O6942C96O6942C101O6752C104O6987C110O7014C115O7034C126O7034C128O7060C136O7080C140O7060C145O7133C151O7156C157O7156C163O7174C165O7213C167O7233C168O7252C172O7272C177O7280C182O7285C187O7326C189O7446C198O7342C203O7368C215O7415C227O7621C233O7672C248O7672C256O7793C264O7841C273O8497C282O8613C291O8787C300O9231C309O7893C313O7893C327O7936C332O8052C341O8052C346O8117C352O8174C360O8214C362O8213C369O8253C371O8252C379O8174C384O8353C393O8353C399O8399C401O8413C405O8413C410O8467C412O8537C421O8537C426O8583C428O8657C437O8657C442O8703C446O8703C451O8757C453O8842C462O8842C468O8888C470O8928C474O8928C488O8973C493O9095C502O9095C507O9162C509O9201C511O9298C520O9298C526O9344C528O9372C532O9372C537O9428C543O9445C547O9472C564O9519C570O9542C576O9597C582O9597C597O9658C599O7024C605O9704C611O9755C615O9782C622O9789C626O9795,,
tick,0x7f6e64f83003,91789,0,0x0,3,0x12da7b0,0x2dd43b9435ad
code-creation,LazyCompile,10,91804,0x2dd43b945dd0,25,setHasRejectionToWarn node:internal/process/promises:77:31,0x32bbd74556d0,~
code-source-info,0x2dd43b945dd0,35,2149,2209,C0O2161C7O2170C12O2193C19O2191C24O2208,,
profiler,end
delete,MemoryChunk,0x2aac13700000
delete,MemoryChunk,0x23f41f780000
delete,MemoryChunk,0x28d42e280000
delete,MemoryChunk,0x32bbd7440000
delete,MemoryChunk,0x13800b140000
delete,MemoryChunk,0x1d7bd0ec0000
delete,MemoryChunk,0x556af5c0000
delete,MemoryChunk,0x227cb5380000
delete,MemoryChunk,0x3694bf280000
delete,MemoryChunk,0x3f370e3c0000
delete,MemoryChunk,0x3a1b5d300000
delete,MemoryChunk,0x2ffc48500000
delete,MemoryChunk,0x287bc380000
delete,MemoryChunk,0x31bb26c0000
delete,MemoryChunk,0x2dd43b940000
delete,MemoryChunk,0x6580000
delete,MemoryChunk,0x65c0000
delete,MemoryChunk,0x2bd542180000
delete,MemoryChunk,0x33c0d1780000
delete,MemoryChunk,0x796b5680000
delete,MemoryChunk,0x3ea77c980000
delete,MemoryChunk,0x2801da800000
delete,MemoryChunk,0x3cdec0880000
